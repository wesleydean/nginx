<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <!-- Content Security Policy for local development -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' https://balanced-shiner-88.clerk.accounts.dev https://clerk.com https://*.clerk.com https://clerk-telemetry.com https://*.clerk-telemetry.com https://api.stripe.com https://*.js.stripe.com https://js.stripe.com https://maps.googleapis.com https://*.sentry-cdn.com https://*.sentry.io https://challenges.cloudflare.com https://cdn.jsdelivr.net https://cdnjs.cloudflare.com https://unpkg.com https://www.gstatic.com https://cdn.plaid.com http://localhost:5000 http://127.0.0.1:5000 https://plaid-api-production.up.railway.app; connect-src 'self' https://balanced-shiner-88.clerk.accounts.dev https://clerk.com https://*.clerk.com https://clerk-telemetry.com https://*.clerk-telemetry.com https://api.stripe.com https://*.js.stripe.com https://js.stripe.com https://maps.googleapis.com https://*.sentry-cdn.com https://*.sentry.io https://challenges.cloudflare.com https://cdn.jsdelivr.net https://cdnjs.cloudflare.com https://unpkg.com https://www.gstatic.com https://cdn.plaid.com http://localhost:5000 http://127.0.0.1:5000 https://plaid-api-production.up.railway.app; worker-src 'self' blob:;">
    <title>Expense Tracker</title>
    
    <!-- Web App Manifest -->
    <link rel="manifest" href="manifest.json">
    
    <!-- iOS specific meta tags -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Expenses">
    
    <!-- Capacitor and haptic feedback support -->
    <script src="capacitor.js"></script>
    <script src="haptics.js"></script>
    <script src="haptic-debug.js"></script>
    <!-- Add this in the head section -->
    <script src="https://cdn.plaid.com/link/v2/stable/link-initialize.js"></script>
    <script src="js/plaid-service.js"></script>
    
    <!-- iOS icons -->
    <link rel="apple-touch-icon" href="icons/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="152x152" href="icons/icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="167x167" href="icons/icon-167x167.png">
    
    <!-- iOS splash screens -->
    <link rel="apple-touch-startup-image" href="icons/apple-splash-2048-2732.png" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="icons/apple-splash-1668-2388.png" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="icons/apple-splash-1536-2048.png" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="icons/apple-splash-1125-2436.png" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="icons/apple-splash-1242-2688.png" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="icons/apple-splash-828-1792.png" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="icons/apple-splash-1242-2208.png" media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="icons/apple-splash-750-1334.png" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="icons/apple-splash-640-1136.png" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
    
    
    <!-- Theme color for browser chrome -->
    <meta name="theme-color" content="#3b82f6">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
     <script
        async
        crossorigin="anonymous"
        data-clerk-publishable-key="pk_test_YmFsYW5jZWQtc2hpbmVyLTg4LmNsZXJrLmFjY291bnRzLmRldiQ" 
        src="https://balanced-shiner-88.clerk.accounts.dev/npm/@clerk/clerk-js@5/dist/clerk.browser.js"
        type="text/javascript">
    </script>
    <script>
        // Initialize Lucide icons when the DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            initializeLucideIcons();
            
            // Add additional retries with increasing delays
            setTimeout(initializeLucideIcons, 500);
            setTimeout(initializeLucideIcons, 1000);
        });
        
        // Debounced icon initialization to prevent conflicts
        let iconInitTimeout = null;
        let iconInitInProgress = false;
        
        function initializeLucideIcons() {
            // Clear any pending initialization
            if (iconInitTimeout) {
                clearTimeout(iconInitTimeout);
            }
            
            // Debounce the actual initialization
            iconInitTimeout = setTimeout(() => {
                if (iconInitInProgress) return;
                
                if (window.lucide && typeof window.lucide.createIcons === 'function') {
                    try {
                        iconInitInProgress = true;
                        window.lucide.createIcons();
                    } catch (error) {
                        console.error('Error initializing Lucide icons:', error);
                    } finally {
                        iconInitInProgress = false;
                    }
                } else {
                    console.warn('Lucide not loaded yet, retrying...');
                    setTimeout(initializeLucideIcons, 100);
                }
            }, 50); // 50ms debounce
        }
        
        // Global function for safe icon initialization
        window.safeInitLucideIcons = initializeLucideIcons;
        
        // Special function for transaction/expense lists that need immediate icon rendering
        function initializeTransactionIcons() {
            
            // For transaction lists, we need more immediate rendering
            if (window.lucide && typeof window.lucide.createIcons === 'function') {
                try {
                    // Use requestAnimationFrame to ensure DOM is ready
                    requestAnimationFrame(() => {
                        // Double-check that lucide is still available
                        if (window.lucide && typeof window.lucide.createIcons === 'function') {
                            window.lucide.createIcons();
                        } else {
                            console.warn('Lucide became unavailable during requestAnimationFrame');
                        }
                    });
                } catch (error) {
                    console.error('Error initializing transaction icons:', error);
                    // Fallback to safe method
                    if (window.safeInitLucideIcons) {
                        window.safeInitLucideIcons();
                    }
                }
            } else {
                console.warn('Lucide not immediately available, trying fallbacks');
                // Try multiple fallback strategies
                
                // Strategy 1: Wait a bit and try again
                setTimeout(() => {
                    if (window.lucide && typeof window.lucide.createIcons === 'function') {
                        window.lucide.createIcons();
                    } else {
                        console.warn('Lucide still not available after timeout');
                        // Strategy 2: Use the safe method
                        if (window.safeInitLucideIcons) {
                            window.safeInitLucideIcons();
                        }
                    }
                }, 100);
            }
        }
        
        window.initializeTransactionIcons = initializeTransactionIcons;
        
        // Emergency fix function to find and initialize any missed icons
        function emergencyIconFix() {
            const uninitialized = document.querySelectorAll('[data-lucide]:not([data-lucide-initialized])');
            if (uninitialized.length > 0) {
                if (window.lucide && typeof window.lucide.createIcons === 'function') {
                    window.lucide.createIcons();
                } else {
                    console.warn('Emergency icon fix failed - Lucide not available');
                }
            }
        }
        
        window.emergencyIconFix = emergencyIconFix;
        
        // Emergency fix can be called manually if needed, but no polling
        // setInterval(emergencyIconFix, 2000);
    </script>
    
    <style>
        
        #user-button {
            /* position: absolute; */
            z-index: 100;
            top: 15px;
            left: 15px;
        }
        /* shadcn/ui Design System */
        :root {
            /* Colors */
            --background: 0 0% 100%;
            --foreground: 222.2 84% 4.9%;
            --card: 0 0% 100%;
            --card-foreground: 222.2 84% 4.9%;
            --popover: 0 0% 100%;
            --popover-foreground: 222.2 84% 4.9%;
            --primary: 221.2 83.2% 53.3%;
            --primary-foreground: 210 40% 98%;
            --secondary: 210 40% 96%;
            --secondary-foreground: 222.2 84% 4.9%;
            --muted: 210 40% 96%;
            --muted-foreground: 215.4deg 24.61% 40.65%;
            --accent: 210 40% 96%;
            --accent-foreground: 222.2 84% 4.9%;
            --destructive: 0 84.2% 60.2%;
            --destructive-foreground: 210 40% 98%;
            --border: 214.3 31.8% 91.4%;
            --input: 214.3 31.8% 91.4%;
            --ring: 221.2 83.2% 53.3%;
            --radius: 0.5rem;
            
            /* Success & Warning */
            --success: 142.1 76.2% 36.3%;
            --success-foreground: 210 40% 98%;
            --warning: 47.9 95.8% 53.1%;
            --warning-foreground: 26 83.3% 14.1%;
        }
        
        /* Dark Mode */
        @media (prefers-color-scheme: dark) {
            :root {
                --background: 222.2 84% 4.9%;
                --foreground: 210 40% 98%;
                --card: 222.2 84% 4.9%;
                --card-foreground: 210 40% 98%;
                --primary: 217.2 91.2% 59.8%;
                --primary-foreground: 222.2 84% 4.9%;
                --secondary: 217.2 32.6% 17.5%;
                --secondary-foreground: 210 40% 98%;
                --muted: 217.2 32.6% 17.5%;
                --muted-foreground: 215 20.2% 65.1%;
                --accent: 217.2 32.6% 17.5%;
                --accent-foreground: 210 40% 98%;
                --destructive: 0 62.8% 30.6%;
                --destructive-foreground: 210 40% 98%;
                --border: 217.2 32.6% 17.5%;
                --input: 217.2 32.6% 17.5%;
                --ring: 224.3 76.3% 94.1%;
            }
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            border-color: hsl(var(--border));
            /* Disable text selection and improve mobile touch behavior */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            /* Optimize touch behavior for mobile */
            -webkit-touch-callout: none;
            -webkit-touch-action: manipulation;
            touch-action: manipulation;
        }
        
        /* Allow text selection for specific elements that need it */
        input, textarea, [contenteditable="true"], .selectable-text {
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            user-select: text;
        }
        
        /* Prevent text selection on buttons and interactive elements */
        button, .btn, .swipe-container, .expense-item, .balance-item, .card {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
            -webkit-touch-action: manipulation;
            touch-action: manipulation;
        }
        
        /* Disable context menu on long press for mobile */
        * {
            -webkit-touch-callout: none;
        }
        
        /* Improve touch targets for mobile */
        .btn, button, .swipe-container, .expense-item, .balance-item {
            min-height: 44px; /* iOS recommended minimum touch target */
            min-width: 44px;
        }
        
        /* Ensure all form elements have minimum touch target size */
        input, select, textarea, .form-input, .date-input, .select-trigger, .date-picker-trigger, .datepicker-trigger {
            min-height: 44px; /* iOS recommended minimum touch target */
        }
        
        /* Disable hover effects on touch devices */
        @media (hover: none) and (pointer: coarse) {
            .btn:hover, button:hover, .swipe-action:hover {
                background-color: inherit;
            }
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: hsl(var(--background));
            color: hsl(var(--foreground));
            height: 100vh;
            overflow: hidden;
            font-feature-settings: "rlig" 1, "calt" 1;
        }
        
        /* Card Components */
        .stat-card, .home-section, .modern-balance-card {
            background-color: hsl(var(--card));
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
        }
        
        /* Account Section Headers */
        .account-section-header {
                font-size: 1.2rem;
                font-weight: 400;
                margin: 1.5rem 0 0.75rem 0.4rem;
                color: hsl(220, 13%, 28%);
        }

        /* New Accounts Layout - Match Cashflow Styling */
        .accounts-list {
            margin: 0 -1rem;
        }

        .account-group-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 1rem;
            margin-bottom: 0;
            background: hsl(0deg 0% 0% / 2%);
            font-weight: 600;
        }
        
        .account-group-title {
            font-size: 0.875rem;
            font-weight: 600;
            color: hsl(var(--foreground));
        }
        
        .account-group-total {
            font-size: 0.875rem;
            font-weight: 600;
            color: hsl(var(--foreground));
        }
        
        .account-item {
            display: flex;
            flex: 1;
            align-items: center;
            padding: 0.5rem;
            background-color: hsl(var(--card));
            border-bottom: 1px solid hsl(var(--border));
            transition: transform 0.12s, background-color 0.16s;
            cursor: pointer;
            gap: 0.75rem;
        }
        
        .account-item:active {
            transform: scale(0.98);
            background-color: hsl(var(--muted));
        }
        
        .account-icon {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .account-info {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .account-name {
            font-size: 1rem;
            font-weight: 500;
            color: hsl(var(--foreground));
            margin-bottom: 0.125rem;
        }
        
        .account-balance {
            font-size: 1rem;
            color: hsl(var(--foreground));
            text-align: right;
        }
        

        .date-group-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 1rem;
            margin: 0;
            background: hsl(0deg 0% 0% / 2%);
            font-weight: 600;
            position: sticky;
            top: 86px; /* Account for fixed header height */
            z-index: 10;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        .transaction-item {
            display: flex;
            flex: 1;
            align-items: center;
            padding: 0.6rem 1rem;
            background-color: hsl(var(--card));
            border: 1px solid hsl(var(--border));
            border-radius: 0;
            transition: transform 0.12s, background-color 0.16s;
            cursor: pointer;
            gap: 0.75rem;
        }

        .transaction-item:active {
            transform: scale(0.98);
            background-color: hsl(var(--muted));
        }

        .transaction-icon {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: hsl(var(--muted) / 0.3);
            color: hsl(var(--muted-foreground));
        }

        .transaction-info {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .transaction-description {
            display: flex;
            font-weight: 500;
            color: hsl(var(--foreground));
            margin-bottom: 0.1rem;
            font-size: 0.875rem;
            align-items: center;
            gap: 0.5rem;
            line-height: 1.4;
        }

        .transaction-category {
            font-size: 0.75rem;
            color: hsl(var(--muted-foreground));
        }

        .transaction-amount {
            font-size: 0.875rem;
            font-weight: 600;
            text-align: right;
        }

        /* Account Type Chart - Match cashflow chart style */
        .investment-visual {
            background: linear-gradient(to bottom, #f59e0b73, #ffffff00);
            border: 2px solid #f59e0b;
            border-bottom: 0;
        }
        
        .cash-visual {
            background: linear-gradient(to bottom, #06b6d473, #ffffff00);
            border: 2px solid #06b6d4;
            border-bottom: 0;
        }
        
        .debt-visual {
            background: linear-gradient(to bottom, #ef444473, #ffffff00);
            border: 2px solid #ef4444;
            border-bottom: 0;
        }

        .stat-card, .home-section, .account-type-section, .modern-balance-card {
            background-color: hsl(var(--card));
        }
        /* Button Components */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            white-space: nowrap;
            border-radius: var(--radius);
            font-size: 0.875rem;
            font-weight: 500;
            transition: all 150ms ease;
            cursor: pointer;
            user-select: none;
            border: 1px solid transparent;
            position: relative;
            overflow: hidden;
            text-decoration: none;
        }
        
        .btn:disabled {
            pointer-events: none;
            opacity: 0.5;
        }
        
        .btn:focus-visible {
            outline: 2px solid hsl(var(--ring));
            outline-offset: 2px;
        }
        
        .btn-primary {
            background-color: hsl(var(--primary));
            color: hsl(var(--primary-foreground));
        }
        
        .btn-primary:hover {
            background-color: hsl(var(--primary) / 0.9);
        }
        
        .btn-secondary {
            background-color: hsl(var(--secondary));
            color: hsl(var(--secondary-foreground));
        }
        
        .btn-secondary:hover {
            background-color: hsl(var(--secondary) / 0.8);
        }
        
        .btn-outline {
            border: 1px solid hsl(var(--border));
            background-color: hsl(var(--background));
            color: hsl(var(--foreground));
        }
        
        .btn-outline:hover {
            background-color: hsl(var(--accent));
            color: hsl(var(--accent-foreground));
        }
        
        .btn-ghost {
            background-color: transparent;
            color: hsl(var(--foreground));
        }
        
        .btn-ghost:hover {
            background-color: hsl(var(--accent));
            color: hsl(var(--accent-foreground));
        }
        
        .btn-destructive {
            background-color: hsl(var(--destructive));
            color: hsl(var(--destructive-foreground));
        }
        
        .btn-destructive:hover {
            background-color: hsl(var(--destructive) / 0.9);
        }
        
        /* Button Sizes */
        .btn-sm {
            height: 2rem;
            padding: 0 0.75rem;
            font-size: 0.8rem;
        }
        
        .btn-xs {
            height: 1.5rem;
            padding: 0.8rem;
            min-height: 0;
        }
        
        .btn-md {
            height: 2.5rem;
            padding: 0 1rem;
        }
        
        .btn-lg {
            height: 2.75rem;
            padding: 0 2rem;
        }
        
        .btn-icon {
            height: 2.5rem;
            width: 2.5rem;
            padding: 0;
        }
        
        /* Card Components */
        .card {
            color: hsl(var(--card-foreground));
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
            padding: .2rem;
        }
        
        /* Today view: remove borders and shadows from main cards */
        .today-view .card {
            border: none;
            box-shadow: none;
            background-color: transparent;
        }
        
        /* Keep borders for specific cards in today view that need them */
        .today-view .expense-item {
            border: 1px solid hsl(var(--border));
            box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
        }
        
        .today-view .balance-item {
            border: 1px solid hsl(var(--border));
            box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
        }
        
        /* Month view: remove borders and shadows from main cards */
        
       
        
        .expense-item:active {
            transform: scale(0.98);
            background-color: hsl(var(--muted));
        }
        
        .balance-item {
            border: 1px solid hsl(var(--border));
            box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
        }
        

        .swipe-container {
            position: relative;
            border-radius: 0;
            background-color: hsl(var(--background)); /* Changed from destructive to background */
            position: relative;
            overflow: hidden;
            width: 100%;
            border-radius: 0;
            /* margin-bottom: 8px; */
            touch-action: pan-y; /* Change to pan-y to enable horizontal swiping */
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            overflow: hidden;
        }
       
         .swipe-action {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            background: hsl(260deg 54.55% 69.74%);
            color: hsl(var(--destructive-foreground));
            width: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            font-weight: bold;
            cursor: pointer;
            z-index: 1;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            font-weight: bold;
            cursor: pointer;
            z-index: 0;
            -webkit-tap-highlight-color: rgba(255,255,255,0.3);
            touch-action: manipulation;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            z-index: 0; /* Higher z-index to ensure it's above other elements */
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
            touch-action: none; /* Disable browser handling of all panning and zooming gestures */
        }
        
        .swipe-action:hover {
            background-color: hsl(var(--destructive) / 0.9);
        }
        
        .swipe-container.swiped .swipe-content {
            transform: translateX(-80px);
            border-right: none;
            border-top-right-radius: 0;
            border-bottom-right-radius: 0;
        }
        
        /* Ensure swipe container maintains background even when swiped */
        .swipe-container.swiped {
            background-color: hsl(var(--background));
        }
        
        .swipe-container.deleting {
            animation: fade-out 0.45s cubic-bezier(0.4, 0, 0.2, 1) forwards;
            pointer-events: none;
            overflow: hidden;
        }
        
        .swipe-container.deleting .swipe-content {
            opacity: 0;
            transition: opacity 0.45s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        @keyframes fade-out {
            0% {
                height: auto;
                margin-bottom: 0.5rem;
                opacity: 1;
            }
            70% {
                height: auto;
                margin-bottom: 0.5rem;
                opacity: 0;
            }
            100% {
                height: 0;
                margin-bottom: 0;
                opacity: 0;
            }
        }
        
        /* Hide original delete buttons when swipe is enabled */
        .swipe-container .delete-btn,
        .swipe-container .delete-balance-btn {
            display: none;
        }
        
        /* Items inside swipe containers should fill the container completely */
        .swipe-container .expense-item {
            border: none;
            box-shadow: none;
            background-color: hsl(var(--card));
            width: 100%;
            margin: 0;
            height: 100%;
            border-radius: 0; /* This matches parent container's radius */
            display: flex;
            align-items: center;
        }
        
        .swipe-container .balance-item {
            border: none;
            box-shadow: none;
            background-color: hsl(var(--card));
            width: 100%;
            margin: 0;
            height: 100%;
            border-radius: var(--radius); /* This matches parent container's radius */
            display: flex;
            align-items: center;
        }
        
        /* Keep borders for slide-out content and modals */
        .slide-out-content .card,
        .modal-content .card,
        .account-management-content .card {
            border: 1px solid hsl(var(--border));
            box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
            background-color: hsl(var(--card));
        }
        
        /* Give stat cards a subtle background for better visual separation */
        .stat-card {
            background-color: hsl(var(--muted) / 0.3);
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            text-align: left;
            align-items: flex-start;
            padding: 1rem;
        }
        .stat-card > div {
            text-align: left;
            margin-left: 0 !important;
            padding-left: 0 !important;
        }
        .stat-card .text-sm,
        .stat-card .text-2xl,
        .stat-card .stat-label,
        .stat-card .stat-value {
            text-align: left;
            margin-left: 0 !important;
            padding-left: 0 !important;
        }
        
        .card-header {
            position: sticky;
            display: flex;
            flex-direction: row;
            align-items: center;
        }
        
        .card-title {
            font-size: 1.5rem;
            font-weight: 600;
            line-height: 1.2;
            margin: 0;
            color: hsl(var(--foreground));
        }
        
        .card-description {
            font-size: 0.875rem;
            color: hsl(var(--muted-foreground));
            margin-top: 0.375rem;
        }
        
        .card-content {
            padding: 0;
        }
        
        /* Income/Spending Bar Chart Layout */

        #budgetDisplay {
            overflow: hidden;
            margin-bottom: 0;
        }

        #budgetDisplay .card-content {
            padding: 0;
        }
        
        .income-spending-chart {
            display: flex;
            align-items: end;
            justify-content: center;
            gap: 1.5rem;
            padding: 2rem 1rem 1rem 1rem;
            height: 140px;
            position: relative;
        }
        
        .monthly-spending-chart {
            display: flex;
            align-items: end;
            gap: 0.5rem;
            padding: 2rem 1rem 0.5rem 1rem;
            height: 140px;
            position: relative;
            overflow-x: auto;
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
        }
        
        .monthly-spending-chart .chart-bar {
            min-width: 40px;
            max-width: 40px;
            flex-shrink: 0;
            cursor: pointer;
            transition: opacity 0.2s ease;
        }
        
        .monthly-spending-chart .chart-bar:hover {
            opacity: 0.8;
        }
        
        .monthly-spending-chart .chart-bar.selected .bar-visual {
            border-width: 2px !important;
            background: linear-gradient(to bottom, rgba(139, 92, 246, 1) 0%, rgba(139, 92, 246, 0.6) 100%) !important;
            opacity: 1 !important;
        }
        
        .monthly-spending-chart .chart-bar.selected .bar-visual.zero-or-negative {
            border: 2px solid #6b7280 !important;
            background: linear-gradient(to bottom, rgba(107, 114, 128, 0.9) 0%, rgba(107, 114, 128, 0.6) 100%) !important;
        }
        
        /* Push button effect for chart bars */
        .monthly-spending-chart .chart-bar .bar-visual {
            transition: transform 0.1s ease, box-shadow 0.1s ease;
        }
        
        .monthly-spending-chart .chart-bar .bar-visual:active {
            transform: scale(0.95);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .monthly-spending-chart .chart-bar.current-month .bar-visual {
            background: rgba(139, 92, 246, 0.24);
        }
        
        .monthly-spending-chart .chart-bar.current-month .bar-visual.zero-or-negative {
            background: rgba(107, 114, 128, 0.4);
        }
        
        .monthly-spending-chart .chart-bar:not(.current-month):not(.selected) .bar-visual {
            opacity: 0.7;
        }
        
        /* Fade out non-selected bars when one is selected */
        .monthly-spending-chart.has-selection .chart-bar:not(.selected) {
            opacity: 0.3;
            transition: opacity 0.3s ease;
        }
        
        .monthly-spending-chart.has-selection .chart-bar.selected {
            opacity: 1;
            transition: opacity 0.3s ease;
        }
        
        .monthly-spending-chart .bar-visual {
            border: 1px solid #8b5cf6;
            background: linear-gradient(to bottom, rgba(139, 92, 246, 0.8) 0%, rgba(139, 92, 246, 0.4) 100%);
            border-radius: 4px;
        }
        
        .monthly-spending-chart .bar-visual.zero-or-negative {
            border: 1px solid #d1d5db;
            background: #d8d8d8;
        }
        
        .selected-month-total {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            font-size: 1.1rem;
            font-weight: 600;
            color: hsl(var(--foreground));
            margin-top: 0.6rem;
            margin-bottom: 0.5rem;
        }
        
        .selected-month-total .month-name {
            flex: 1;
            text-align: left;
            font-weight: 400;
            font-size: 1rem;
        }
        
        .selected-month-total .month-amount {
            flex: 1;
            text-align: right;
            font-variant-numeric: tabular-nums;
            color: #8b5cf6;
            font-size: 1.3rem;
        }
        
        .selected-month-total .month-amount.zero-or-negative {
            color: #000000;
        }
        
        .chart-carousel-container {
            position: relative;
            width: 100%;
            overflow: hidden;
        }
        
        .chart-carousel {
            display: flex;
            width: 200%;
            transition: transform 0.3s ease;
            overflow: hidden;
            margin-bottom: 0 !important;
        }
        
        .chart-fade-transition {
            opacity: 0.7;
            transition: opacity 0.2s ease;
        }
        
        .chart-fade-in {
            opacity: 1 !important;
        }
        
        .chart-fade-slide-in {
            animation: slideInFromLeft 0.3s ease-out forwards;
        }
        
        .chart-fade-slide-out {
            animation: slideOutToRight 0.3s ease-out forwards;
        }
        
        @keyframes slideInFromLeft {
            0% {
                opacity: 0;
                transform: translateX(-20px);
            }
            100% {
                opacity: 1;
                transform: translateX(0);
            }
        }
        
        @keyframes slideOutToRight {
            0% {
                opacity: 1;
                transform: translateX(0);
            }
            100% {
                opacity: 0;
                transform: translateX(20px);
            }
        }
        
        .chart-bar-stagger-in {
            opacity: 0;
            animation: barFadeInStagger 0.3s ease-out forwards;
        }
        
        @keyframes barFadeInStagger {
            0% {
                opacity: 0;
            }
            100% {
                opacity: 1;
            }
        }
        
        .chart-slide {
            width: 50%;
            flex-shrink: 0;
        }

        
        .chart-dots {
            display: flex;
            justify-content: center;
            gap: 6px;
            padding: 0.5rem;
        }
        
        .chart-dots .dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background-color: #9ca3af;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        
        .chart-dots .dot.active {
            background-color: #374151;
        }
        
        .chart-dots .dot:hover {
            opacity: 0.8;
        }
        
        .category-spending-chart {
            display: flex;
            align-items: end;
            gap: 0.5rem;
            min-height: 140px;
            position: relative;
            justify-content: center;
        }
        
        .category-spending-chart .chart-bar {
            min-width: 40px;
            max-width: 40px;
            flex-shrink: 0;
            cursor: pointer;
            transition: opacity 0.2s ease;
        }
        
        /* Fade out non-selected bars when one is selected */
        .category-spending-chart.has-selection .chart-bar:not(.selected) {
            opacity: 0.3;
            transition: opacity 0.3s ease;
        }
        
        .category-spending-chart.has-selection .chart-bar.selected {
            opacity: 1;
            transition: opacity 0.3s ease;
        }
        
        /* Push button effect for category chart bars */
        .category-spending-chart .chart-bar .bar-visual {
            transition: transform 0.1s ease, box-shadow 0.1s ease;
        }
        
        .category-spending-chart .chart-bar .bar-visual:active {
            transform: scale(0.95);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .chart-bar {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            flex: 1;
            max-width: 40%;
            position: relative;
            /* height: 100px; */
        }
        
        .bar-amount {
            font-weight: 500;
            text-align: center;
            font-size: 0.7rem;
            text-transform: uppercase;
        }

        .bar-amount span,
        .bar-amount-icon {
            font-size: 1.1rem;
        }
        
        .bar-visual {
            width: 100%;
            border-radius: 4px;
            transition: height 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            /* min-height: 24px; */
            height: 0px;
            /* position: absolute; */
            /* bottom: 0;
            left: 0; */
        }
        
        /* Category bar colors */
        .category-visual.food { 
            background: linear-gradient(to bottom, #f59e0bCC 0%, #f59e0b66 100%); 
            border: 1px solid #f59e0b; 
        }
        .category-visual.transportation { 
            background: linear-gradient(to bottom, #3b82f6CC 0%, #3b82f666 100%); 
            border: 1px solid #3b82f6; 
        }
        .category-visual.entertainment { 
            background: linear-gradient(to bottom, #8b5cf6CC 0%, #8b5cf666 100%); 
            border: 1px solid #8b5cf6; 
        }
        .category-visual.shopping { 
            background: linear-gradient(to bottom, #ef4444CC 0%, #ef444466 100%); 
            border: 1px solid #ef4444; 
        }
        .category-visual.health { 
            background: linear-gradient(to bottom, #10b981CC 0%, #10b98166 100%); 
            border: 1px solid #10b981; 
        }
        .category-visual.utilities { 
            background: linear-gradient(to bottom, #f97316CC 0%, #f9731666 100%); 
            border: 1px solid #f97316; 
        }
        .category-visual.other { 
            background: linear-gradient(to bottom, #6b7280CC 0%, #6b728066 100%); 
            border: 1px solid #6b7280; 
        }
        
        .income-visual {
            background: linear-gradient(to bottom, #cb82f273, #ffffff00);
            border: 2px solid #853dc7;
            border-bottom: 0;
        }
        
        .spending-visual {
            background: linear-gradient(to bottom, #ff6a2461, #ffffff00);
            border: 2px solid #ff7474;
            border-bottom: 0;  
        }
        
        .current-month .spending-visual {
            border-style: dashed;
        }
        
        /* Horizontal Account Type Chart */
        .account-type-horizontal {
            display: flex;
            flex-direction: column;
            gap: 0.4rem;
        }
        
        .account-type-bar {
            display: flex;
            flex-direction: column;
        }
        
        .account-type-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .account-type-left {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .account-type-label {
            font-size: 1rem;
            font-weight: 500;
            color: hsl(var(--foreground));
        }
        
        .account-type-amount {
            font-size: 1rem;
            font-weight: 600;
            color: hsl(var(--foreground));
        }
        
        .account-type-bar-row {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        
        .account-type-icon {
            height: 32px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: hsl(var(--foreground));
            flex-shrink: 0;
        }
        
        .account-type-bar-container {
            position: relative;
            height: 35px;
            background: hsl(var(--muted));
            border-radius: 4px;
            overflow: hidden;
            flex: 1;
            display: flex;
            align-items: center;
        }
        
        .account-type-bar-visual {
            display: flex;
            align-items: center;
            height: 100%;
            border-radius: 4px 1rem 0rem 4px;
            position: relative;
            transition: all 0.3s ease;
            min-height: 30px;
        }
        
        .account-type-bar-visual.investments,
        .account-type-bar-visual.investment {
            background: linear-gradient(to right, #f59e0b66 0%, #f59e0bCC 100%);
            border: 1px solid #f59e0b;
        }
        
        .account-type-bar-visual.cash {
            background: linear-gradient(to right, #10b98166 0%, #10b981CC 100%);
            border: 1px solid #10b981;
        }
        
        .account-type-bar-visual.debt,
        .account-type-bar-visual.liability {
            background: linear-gradient(to left, #ef444466 0%, #ef4444CC 100%);
            border: 1px solid #ef4444;
            margin-left: auto;
            margin-right: 0;
            border-radius: 1rem 4px 4px 4px;
        }
        
        .account-type-percentage {
            color: white;
            font-size: 0.75rem;
            font-weight: 600;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
            margin-left: 10px;
        }
        
        #budgetDisplay .stat-card {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            margin-bottom: 0;
            position: relative;
            height: auto;
        }

        /* Change indicator styling */
        .change-indicator {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 0.875rem;
            font-weight: 500;
            margin-top: 4px;
        }
        
        /* Budget Overview Card Styles */
        .budget-timerange-toggle {
            display: inline-flex;
            background: hsl(var(--muted) / 0.6);
            border-radius: 20px;
            padding: 3px;
            position: relative;
            border: 1px solid hsl(var(--border) / 0.5);
        }
        
        .timerange-btn {
            padding: 4px 14px;
            border: none;
            background: transparent;
            border-radius: 16px;
            font-size: 0.7rem;
            font-weight: 600;
            color: hsl(var(--muted-foreground));
            cursor: pointer;
            transition: all 0.15s ease;
            position: relative;
            z-index: 2;
            white-space: nowrap;
            min-height: 0;
            height: auto;
        }
        
        .timerange-btn.active {
            background: hsl(var(--background));
            color: hsl(var(--foreground));
            box-shadow: 0 1px 3px rgba(0, 0, 0, 0.12), 0 1px 2px rgba(0, 0, 0, 0.08);
        }
        
        .timerange-btn:hover:not(.active) {
            color: hsl(var(--foreground) / 0.8);
        }
        
        .budget-bar-section {
            margin-bottom: 1.5rem;
        }
        
        .budget-bar-section:last-child {
            margin-bottom: 0;
        }
        
        .budget-bar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }
        
        .budget-bar-label {
            font-size: 0.875rem;
            font-weight: 500;
            color: hsl(var(--foreground));
        }
        
        .budget-bar-amount {
            font-size: 0.875rem;
            color: hsl(var(--muted-foreground));
            font-weight: 500;
        }
        
        .budget-progress-bar {
            height: 12px;
            background: hsl(var(--muted));
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }
        
        .budget-progress-fill {
            height: 100%;
            border-radius: 4px;
            transition: width 0.3s ease;
        }
        
        .savings-fill {
            background: linear-gradient(90deg, #5fa42e 0%, #4a7c23 100%);
        }
        
        .budget-spending-bar {
            height: 12px;
            background: hsl(var(--muted));
            border-radius: 4px;
            overflow: hidden;
            display: flex;
        }
        
        .spending-segment {
            height: 100%;
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
        }
        
        .spending-segment.fixed {
            background: linear-gradient(90deg, #dc2626 0%, #b91c1c 100%);
        }
        
        .spending-segment.essential {
            background: linear-gradient(90deg, #ea580c 0%, #c2410c 100%);
        }
        
        .spending-segment.discretionary {
            background: linear-gradient(90deg, #7c3aed 0%, #6d28d9 100%);
        }
        
        .spending-segment:hover {
            opacity: 0.8;
        }
        
        .budget-legend {
            display: flex;
            justify-content: center;
            gap: 1rem;
            margin-top: 8px;
            flex-wrap: wrap;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.75rem;
            color: hsl(var(--muted-foreground));
        }
        
        .legend-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        
        .legend-dot.fixed {
            background: #dc2626;
        }
        
        .legend-dot.essential {
            background: #ea580c;
        }
        
        .legend-dot.discretionary {
            background: #7c3aed;
        }
        
        /* Budget Flow Styles */
        .budget-progress-indicator {
            padding: 1rem 1.5rem;
            border-bottom: 1px solid hsl(var(--border));
            text-align: center;
            background: hsl(var(--background));
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            position: sticky;
            top: 0;
            left: 0;
            right: 0;
            z-index: 50;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        }
        
        .progress-dots {
            display: flex;
            justify-content: center;
            gap: 14px;
            margin-bottom: 8px;
        }
        
        .progress-dot {
            width: 14px;
            height: 14px;
            border-radius: 50%;
            background: hsl(var(--muted));
            transition: all 0.3s ease;
            border: 2px solid hsl(var(--border));
            box-sizing: border-box;
            cursor: pointer;
        }
        
        .progress-dot.active {
            background: #8b5cf6;
            border-color: #8b5cf6;
            transform: scale(1.2);
            box-shadow: 0 0 0 2px rgba(139, 92, 246, 0.2);
        }
        
        .progress-dot.completed {
            background: #5fa42e;
            border-color: #5fa42e;
            transform: scale(1.1);
        }
        
        .progress-label {
            font-size: 0.875rem;
            color: hsl(var(--muted-foreground));
        }
        
        .budget-flow-screens {
            display: flex;
            flex-direction: column;
            min-height: 60vh;
            padding: 0;
        }
        
        .budget-flow-screen {
            display: none;
            animation: fadeIn 0.3s ease-in-out;
            padding: 1.5rem 1.5rem 120px 1.5rem;
            flex: 1;
        }
        
        .budget-flow-screen.active {
            display: flex;
            flex-direction: column;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .budget-flow-navigation {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1.5rem;
            border-top: 1px solid hsl(var(--border));
            gap: 1rem;
            background: hsl(var(--background));
            position: fixed;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 50;
            margin: 0;
        }
        
        .budget-step-header {
            display: flex;
            align-items: center;
            gap: 1rem;
            margin-bottom: 1.5rem;
            padding: 1rem 1.25rem;
            background: hsl(var(--card));
            border-radius: 0.75rem;

        }
        
        .budget-step-icon {
            width: 2.5rem;
            height: 2.5rem;
            border-radius: 50%;
            background: #5fa42e;
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        
        .budget-step-content h3 {
            margin: 0;
            font-size: 1.25rem;
            font-weight: 600;
            color: hsl(var(--foreground));
        }
        
        .budget-step-description {
            font-size: 0.875rem;
            color: hsl(var(--muted-foreground));
            margin: 0.25rem 0 0 0;
        }
        
        .interactive-chart-container {
            background: hsl(var(--card));
            border: 1px solid hsl(var(--border));
            border-radius: 0.75rem;
            padding: 1.5rem;
            margin-top: 1.5rem;
        }
        
        .budget-content-section {
            background: hsl(var(--card));
            border: 1px solid hsl(var(--border));
            border-radius: 0.75rem;
            padding: 1.5rem;
            margin-bottom: 1.5rem;
        }
        
        .budget-content-section:last-child {
            margin-bottom: 2rem;
        }
        
        .budget-screen-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            padding: 1rem;
        }
        
        .chart-title {
            font-size: 0.875rem;
            font-weight: 500;
            color: hsl(var(--muted-foreground));
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .savings-rate-display {
            font-size: 2rem;
            font-weight: 700;
            color: #5fa42e;
            text-align: center;
            margin: 1rem 0;
        }
        
        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 1rem;
            margin-top: 1rem;
        }
        
        .summary-card {
            background: hsl(var(--card));
            border: 1px solid hsl(var(--border));
            border-radius: 0.75rem;
            padding: 1rem;
            transition: all 0.2s ease;
        }
        
        .summary-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px hsl(var(--shadow) / 0.15);
        }
        
        .summary-card-header {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.75rem;
        }
        
        .summary-card-icon {
            width: 1.75rem;
            height: 1.75rem;
            border-radius: 0.375rem;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        
        .summary-card-title {
            font-size: 0.875rem;
            font-weight: 500;
            color: hsl(var(--muted-foreground));
            margin: 0;
        }
        
        .summary-card-value {
            font-size: 1.25rem;
            font-weight: 700;
            color: hsl(var(--foreground));
            margin-bottom: 0.5rem;
        }
        
        .summary-card-chart {
            height: 40px;
            position: relative;
        }
        
        .income-icon { background: hsl(var(--primary) / 0.1); color: hsl(var(--primary)); }
        .expenses-icon { background: hsl(220 14% 96%); color: #ef4444; }
        .savings-icon { background: hsl(142 76% 96%); color: #10b981; }
        .remaining-icon { background: hsl(262 83% 96%); color: #8b5cf6; }
        
        .nav-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 0.5rem;
            padding: 0.875rem 1.5rem;
            border-radius: 0.5rem;
            font-weight: 500;
            border: none;
            cursor: pointer;
            transition: all 0.2s ease;
            flex: 1;
            max-width: 160px;
            min-height: 44px;
        }
        
        
        .nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }
        
        .change-arrow {
            font-size: 1rem;
        }
        
        .spending-card .change-indicator {
            color: #ef4444; /* red for spending */
        }
        
        .remaining-card .change-indicator {
            color: #5fa42e; /* green for remaining/positive */
        }
        
        .remaining-card .change-indicator.over-budget {
            color: #ef4444; /* red when over budget */
        }
        
        /* Side-by-side squares layout for save screen */
        #saveTargetDisplay .card-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            padding: 0;
        }
        
        #saveTargetDisplay .stat-card {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            margin-bottom: 0;
            position: relative;
            min-height: 120px;
            height: auto;
        }
        
        /* Save screen change indicators */
        .saving-target-card .change-indicator {
            color: #3b82f6; /* blue for target */
        }
        
        .save-progress-card .change-indicator {
            color: #5fa42e; /* green for progress */
        }
        
        .save-progress-card .change-indicator.behind-target {
            color: #ef4444; /* red when behind target */
        }
        
        /* Home Screen Styles */
        .home-section {
            margin-bottom: 1.5rem;
            cursor: pointer;
            position: relative;
            background-color: hsl(var(--card)) !important;
            border: 2px solid hsl(var(--border) / 0.5) !important;
            border-radius: 12px;
            box-shadow: none !important;
            padding: 1rem;
        }
        
        .home-section .card-header {
            display: flex;
            flex-direction: row;
            justify-content: space-between;
            align-items: flex-start;
            gap: 0.5rem;
            text-align: left;
            position: relative;
            width: 100%;
            /* border-bottom: 1px solid #e9e9e9; */
            padding-bottom: 0.6rem;
        }
        
        .home-section .card-header > .home-section-header {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
            align-items: flex-start;
            text-align: left;
        }
        
        .home-section-header {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            gap: 1rem;
            cursor: pointer;
            width: 100%;
        }
        
        .section-header-left {
            display: flex;
            flex-direction: column;
            gap: 0.15rem;
            align-items: flex-start;
            text-align: left;
            flex: 1;
        }
        
        .section-header-right {
            display: flex;
            align-items: flex-start;
            justify-content: flex-end;
            flex-shrink: 0;
        }
        
        /* Account Balance Summary in Net Worth Section */
        .account-balance-summary {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.5rem;
            font-size: 0.875rem;
        }
        
        .balance-label {
            color: hsl(var(--muted-foreground));
            font-weight: 500;
        }
        
        .balance-amount {
            color: hsl(var(--foreground));
            font-weight: 600;
        }
        
        .manage-accounts-btn {
            background: hsl(var(--secondary));
            color: hsl(var(--secondary-foreground));
            border: none;
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        
        .manage-accounts-btn:hover {
            background: hsl(var(--secondary) / 0.8);
        }
        
        /* Account Balance Display Layout */
        .balance-header-section {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }
        
        .balance-left-stack {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            align-items: flex-start;
        }
        
        .balance-info-group {
            display: flex;
            flex-direction: column;
            gap: 0;
        }
        
        .balance-section-title {
            font-size: 1rem;
            font-weight: 600;
            margin: 0;
            color: hsl(var(--foreground));
        }
        
        .section-title {
            font-size: 1.2rem;
            font-weight: 400;
            margin: 0;
            color: hsl(220, 13%, 28%);
        }
        
        /* Transactions title on cashflow page - match other section headers */
        #expensesListTitle {
            font-size: 1.2rem !important;
            font-weight: 400 !important;
            color: hsl(220, 13%, 28%) !important;
        }
        
        /* Card header styling handled by home-section class */
        
        .section-subtitle {
            color: hsl(var(--muted-foreground));
            font-size: 0.875rem;
            display: flex;
            align-items: center;
            gap: 0.25rem;
            margin: 0;
        }
        
        .cashflow-menu-container {
            position: relative;
            z-index: 100;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .dot-menu-btn {
            background: none;
            border: none;
            padding: 0.5rem;
            border-radius: 0.5rem;
            cursor: pointer;
            color: hsl(var(--muted-foreground));
            transition: color 0.2s ease, background-color 0.2s ease;
        }
        
        .dot-menu-btn:hover {
            color: hsl(var(--foreground));
            background-color: hsl(var(--muted));
        }

/* Dropdown menu positioning (moved from stray JS area) */
.dropdown-menu {
  position: absolute;
  top: calc(100% + 0.25rem) !important;
  left: 0;
  max-height: 80vh;
  overflow-y: auto;
  background: hsl(var(--background));
  border: 1px solid hsl(var(--border));
  border-radius: 0.5rem;
  box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
  min-width: 220px;
  z-index: 100;
  display: none;
  margin-top: 0.25rem;
  pointer-events: auto;
  transform: none !important;
}
        
        .dropdown-menu.show {
            display: block;
            position: absolute !important;
        }

        .dropdown-menu.dropdown-right {
            right: 0 !important;
            left: auto !important;
        }

        .dropdown-menu.dropdown-left {
            left: 0 !important;
            right: auto !important;
        }
        
        .time-range-selector {
            background: transparent;
            border: 1px solid hsl(var(--border));
            border-radius: 1rem;
            display: inline-flex;
            align-items: center;
            justify-content: flex-start;
            cursor: pointer;
            font-size: 1rem;
            color: hsl(var(--muted-foreground));
            padding: 9px 12px;
            height: 38px;
            box-sizing: border-box;
            outline: none;
            width: auto;
        }
        
        .time-range-selector-icon:hover {
            background-color: hsl(var(--muted));
        }
        
        .dropdown-header {
            padding: 0.75rem 1rem 0.5rem;
            font-size: 0.75rem;
            font-weight: 500;
            color: hsl(var(--muted-foreground));
            text-transform: uppercase;
            letter-spacing: 0.025em;
        }
        
        .dropdown-item {
            padding: 0.75rem 1rem;
            cursor: pointer;
            font-size: 0.875rem;
            transition: background-color 0.2s ease;
            border-left: 3px solid transparent;
        }
        
        .dropdown-item:hover {
            background-color: hsl(var(--muted));
        }
        
        .dropdown-item.active {
            background-color: transparent;
            border-left-color: transparent;
            color: hsl(var(--foreground));
            font-weight: 700;
            text-decoration: underline;
        }
        
        .dropdown-item:first-of-type {
            border-top-left-radius: 0.5rem;
            border-top-right-radius: 0.5rem;
        }
        
        .dropdown-item:last-of-type {
            border-bottom-left-radius: 0.5rem;
            border-bottom-right-radius: 0.5rem;
        }
        
        .range-picker {
            display: flex;
            gap: 0.5rem;
            margin: 0;
            width: 100%;
        }
        
        .range-btn {
            padding: 0.25rem 0.75rem;
            background: hsl(var(--muted));
            border: none;
            border-radius: 0.375rem;
            color: hsl(var(--muted-foreground));
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.875rem;
        }
        
        .range-btn.active {
            background: hsl(var(--primary));
            color: hsl(var(--primary-foreground));
        }
        
        .range-btn:hover:not(.active) {
            background: hsl(var(--muted) / 0.8);
        }
        
        #homeTransactionsList {
            padding: 0;
        }
        
        .home-transaction-item {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 0.7rem 0;
            border-bottom: 1px solid hsl(var(--border));
        }
        
        .home-transaction-item:last-child {
            border-bottom: none;
        }
        
     
        
        .transaction-date {
            color: hsl(var(--muted-foreground));
            font-size: 0.75rem;
            margin-left: 1.5rem; /* Align with description text, accounting for icon + gap */
        }
        
        .transaction-amount {
            font-weight: 600;
            color: hsl(var(--foreground));
            font-size: 0.875rem;
            white-space: nowrap;
        }
        
        /* Chart Legend */
        .chart-legend {
            display: flex;
            justify-content: center;
            gap: 1.5rem;
            margin: 1rem 0 0.5rem 0;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .legend-color {
            width: 16px;
            height: 3px;
            border-radius: 2px;
        }
        
        .legend-label {
            font-size: 0.875rem;
            color: hsl(var(--muted-foreground));
            font-weight: 500;
        }
        
        /* Form Components */
        .form-group {
            display: flex;
            flex-direction: column;
            margin-bottom: 0.75rem; /* consistent spacing */
        }
        
        .form-label {
            font-size: 0.875rem;
            font-weight: 500;
            color: hsl(var(--foreground));
            margin-bottom: 0.5rem;
        }
        
        .form-input {
            display: flex;
            height: 2.5rem;
            min-height: 44px; /* iOS recommended minimum touch target */
            width: 100%;
            border-radius: var(--radius);
            border: 1px solid hsl(var(--border));
            background-color: hsl(var(--background));
            padding: 0.5rem 0.75rem;
            font-size: 0.875rem;
            transition: all 150ms ease;
            color: hsl(var(--foreground));
        }
        
        .form-input:focus {
            outline: 2px solid hsl(var(--ring));
            outline-offset: 2px;
            border-color: hsl(var(--ring));
        }
        
        .form-input[rows] {
            resize: vertical;
            min-height: 120px;
        }
        
        .form-input:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }
        
        .form-input[readonly] {
            background-color: hsl(var(--muted));
            color: hsl(var(--muted-foreground));
            cursor: not-allowed;
        }
        
        .form-input::placeholder {
            color: hsl(var(--muted-foreground));
        }
        
        /* Custom Select Component */
        .select-container {
            position: relative;
        }
        
        .select-trigger {
            display: flex;
            height: 2.5rem;
            min-height: 44px; /* iOS recommended minimum touch target */
            width: 100%;
            align-items: center;
            justify-content: space-between;
            border-radius: var(--radius);
            border: 1px solid hsl(var(--border));
            background-color: hsl(var(--background));
            padding: 0.5rem 0.75rem;
            font-size: 0.875rem;
            color: hsl(var(--foreground));
            cursor: pointer;
            transition: all 150ms ease;
            user-select: none;
        }
        
        .select-trigger:hover {
            background-color: hsl(var(--accent));
        }
        
        .select-trigger:focus {
            outline: 2px solid hsl(var(--ring));
            outline-offset: 2px;
            border-color: hsl(var(--ring));
        }
        
        .select-trigger[aria-expanded="true"] {
            background-color: hsl(var(--accent));
            border-color: hsl(var(--ring));
        }
        
        .select-content {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            z-index: 50;
            background-color: hsl(var(--popover));
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            margin-top: 0.25rem;
            max-height: 200px;
            overflow-y: auto;
            opacity: 0;
            transform: translateY(-10px);
            transition: all 150ms ease;
            pointer-events: none;
        }
        
        .select-content.open {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }
        
        .select-item {
            padding: 0.5rem 0.75rem;
            font-size: 0.875rem;
            cursor: pointer;
            transition: all 150ms ease;
            color: hsl(var(--foreground));
        }
        
        .select-item:hover {
            background-color: hsl(var(--accent));
        }
        
        .select-item.selected {
            background-color: transparent;
            color: hsl(var(--foreground));
            font-weight: 700;
            text-decoration: underline;
        }
        
        .select-item:first-child {
            border-radius: var(--radius) var(--radius) 0 0;
        }
        
        .select-item:last-child {
            border-radius: 0 0 var(--radius) var(--radius);
        }
        
        /* Date Input Styling */
        .date-input {
            display: flex;
            height: 2.5rem;
            min-height: 44px; /* iOS recommended minimum touch target */
            width: 100%;
            border-radius: var(--radius);
            border: 1px solid hsl(var(--border));
            background-color: hsl(var(--background));
            padding: 0.5rem 0.75rem;
            font-size: 0.875rem;
            transition: all 150ms ease;
            color: hsl(var(--foreground));
            cursor: pointer;
        }
        
        .date-input:focus {
            outline: 2px solid hsl(var(--ring));
            outline-offset: 2px;
            border-color: hsl(var(--ring));
        }
        
        /* Hide native date picker styling */
        .date-input::-webkit-calendar-picker-indicator {
            background: transparent;
            bottom: 0;
            color: transparent;
            cursor: pointer;
            height: auto;
            left: 0;
            position: absolute;
            right: 0;
            top: 0;
            width: auto;
        }
        
        .date-input::-webkit-inner-spin-button,
        .date-input::-webkit-clear-button {
            display: none;
        }
        
        /* Custom Date Picker Styles */
        .date-picker-container {
            position: relative;
        }

        .date-picker-trigger {
            display: flex;
            height: 2.5rem;
            min-height: 44px; /* iOS recommended minimum touch target */
            width: 100%;
            align-items: center;
            justify-content: space-between;
            border-radius: var(--radius);
            border: 1px solid hsl(var(--border));
            background-color: hsl(var(--background));
            padding: 0.5rem 0.75rem;
            font-size: 0.875rem;
            color: hsl(var(--foreground));
            cursor: pointer;
            transition: all 150ms ease;
            user-select: none;
        }

        .date-picker-trigger:hover {
            background-color: hsl(var(--accent));
        }

        .date-picker-trigger:focus {
            outline: 2px solid hsl(var(--ring));
            outline-offset: 2px;
            border-color: hsl(var(--ring));
        }

        .date-picker-trigger[aria-expanded="true"] {
            background-color: hsl(var(--accent));
            border-color: hsl(var(--ring));
        }

        .date-picker-content {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            z-index: 50;
            background-color: hsl(var(--popover));
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            margin-top: 0.25rem;
            opacity: 0;
            transform: translateY(-10px);
            transition: all 150ms ease;
            pointer-events: none;
            padding: 1rem;
            min-width: 280px;
        }

        .date-picker-content.open {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }

        .date-picker-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .date-picker-nav {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .date-picker-nav-btn {
            background-color: transparent;
            border: none;
            width: 2rem;
            height: 2rem;
            border-radius: var(--radius);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.875rem;
            color: hsl(var(--foreground));
            transition: all 150ms ease;
        }

        .date-picker-nav-btn:hover {
            background-color: hsl(var(--accent));
        }

        .date-picker-nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .date-picker-month-year {
            font-size: 0.875rem;
            font-weight: 500;
            color: hsl(var(--foreground));
            min-width: 120px;
            text-align: center;
        }

        .date-picker-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 0.125rem;
        }

        .date-picker-day-header {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 2rem;
            font-size: 0.75rem;
            font-weight: 500;
            color: hsl(var(--muted-foreground));
        }

        .date-picker-day {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 2rem;
            font-size: 0.875rem;
            cursor: pointer;
            border-radius: var(--radius);
            transition: all 150ms ease;
            color: hsl(var(--foreground));
            background-color: transparent;
            border: none;
        }

        .date-picker-day:hover {
            background-color: hsl(var(--accent));
        }

        .date-picker-day.today {
            background-color: hsl(var(--accent));
            font-weight: 600;
        }

        .date-picker-day.selected {
            background-color: hsl(var(--primary));
            color: hsl(var(--primary-foreground));
        }

        .date-picker-day.disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .date-picker-day.disabled:hover {
            background-color: transparent;
        }

        .date-picker-day.other-month {
            opacity: 0.5;
        }

        .date-picker-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid hsl(var(--border));
        }

        .date-picker-today-btn {
            background-color: hsl(var(--secondary));
            color: hsl(var(--secondary-foreground));
            border: none;
            padding: 0.375rem 0.75rem;
            border-radius: var(--radius);
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 150ms ease;
        }

        .date-picker-today-btn:hover {
            background-color: hsl(var(--secondary) / 0.8);
        }

        .date-picker-clear-btn {
            background-color: transparent;
            color: hsl(var(--muted-foreground));
            border: none;
            padding: 0.375rem 0.75rem;
            border-radius: var(--radius);
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 150ms ease;
        }

        .date-picker-clear-btn:hover {
            background-color: hsl(var(--accent));
            color: hsl(var(--foreground));
        }
        
        /* Period dropdown custom styling */
        .period-dropdown {
            display: none; /* Hide native select */
        }
        
        .period-select-container {
            position: relative;
            min-width: 120px;
        }
        
        .period-select-trigger {
            display: flex;
            height: 2rem;
            align-items: center;
            justify-content: space-between;
            border-radius: var(--radius);
            border: 1px solid hsl(var(--border));
            background-color: hsl(var(--background));
            padding: 0.375rem 0.75rem;
            font-size: 0.875rem;
            font-weight: 500;
            color: hsl(var(--foreground));
            cursor: pointer;
            transition: all 150ms ease;
            user-select: none;
            gap: 0.5rem;
        }
        
        .period-select-trigger:hover {
            background-color: hsl(var(--accent));
        }
        
        .period-select-trigger:focus {
            outline: 2px solid hsl(var(--ring));
            outline-offset: 2px;
            border-color: hsl(var(--ring));
        }
        
        .period-select-content {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            z-index: 50;
            background-color: hsl(var(--popover));
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            margin-top: 0.25rem;
            max-height: 200px;
            overflow-y: auto;
            opacity: 0;
            transform: translateY(-10px);
            transition: all 150ms ease;
            pointer-events: none;
        }
        
        .period-select-content.open {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }
        
        .period-select-item {
            padding: 0.5rem 0.75rem;
            font-size: 0.875rem;
            cursor: pointer;
            transition: all 150ms ease;
            color: hsl(var(--foreground));
        }
        
        .period-select-item:hover {
            background-color: hsl(var(--accent));
        }
        
        .period-select-item.selected {
            background-color: transparent;
            color: hsl(var(--foreground));
            font-weight: 700;
            text-decoration: underline;
        }
        
        /* Utility Classes */
        .text-sm { font-size: 0.875rem; line-height: 1.25rem; }
        .text-base { font-size: 1rem; line-height: 1.5rem; }
        .text-lg { font-size: 1.125rem; line-height: 1.75rem; }
        .text-xl { font-size: 1.25rem; line-height: 1.75rem; }
        .text-2xl { font-size: 1.5rem; line-height: 2rem; }
        .text-3xl { font-size: 1.875rem; line-height: 2.25rem; }
        
        .font-medium { font-weight: 500; }
        .font-semibold { font-weight: 600; }
        .font-bold { font-weight: 700; }
        
        /* Lucide Icon Fallbacks */
        [data-lucide] {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            height: 1em;
            width: 1em;
            color: hsl(var(--foreground)); /* Set icons to use the foreground color by default */
        }
        
        /* Icon color handling for specific icons */
        @media (prefers-color-scheme: light) {
            [data-lucide="settings"] {
                color: #000; /* Black in light mode */
            }
        }
        
        @media (prefers-color-scheme: dark) {
            [data-lucide="settings"] {
                color: hsl(var(--foreground)); /* Light color in dark mode */
            }
        }
        
        /* Always make icons in dark buttons (like Add Expense) white */
        .quick-action-card [data-lucide],
        .expense-btn [data-lucide],
        .balance-btn [data-lucide],
        .add-btn [data-lucide],
        .swipe-action [data-lucide] {
            color: #ffffff;
        }
        
        /* Smooth fade-in for chart icons to prevent flash */
        .chart-bar [data-lucide],
        .transaction-description [data-lucide],
        .expense-icon [data-lucide] {
            opacity: 0;
            transition: opacity 0.2s ease-in-out;
        }
        
        .chart-bar [data-lucide].lucide,
        .transaction-description [data-lucide].lucide,
        .expense-icon [data-lucide].lucide {
            opacity: 1;
        }
        
        /* Remove the jarring dot fallback for chart icons */
        .chart-bar [data-lucide]:empty::before,
        .transaction-description [data-lucide]:empty::before,
        .expense-icon [data-lucide]:empty::before {
            content: '';
        }
        
        /* Keep dot fallback for other icons */
        [data-lucide]:empty::before {
            content: '';
            font-size: 1.2em;
        }
        
        .text-foreground { color: hsl(var(--foreground)); }
        .text-muted-foreground { color: hsl(var(--muted-foreground)); }
        .text-primary { color: hsl(var(--primary)); }
        .text-success { color: hsl(var(--success)); }
        .text-destructive { color: hsl(var(--destructive)); }
        
        .flex { display: flex; }
        .flex-col { flex-direction: column; }
        .items-center { align-items: center; }
        .justify-center { justify-content: center; }
        .justify-between { justify-content: space-between; }
        .gap-2 { gap: 0.5rem; }
        .gap-3 { gap: 0.75rem; }
        .gap-4 { gap: 1rem; }
        
        .p-2 { padding: 0.5rem; }
        .p-4 { padding: 1rem; }
        .px-3 { padding-left: 0.75rem; padding-right: 0.75rem; }
        .px-4 { padding-left: 1rem; padding-right: 1rem; }
        .py-2 { padding: 0.5rem 0; }
        .py-3 { padding: 0.75rem 0; }
        
        .mb-2 { margin-bottom: 0.5rem; }
        .mb-4 { margin-bottom: 1rem; }
        .mb-6 { margin-bottom: 1.5rem; }
        .mr-2 { margin-right: 0.5rem; }
        
        .rounded { border-radius: var(--radius); }
        .rounded-lg { border-radius: var(--radius); }
        .rounded-full { border-radius: 9999px; }
        
        /* Icon Styles */
        .w-4 { width: 1rem; }
        .h-4 { height: 1rem; }
        .w-5 { width: 1.25rem; }
        .h-5 { height: 1.25rem; }
        .w-6 { width: 1.5rem; }
        .h-6 { height: 1.5rem; }
        
        .app-container {
            height: 100vh;
            display: flex;
            flex-direction: column;
            position: relative;
            background-color: hsl(var(--background));
        }
        
        .app-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 10px 20px;
            background: hsl(36deg 55.56% 98.24%);
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 10;
        }
        
        .app-header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 30%;
            pointer-events: none;
        }
        
        .app-header::after {
            content: '';
            position: absolute;
            top: 30%;
            left: 0;
            right: 0;
            height: 40%;
            pointer-events: none;
        }
        
        .app-header h1 {
            font-size: 1.3rem;
            font-weight: 600;
            color: hsl(var(--foreground));
            margin-bottom: 0.25rem;
        }
        
        .date-display {
            font-size: 0.875rem;
            color: hsl(var(--muted-foreground));
        }
        
        .content-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        
        .screens-wrapper {
            display: flex;
            height: 100%;
            /* transition: transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94); */
            will-change: transform;
        }
        
        .screen {
            width: 100vw;
            flex-shrink: 0;
            overflow-y: auto;
            overflow-x: hidden; /* Prevent horizontal scrolling */
            padding: 1rem;
            padding-top: 66px; /* Account for fixed header height */
            background-color: rgba(200, 160, 61, 0.04);
            scroll-behavior: smooth;
        }
        
        /* Faster scroll animation for nav tap to top */
        .screen.fast-scroll {
            scroll-behavior: auto;
            transition: scroll-top 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        /* Remove old daily-budget styles - now using card classes */
        
        /* Action Buttons */
        .action-buttons {
            display: flex;
            gap: 0.75rem;
            justify-content: center;
            margin-bottom: 1.5rem;
            margin-top: 1.5rem;
            padding: 0 1.5rem;
        }
        
        .action-btn {
            flex: 1;
            max-width: 200px;
        }
        
        .expense-btn {
            background-color: hsl(220, 13%, 18%);
            color: #ffffff;
        }
        
        .expense-btn:hover {
            background-color: hsl(220, 13%, 28%);
        }
        
        .balance-btn {
            background-color: hsl(220, 13%, 18%);
            color: #ffffff;
        }
        
        .balance-btn:hover {
            background-color: hsl(220, 13%, 28%);
        }
        
        /* Remove old action-label styles - using shadcn button styling */
        
        @media (max-width: 480px) {
            .action-buttons {
                padding: 0px;
                gap: 10px;
            }
            
            .action-btn {
                padding: 14px 16px;
                max-width: none;
            }
            
            .action-label {
                font-size: 0.85rem;
            }
        }
        
        .expense-input {
            margin-bottom: 25px;
        }
        
        .input-row {
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }
        
        .input-group {
            flex: 1;
        }
        
        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: hsl(var(--foreground));
            font-size: 0.9rem;
        }
        
        .input-group input, .input-group select {
            width: 100%;
            min-height: 44px; /* iOS recommended minimum touch target */
            padding: 14px 16px;
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            font-size: 1rem;
            background-color: hsl(var(--background));
            color: hsl(var(--foreground));
            transition: all 0.3s ease;
        }
        
        .input-group input:focus, .input-group select:focus {
            outline: 2px solid hsl(var(--ring));
            outline-offset: 2px;
            border-color: hsl(var(--ring));
        }
        
        .add-btn {
            background: linear-gradient(135deg, hsl(260deg 58.02% 57.98%), hsl(260deg 54.55% 69.74%));
            border-radius: 1rem;
            color: #ffffff;
            border: none;
            padding: 10px 16px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            display: block;
        }
        
        .add-btn:hover {
            background-color: hsl(220, 13%, 28%);
        }
        
        .add-btn:active {
            transform: translateY(1px);
        }
        
        /* Settings menu add-btn styling */
        .settings-menu-btn-item .add-btn {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            gap: 1rem;
            font-size: 0.95rem;
            font-weight: 600;
            padding: 10px 16px;
            margin: 0;
            background-color: hsl(var(--primary));
            color: hsl(var(--primary-foreground));
            border: none;
            border-radius: var(--radius);
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
        }
        
        .settings-menu-btn-item .add-btn:hover {
            background-color: hsl(var(--primary) / 0.9);
        }
        
        .settings-menu-btn-item .add-btn:active {
            transform: translateY(1px);
        }
        
        .settings-menu-btn-item .add-btn .settings-menu-icon {
            color: #fff;
        }
        
        .expenses-list {
            /* max-height: 300px; */
            overflow-y: auto;
            margin: 0 -1rem;
        }
        
        
        /* .expense-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background-color: hsl(var(--card));
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
        } */

         /* Keep borders for specific cards that need them */
        .expense-item {
            display: flex;
            flex: 1;
            align-items: center;
            padding: 1rem;
            background-color: hsl(var(--card));
            border-top: 1px solid hsl(var(--border));
            border-radius: 0;
            transition: transform 0.3s, background-color 0.3s;
            cursor: pointer;
            gap: 0.75rem;
        }
        
        .expense-icon {
            font-size: 1.1rem;
            flex-shrink: 0;
        }
        
        .expense-details {
            display: flex;
            flex-direction: column;
            gap: .19rem;
            flex: 1;
        }
        
        .expense-description {
            text-transform: capitalize;
            /* font-size: 0.95rem; */
            color: #444;
            font-weight: 500;
            flex: 1 1 40%;
        }
        
        .expense-category {
            font-size: 0.8rem;
            color: rgba(124, 128, 138, 0.74);
            text-transform: uppercase;
            font-weight: 600;
            letter-spacing: .01rem;
        }
        
        .expense-amount {
            font-size: 1rem;
            color: hsl(var(--foreground));
            text-align: right;
            flex-shrink: 0;
        }
        
        
        .date-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 1rem;
            margin: 0;
            background: hsl(0deg 0% 0% / 2%);
            font-weight: 600;
        }
        
     
        
        .date-title {
            font-size: 0.9rem;
            color: hsl(var(--foreground));
        }
        
        .date-total {
            font-size: 0.9rem;
            font-weight: 600;
        }
        
        .account-header-section {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: .4rem;
        }

        .account-action-pills {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
            margin-top: 0.5rem;
        }

        .account-pill-btn {
            display: flex;
            align-items: center;
            gap: 0.375rem;
            padding: 0.375rem 0.75rem;
            background: transparent;
            border: 1px solid #000000;
            border-radius: 1rem;
            font-size: 0.875rem;
            font-weight: 500;
            color: #000000;
            cursor: pointer;
            transition: all 0.2s ease;
            text-decoration: none;
            min-height: 0;
        }

        .account-pill-btn.bold {
            font-weight: 600;
            border-width: 2px;
        }

        .account-pill-btn:hover {
            background: #e9ecef;
            border-color: #dee2e6;
            color: #343a40;
        }

        .account-pill-btn:active {
            transform: translateY(1px);
        }

        .account-pill-btn [data-lucide] {
            width: 1rem;
            height: 1rem;
        }
        
        .date-transactions {
            display: flex;
            flex-direction: column;
            gap: 0;
        }
        
        .delete-btn {
            background-color: hsl(0deg 0% 95.88%);
            color: hsl(0deg 0% 24.54%);
            border: none;
            padding: 6px 10px;
            border-radius: var(--radius);
            font-size: 0.8rem;
            cursor: pointer;
            margin-left: 10px;
            transition: all 150ms ease;
        }
        
        .delete-btn:hover {
            background-color: hsl(var(--destructive) / 0.9);
        }
        
        .chart-container {
            /* Use .card class instead of custom styling */
            height: 350px;
        }
        
        /* Charts with headers use flexbox layout */
        .chart-container.chart-with-header {
            display: flex;
            flex-direction: column;
        }
        
        .chart-container.chart-with-header canvas {
            flex: 1;
            min-height: 0;
        }
        
        .chart-canvas-wrapper {
            flex: 1;
            padding: 0 1rem 1rem 1rem;
            min-height: 0;
            position: relative;
        }
        
        .chart-canvas-wrapper canvas {
            width: 100% !important;
            height: 100% !important;
        }
        
        /* Specific styling for category chart to prevent height issues */
        #categoryChart {
            max-height: none !important;
            min-height: 200px !important;
        }
        
        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem;
            flex-shrink: 0;
        }
        
        .chart-header h3 {
            margin: 0;
            font-size: 1.1rem;
            font-weight: 600;
            color: hsl(var(--foreground));
        }
        
        .chart-time-range {
            font-size: 0.8rem;
            color: hsl(var(--muted-foreground));
            background: hsl(var(--muted));
            padding: 0.25rem 0.5rem;
            border-radius: 0.375rem;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            margin-bottom: 1rem;
        }
        
        /* Remove margin-bottom from stat cards since we're using gap */
        .stats-grid .stat-card {
            margin-bottom: 0;
        }
        
        .stat-card {
            /* Use .card class instead of custom styling */
            text-align: center;
            padding: 1rem;
        }
        
        .stat-label {
            font-size: 0.8rem;
            color: hsl(var(--muted-foreground));
            margin-bottom: 8px;
            font-weight: 500;
        }
        
        .stat-value {
            font-size: 1.4rem;
            font-weight: 700;
            color: hsl(var(--foreground));
        }
        
        .stat-subtitle {
            font-size: 0.75rem;
            color: hsl(var(--muted-foreground));
            margin-top: 4px;
            font-weight: 400;
        }
        
        .stat-subtitle.positive {
            color: hsl(var(--success));
        }
        
        .stat-subtitle.positive {
            color: hsl(var(--success));
        }
        
        .stat-value.positive {
            color: hsl(var(--success));
        }
        
        .stat-value.negative {
            color: hsl(var(--destructive));
        }
        
        .stat-value.warning {
            color: hsl(var(--warning));
        }
        
        .bottom-nav {
            background-color: hsl(var(--card));
            border-top: 1px solid hsl(var(--border));
            padding: 1.25rem 0; /* Further increased padding for iOS swipe bar clearance */
            display: flex;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(10px);
            position: relative;
        }
        
        .nav-item {
            display: flex;
            flex-direction: column;
            top: -10px;
            align-items: center;
            padding: 0.5rem;
            margin: 0 0.8rem; /* Increased margin for better spacing */
            cursor: pointer;
            transition: all 150ms ease, transform 0.12s;
            border-radius: var(--radius);
            user-select: none;
            color: hsl(var(--muted-foreground) / 0.5); /* More grayed out for inactive items */
            position: relative;
            opacity: 0.6; /* Additional opacity to ensure graying out */
        }
        
        .nav-item.active {
            color: hsl(var(--foreground)); /* Darker color for active item */
            font-weight: 500; /* Slightly bolder to enhance visibility */
            opacity: 1; /* Full opacity for active item */
        }
        
        .nav-item:hover:not(.active) {
            color: hsl(var(--foreground) / 0.9); /* Slightly darker on hover */
        }
        
        .nav-item:active .icon {
            transform: scale(0.90);
        }
        
        .nav-item .icon {
            font-size: 1.3rem;
            transition: all 150ms ease;
            color: inherit; /* Ensure icon inherits the parent's color */
        }
        

        /* Make icon size slightly bigger for active state */
        .nav-item.active .icon {
            transform: scale(1.10);
        }
        
        /* Show labels beneath nav icons */
        .nav-item .label {
            display: block;
            font-size: 0.75rem;
            font-weight: 500;
            margin-top: 5px;
            text-align: center;
            color: rgb(53, 53, 53);
            transition: color 150ms ease;
        }

        .nav-item.active .label {
            color: hsl(var(--foreground));
            /* font-weight: 600; */
        }
        
        .screen::-webkit-scrollbar {
            display: none;
        }
        
        .screen {
            -ms-overflow-style: none;
            scrollbar-width: none;
            -webkit-overflow-scrolling: touch;
        }
        
        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .status-good { background-color: hsl(var(--success)); }
        .status-warning { background-color: hsl(var(--warning)); }
        .status-danger { background-color: hsl(var(--destructive)); }
        
        .weekly-summary {
            background-color: hsl(var(--primary));
            color: hsl(var(--primary-foreground));
            text-align: center;
            margin-bottom: 20px;
            border-radius: var(--radius);
            padding: 1.5rem;
        }
        
        .weekly-summary h3 {
            margin-bottom: 10px;
            font-size: 1.1rem;
        }
        
        .weekly-stats {
            display: flex;
            justify-content: space-around;
            margin-top: 15px;
        }
        
        .weekly-stat {
            text-align: center;
        }
        
        .weekly-stat-value {
            font-size: 1.2rem;
            font-weight: 700;
        }
        
        .weekly-stat-label {
            font-size: 0.8rem;
            opacity: 0.8;
        }
        
        /* Combined spent/remaining card styles */
        .combined-stats {
            display: flex;
            align-items: center;
            justify-content: space-around;
            margin-top: 15px;
        }
        
        .combined-stat {
            text-align: center;
            flex: 1;
        }
        
        .combined-stat-value {
            font-size: 1.2rem;
            font-weight: 700;
        }
        
        .combined-stat-label {
            font-size: 0.8rem;
            margin-top: 5px;
            opacity: 0.8;
        }
        
        .stat-separator {
            width: 1px;
            height: 40px;
            background: hsla(var(--primary-foreground) / 0.3);
            margin: 0 1rem;
        }
        
        /* Combined budget stats for cashflow screen */
        .combined-budget-card {
            background: hsl(var(--card));
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            padding: 1.5rem;
            flex: 1;
            text-align: center;
        }
        
        
        .sticky-controls-section {
            position: sticky;
            top: -2px;
            z-index: 100;
            transform: translateY(0);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            margin: 0 -1rem;
            backdrop-filter: blur(21px);
            background: hsl(36deg 55.56% 98.24% / 70%);
        }
        
        .sticky-controls-section.hidden {
            transform: translateY(-100%);
        }
        
        .sticky-controls-content {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            min-height: 38px;
            padding: 0.6rem 0;
            margin: 1rem;
            border-radius: 1rem;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        /* Style the expenses list card inside sticky section */
        .sticky-controls-section .expenses-list-card {
            margin: 0 1rem 1rem 1rem;
        }
        
        .sticky-title-section {
            position: sticky;
            top: 69px;
            z-index: 99;
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            padding: 0.6rem 1rem;
            margin: 0 -1rem;
            transition: top 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .sticky-controls-section.hidden ~ .sticky-title-section {
            top: 0;
        }
        
        /* Give white backgrounds only to interactive elements */
        #budgetTitleContainer button {
            background: hsl(var(--card)) !important;
        }
       
        
        
        
        #monthYearSelectorBtn {
            height: 38px !important;
            box-sizing: border-box !important;
            line-height: 1 !important;
            min-height: 38px !important;
            max-height: 38px !important;
        }
        
        #monthYearSelectorBtn:hover {
            background: hsl(var(--accent)) !important;
            transition: background 0.2s ease;
        }
        
        .expenses-list-card {
            position: sticky;
            top: 80px;
            z-index: 10;
        }
        
        .combined-budget-stats {
            display: flex;
            align-items: stretch;
            justify-content: space-between;
            gap: 2rem;
        }
        
        .combined-budget-stat {
            flex: 1;
            text-align: center;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        
        .budget-separator {
            width: 1px;
            background: hsl(var(--border));
            opacity: 0.5;
            align-self: stretch;
            margin: 0;
        }
        
        /* period-selector uses .card class for styling */

        .period-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
        }

        .period-title {
            font-size: 1.2rem;
            font-weight: 700;
            margin: 0;
            color: hsl(var(--foreground));
        }

        /* Icon-only toggle for day/month - styled like chart-period-selector-bottom */
        .period-icon-toggle {
            display: flex;
            align-items: center;
            background: hsl(var(--card));
            border: 1px solid hsl(var(--border));
            border-radius: 1rem;
            padding: 4px;
            height: 38px;
            box-sizing: border-box;
            min-height: 38px;
            max-height: 38px;
        }
        
        .period-icon-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 30px;
            border: none;
            background: transparent;
            border-radius: 1rem;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            color: hsl(var(--muted-foreground));
            padding: 0;
            transform: scale(1);
        }
        button.period-icon-btn {
            min-height: 0;
        }
        
        .period-icon-btn.active {
            background: hsl(89.33deg 55.56% 68.24% / 52.16%);
            color: hsl(var(--foreground));
            transform: scale(1);
            opacity: 1;
        }
        
        .period-icon-btn:hover:not(.active) {
            color: hsl(var(--foreground));
            transform: scale(0.8);
        }
        
        .period-icon-btn:focus {
            outline: none;
        }

        /* Original period switch (to be hidden/replaced) */
        .period-switch {
            display: none; /* Hide the original switch */
        }

        .period-switch button {
            background-color: transparent;
            border: none;
            color: hsl(var(--muted-foreground));
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            transition: color 0.2s ease;
            padding: 0.5rem 1rem;
            border-radius: var(--radius);
        }

        .period-switch button.active {
            color: hsl(var(--foreground));
            background-color: hsl(var(--muted));
        }

        .month-navigation {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 10px;
        }

        .month-nav-btn {
            background-color: hsl(var(--primary));
            color: hsl(var(--primary-foreground));
            border: none;
            width: 32px;
            height: 32px;
            border-radius: var(--radius);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            transition: all 0.2s ease;
        }

        .month-nav-btn:hover {
            background-color: hsl(var(--primary) / 0.9);
        }

        .month-nav-btn:disabled {
            background-color: hsl(var(--muted));
            color: hsl(var(--muted-foreground));
            cursor: not-allowed;
        }

        .selected-month {
            font-size: 1rem;
            font-weight: 600;
            color: hsl(var(--foreground));
            text-align: center;
            min-width: 120px;
        }
        
        .chart-period-selector {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-bottom: 20px;
            padding: 4px;
            background-color: hsl(var(--muted));
            border-radius: var(--radius);
        }

        .chart-period-btn {
            padding: 8px 16px;
            border: none;
            background: transparent;
            border-radius: calc(var(--radius) - 2px);
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            color: hsl(var(--muted-foreground));
            min-width: 60px;
        }

        .chart-period-btn.active {
            background-color: hsl(var(--background));
            color: hsl(var(--foreground));
            box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1);
        }

        .chart-period-btn:hover:not(.active) {
            background-color: hsl(var(--accent));
            color: hsl(var(--accent-foreground));
        }
        
        /* chart-container-wrapper uses .card class for styling */
        
        /* Enhanced Wealthsimple-style chart header */
        .chart-container-wrapper {
            position: relative;
            overflow: hidden; /* Prevent wrapper overflow */
        }
        
        /* Chart date display - visible when interacted with */
        .chart-date-display {
            margin-bottom: 8px;
            font-weight: 500;
            font-size: 1rem;
            color: hsl(var(--foreground));
            height: 1.2rem;
            opacity: 0;
            transition: opacity 0.15s ease;
        }
        
        .chart-date-display.visible {
            opacity: 1;
        }
        
        .chart-header {
            padding: 0 6px;
        }
        
        /* Chart row container for savings and spending */
        .chart-row {
            margin-bottom: 16px;
        }
        
        .chart-row:last-child {
            margin-bottom: 0;
        }

        .chart-date-display {
            display: flex;
            font-weight: 600;
            color: #6B7280; 
            margin-bottom: 15px;
        }
        
        /* Savings row styling (black) */
        .savings-row .chart-main-value {
            font-size: 2.5rem;
            font-weight: 700;
            color: hsl(var(--foreground));
            margin-bottom: 4px;
            line-height: 1;
            letter-spacing: -0.02em;
        }
        
        .savings-row .chart-subtitle {
            color: black; /* Gray color for spending */
           letter-spacing: 0.07rem;
            text-transform: uppercase;
            font-size: 0.9rem;
            margin-bottom: 8px;
            font-weight: 600;
        }
        
        .savings-row .chart-growth {
            font-size: 0.9rem;
            font-weight: 500;
            padding: 4px 0;
            margin-bottom: 8px;
        }
        
        /* Spending row styling (gray) */
        .spending-row .chart-main-value {
            font-size: 1.7rem;
            font-weight: 600;
            color: #6B7280; /* Gray color for spending */
            margin-bottom: 4px;
            line-height: 1;
            letter-spacing: -0.02em;
        }
        
        .spending-row .chart-subtitle {
            color: black; /* Gray color for spending */
            letter-spacing: 0.07rem;
            text-transform: uppercase;
            font-size: 0.9rem;
            margin-bottom: 8px;
            font-weight: 600;
        }
        
        .spending-row .chart-growth {
            font-size: 0.85rem;
            font-weight: 500;
            padding: 4px 0;
            margin-bottom: 8px;
            color: #6B7280; /* Gray color for spending growth */
        }
        
        /* Legacy styles for backward compatibility */
        .chart-main-value {
            font-size: 2.5rem;
            font-weight: 700;
            color: hsl(var(--foreground));
            margin-bottom: 4px;
            line-height: 1;
            letter-spacing: -0.02em;
        }
        
        .chart-subtitle {
            font-size: 1rem;
            color: hsl(var(--muted-foreground));
            margin-bottom: 8px;
            font-weight: 500;
        }
        
        .chart-growth {
            font-size: 0.95rem;
            font-weight: 500;
            padding: 4px 0;
        }
        
        .chart-growth.positive {
            color: hsl(var(--success)); /* Green for positive growth */
        }
        
        .chart-growth.negative {
            color: #EF4444; /* Red for negative growth */
        }
        
        .chart-container {
            position: relative;
            /* Removed fixed height to allow flexible canvas sizing */
            margin-top: 20px;
            transition: opacity 0.2s ease;
            /* Added gradient fade to transparent/white */
            mask-image: linear-gradient(to bottom, black 80%, transparent 100%);
            -webkit-mask-image: linear-gradient(to bottom, black 80%, transparent 100%);
        }
        
        .chart-container.loading::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 5;
        }
        
        .chart-container.loading::before {
            content: '';
            position: absolute;
            width: 30px;
            height: 30px;
            border: 3px solid rgba(16, 185, 129, 0.2);
            border-radius: 50%;
            border-top-color: hsl(var(--success));
            animation: spin 0.8s linear infinite;
            z-index: 6;
            top: 50%;
            left: 50%;
            margin-top: -15px;
            margin-left: -15px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Bottom Period Selector for Chart (Wealthsimple Style) */
        .chart-period-selector-bottom {
            display: flex;
            justify-content: center;
            gap: 0;
            margin-top: 24px;
            background-color: hsl(var(--muted));
            border-radius: calc(var(--radius) * 2.5);
            padding: 4px;
            width: fit-content;
            margin-left: auto;
            margin-right: auto;
        }
        
        /* Enhanced Wealthsimple-style period selector buttons */
        .chart-period-btn-wealthsimple {
            padding: 8px 16px;
            border: none;
            background: transparent;
            border-radius: calc(var(--radius) * 2);
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            color: hsl(var(--muted-foreground));
            min-width: 50px;
            letter-spacing: 0.02em;
            position: relative;
            z-index: 1;
            min-height: 0;
        }
        
        .chart-period-btn-wealthsimple.active {
            background-color: hsl(var(--background));
            color: hsl(var(--foreground));
            box-shadow: 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            font-weight: 600;
        }
        
        .chart-period-btn-wealthsimple:hover:not(.active) {
            color: hsl(var(--foreground));
        }
        
        .chart-period-btn-wealthsimple:focus {
            outline: none;
            box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.2);
        }
        
        /* Animate period button transitions */
        .chart-period-selector-bottom {
            position: relative;
        }
        
        @media (prefers-reduced-motion: no-preference) {
            .chart-period-btn-wealthsimple.active {
                animation: scaleIn 0.2s ease forwards;
            }
            
            @keyframes scaleIn {
                0% { transform: scale(0.95); }
                100% { transform: scale(1); }
            }
        }
        
        /* Sticky Period Selector for Tracking Screen */
        .period-selector-sticky {
            position: sticky;
            top: 0;
            z-index: 100;
            background-color: #ffffffa1; /* Semi-transparent white */
            border-bottom: 1px solid hsl(var(--border));
            backdrop-filter: blur(10px);
            box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1);
            border-radius: 0;
            margin-bottom: 20px;
            border-radius: 10px;
        }
        
        .period-selector-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        /* Compact Toggle - Full Width */
        .period-mode-toggle-compact {
            display: flex;
            background: hsl(210deg 33.58% 90.82% / 36%);
            backdrop-filter: blur(10px);
            border-radius: var(--radius);
            padding: 2px;
            gap: 0.5rem;
            width: 100%;
            justify-content: space-between;
            align-items: center;
        }
        
        .period-mode-btn-compact {
            padding: 0.375rem 0.75rem;
            border: none;
            background: transparent;
            border-radius: calc(var(--radius) - 2px);
            font-size: 0.875rem;
            font-weight: 500;
            color: hsl(var(--muted-foreground));
            cursor: pointer;
            transition: all 150ms ease;
            flex: 1;
            min-width: 0;
        }
        
        .period-mode-btn-compact.active {
            background-color: hsl(var(--background));
            color: hsl(var(--foreground));
            box-shadow: 0 1px 3px 0 rgb(0, 0, 0 / 0.1);
        }
        
        .period-mode-btn-compact:hover:not(.active) {
            background-color: hsl(var(--accent));
        }
        
        /* Spacer Icons - Evenly Distributed */
        .toggle-spacer-icons {
            display: flex;
            justify-content: space-evenly;
            align-items: center;
            flex: 1;
            gap: 0.5rem;
            padding: 0 0.5rem;
        }
        
        .toggle-spacer-icons i {
            color: hsl(var(--muted-foreground));
            opacity: 0.6;
            transition: all 150ms ease;
        }
        
        .toggle-spacer-icons i:hover {
            opacity: 1;
            color: hsl(var(--foreground));
        }
        
        /* Enhanced Wealthsimple-style chart overlay */
        .chart-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.15s ease;
        }
        
        .chart-container {
            position: relative;
            height: 250px; /* Minimum height instead of fixed height */
            margin: 0; /* Remove all margins */
            padding: 0; /* Remove all padding */
            border-radius: var(--radius);
            border-bottom: none; /* Remove bottom border */
            overflow: hidden; /* Prevent any overflow */
            touch-action: pan-y; /* Allow vertical scrolling */
            box-sizing: border-box; /* Include padding and border in element's width */
            /* Remove fade from container - we'll apply it just to the green area */
        }
        
        /* Full width styling for specific chart */
        .chart-container.full-width-chart {
            margin: 0 -1rem; /* Only horizontal negative margins */
            padding: 0; /* Remove all padding */
            width: calc(100% + 2rem);
            border-radius: 0;
            border: none; /* Remove all borders */
            overflow-x: hidden; /* Prevent horizontal overflow */
            max-width: 100vw; /* Ensure it doesn't exceed viewport width */
        }
        
        #spendingChart {
            touch-action: pan-y; /* Allow vertical scrolling */
            cursor: crosshair;
            padding: 0; /* Remove padding */
            margin: 0; /* Remove margin */
            min-height: 250px; /* Minimum height instead of fixed height */
            height: auto; /* Allow the canvas to grow as needed */
            width: 100%; /* Ensure full width */
            display: block; /* Remove any inline spacing */
        }
        
        #homeCashflowCanvas, #homeNetWorthCanvas {
            padding: 0;
            margin: 0;
            display: block;
            width: 100%;
            height: 100%;
        }

        #accountsNetWorthCanvas {
            padding: 0;
            margin: 0;
            display: block;
            width: 100%;
            height: inherit;
        }
        
        /* Make chart more responsive to touch on mobile devices */
        @media (hover: none) and (pointer: coarse) {
            #spendingChart {
                cursor: default;
                padding: 15px 0; /* More padding on mobile for better touch area */
                touch-action: pan-y; /* Ensure vertical scrolling works on mobile */
                min-height: 280px; /* Slightly larger on mobile for better touch targets */
            }
        }
        
        .chart-crosshair {
            position: absolute;
            width: 1px;
            height: 100%;
            border-left: 1px dashed #9ca3af;
            opacity: 0;
            z-index: 20;
            pointer-events: none;
            transition: opacity 0.15s ease, left 0.05s linear;
        }
        .chart-overlay.visible {
            opacity: 1;
        }
        @media (hover: none) and (pointer: coarse) {
            .chart-crosshair {
                width: 2px;
                border-left: 2px dashed #9ca3af;
            }
        }
        
        .chart-overlay.visible .chart-tooltip {
            opacity: 1;
            transform: translateY(0);
        }
        
        .tooltip-date {
            font-size: 0.95rem;
            color: #111827;
            margin-bottom: 12px;
            font-weight: 600;
            border-bottom: 1px solid rgba(230, 230, 230, 0.5);
            padding-bottom: 10px;
        }
        
        .tooltip-values {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .tooltip-value {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .tooltip-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        
        .tooltip-dot.savings {
            background: hsl(var(--success)); /* Match the green line color */
            box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.2);
        }
        
        .tooltip-dot.spending {
            background: #6B7280; /* Match the gray line color */
            box-shadow: 0 0 0 2px rgba(107, 114, 128, 0.2);
        }
        
        .tooltip-label {
            font-size: 0.85rem;
            color: #666;
            flex: 1;
        }
        
        .tooltip-value:first-child .tooltip-amount {
            color: hsl(var(--success)); /* Green for savings */
            font-weight: 600;
        }
        
        .tooltip-value:last-child .tooltip-amount {
            color: #6B7280; /* Gray for spending */
            font-weight: 600;
        }
        
        .tooltip-amount {
            font-size: 0.9rem;
            font-weight: 600;
        }
        
        /* Savings/Account tracking styles */
        .savings-accounts-section {
            margin-bottom: 20px;
            margin-top: 20px;
        }
        
        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            flex: 1;
        }
        
        .manage-accounts-btn {
            background-color: hsl(var(--secondary));
            color: hsl(var(--secondary-foreground));
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            padding: 0.5rem 0.75rem;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 150ms ease;
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
        }
        
        .manage-accounts-btn:hover {
            background-color: hsl(var(--secondary) / 0.8);
        }
        
        /* Mobile responsive for section header */
        @media (max-width: 480px) {
            .section-header h3 {
                font-size: 1.1rem;
            }
            
            .manage-accounts-btn {
                padding: 10px 14px;
                font-size: 0.85rem;
                min-height: 44px; /* Better touch target */
            }
        }
        
        .account-balance-input {
            margin-bottom: 15px;
        }
        
        .account-balance-input h4 {
            margin-bottom: 15px;
            color: hsl(var(--foreground));
            font-size: 1.1rem;
        }
        
        .balance-input-row {
            display: flex;
            gap: 10px;
            align-items: flex-end;
            flex-wrap: wrap;
        }
        
        .balance-input-row .input-group {
            flex: 1;
            min-width: 120px;
        }
        
        .balance-input-row select {
            width: 100%;
            min-height: 44px; /* iOS recommended minimum touch target */
            padding: 14px 16px;
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            font-size: 1rem;
            background-color: hsl(var(--background));
            color: hsl(var(--foreground));
            transition: all 0.3s ease;
        }
        
        .balance-input-row select:focus {
            outline: 2px solid hsl(var(--ring));
            outline-offset: 2px;
            border-color: hsl(var(--ring));
        }
        
        .balance-add-btn {
            background: linear-gradient(135deg, hsl(260deg 58.02% 57.98%), hsl(260deg 54.55% 69.74%));
            border-radius: 1rem;
            color: #ffffff;
            border: none;
            padding: 10px 16px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            display: block;
        }
        
        .balance-add-btn:hover {
            background-color: hsl(220, 13%, 28%);
        }
        
        /* Mobile responsiveness for balance input */
        @media (max-width: 480px) {
            .balance-input-row {
                flex-direction: column;
                align-items: stretch;
                gap: 15px;
            }
            
            .balance-input-row .input-group {
                min-width: 100%;
            }
            
            .balance-add-btn {
                width: 100%;
                margin-top: 5px;
            }
        }
        
        .balance-add-btn:active {
            transform: translateY(1px);
        }
        
        .account-balance-display {
            border: 1px solid hsl(var(--border));
            padding: 15px;
            border-radius: var(--radius);
            margin-bottom: 15px;
            text-align: center;
        }
        
        .current-balance {
            font-size: 1.5rem;
            font-weight: 700;
            color: hsl(var(--success));
            margin-bottom: 5px;
        }
        
        /* Mobile responsiveness for balance display */
        @media (max-width: 480px) {
            .account-balance-display {
                padding: 12px;
            }
            
            .current-balance {
                font-size: 1.3rem;
            }
        }
        
        .balance-change {
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .balance-change.positive {
            color: #27ae60;
        }
        
        .balance-change.negative {
            color: #e74c3c;
        }
        
        .balance-change.neutral {
            color: #666;
        }
        
        .balance-history {
            max-height: none !important;
            overflow-y: visible !important;
        }
        
        .balance-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 12px;
            background-color: hsl(var(--card));
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
        }
        
        .balance-details {
            flex: 1;
        }
        
        .balance-date {
            font-weight: 600;
            color: hsl(var(--foreground));
            margin-bottom: 2px;
        }
        
        .balance-account {
            font-size: 0.8rem;
            color: hsl(var(--muted-foreground));
        }
        
        .balance-amount {
            font-size: 1.1rem;
            font-weight: 700;
            color: hsl(var(--foreground));
        }
        
        .delete-balance-btn {
            background-color: hsl(0deg 0% 95.88%);
    color: hsl(0deg 0% 24.54%);
            border: none;
            padding: 4px 8px;
            border-radius: var(--radius);
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 150ms ease;
        }
        
        .delete-account-btn:hover {
            background-color: hsl(var(--destructive) / 0.9);
        }
        
        .add-account-form {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .add-account-form input {
            flex: 1;
            min-height: 44px; /* iOS recommended minimum touch target */
            padding: 10px;
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            font-size: 0.9rem;
            background-color: hsl(var(--background));
            color: hsl(var(--foreground));
        }
        
        .add-account-form input:focus {
            outline: 2px solid hsl(var(--ring));
            outline-offset: 2px;
            border-color: hsl(var(--ring));
        }
        
        .add-account-form button {
            background-color: hsl(var(--primary));
            color: hsl(var(--primary-foreground));
            border: none;
            padding: 10px 15px;
            border-radius: var(--radius);
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 150ms ease;
        }
        
        .add-account-form button:hover {
            background-color: hsl(var(--primary) / 0.9);
        }
        
        /* Modal styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .modal-content {
            background-color: hsl(var(--card));
            color: hsl(var(--card-foreground));
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            padding: 24px;
            margin: 20px;
            max-width: 400px;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .modal-title {
            font-size: 1.3rem;
            font-weight: 600;
            color: hsl(var(--foreground));
        }
        
        .modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #666;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s ease;
        }
        
        .modal-close:hover {
            background: rgba(0,0,0,0.1);
        }
        
        .account-list-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: rgba(0,0,0,0.03);
            border-radius: 8px;
            margin-bottom: 8px;
        }
        
        .account-name {
            font-weight: 500;
            color: hsl(var(--foreground));
        }
        
        .delete-account-btn {
            background-color: hsl(0deg 0% 95.88%);
            color: hsl(0deg 0% 24.54%);
            border: none;
            padding: 6px 12px;
            border-radius: var(--radius);
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 150ms ease;
        }
        
        .delete-account-btn:hover {
            background-color: hsl(var(--destructive) / 0.9);
        }
        
        .add-account-form {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid hsl(var(--border));
        }
        
        .add-account-btn {
            background: #27ae60;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            width: 100%;
            margin-top: 10px;
            transition: all 0.2s ease;
        }
        
        .add-account-btn:hover {
            background: #219a52;
        }
        
        /* Slide-out overlays */
        .slide-out-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            z-index: 2000;
        }
        
        .slide-out-overlay.active {
            opacity: 1;
            visibility: visible;
        }
        
        .slide-out-content {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: white;
            border-radius: 20px 20px 0 0;
            padding: 20px 20px 40px;
            transform: translateY(100%);
            transition: transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .slide-out-overlay.active .slide-out-content {
            transform: translateY(0);
        }
        
        .slide-out-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            position: relative;
        }
        
        .slide-out-title {
            font-size: 1.3rem;
            font-weight: 600;
            color: #2c3e50;
        }
        
        .slide-out-close {
            background-color: hsl(var(--muted));
            border: none;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: hsl(var(--foreground));
            transition: all 150ms ease;
        }
        
        .slide-out-close:hover {
            background-color: hsl(var(--muted) / 0.8);
        }
        
        .slide-out-form {
            display: flex;
            flex-direction: column;
        }
        
        /* Handle bar for slide-out - removed */

        /* Account Management Slide-out Styles */
        .account-management-slide-out {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            z-index: 2000;
        }
        
        .account-management-slide-out.active {
            opacity: 1;
            visibility: visible;
        }
        
        .account-management-content {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: hsl(var(--background));
            border-radius: 20px 20px 0 0;
            padding: 20px 20px 40px;
            transform: translateY(100%);
            transition: transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .account-management-slide-out.active .account-management-content {
            transform: translateY(0);
        }
        
        .account-management-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            position: relative;
        }
        
        .account-management-title {
            font-size: 1.3rem;
            font-weight: 600;
            color: hsl(var(--foreground));
        }
        
        .account-management-close {
            background-color: hsl(var(--muted));
            border: none;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: hsl(var(--foreground));
            transition: all 150ms ease;
        }
        
        .account-management-close:hover {
            background-color: hsl(var(--muted) / 0.8);
        }
        
        .account-management-handle {
            display: none;
        }
        
        .account-management-list {
            margin-bottom: 20px;
        }
        
        .account-management-list-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: hsl(var(--card));
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            margin-bottom: 8px;
        }
        
        .account-management-name {
            font-weight: 500;
            color: hsl(var(--foreground));
        }
        
        .account-management-delete-btn {
            background-color: hsl(var(--destructive));
            color: hsl(var(--destructive-foreground));
            border: none;
            padding: 6px 12px;
            border-radius: var(--radius);
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 150ms ease;
            min-height: 32px;
            min-width: 60px;
        }
        
        .account-management-delete-btn:hover {
            background-color: hsl(var(--destructive) / 0.9);
        }
        
        .account-management-add-form {
            border-top: 1px solid hsl(var(--border));
            padding-top: 20px;
        }
        
        .account-management-add-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: hsl(var(--foreground));
            margin-bottom: 15px;
        }
        
        .account-management-input-group {
            margin-bottom: 15px;
        }
        
        .account-management-input {
            width: 100%;
            min-height: 44px;
            padding: 12px 16px;
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            font-size: 1rem;
            background-color: hsl(var(--background));
            color: hsl(var(--foreground));
            transition: all 0.3s ease;
            box-sizing: border-box;
        }
        
        .account-management-input:focus {
            outline: 2px solid hsl(var(--ring));
            outline-offset: 2px;
            border-color: hsl(var(--ring));
        }
        
        .account-management-add-btn {
            background-color: hsl(220, 13%, 18%);
            color: #ffffff;
            border: none;
            padding: 12px 20px;
            border-radius: var(--radius);
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            min-height: 44px;
        }
        
        .account-management-add-btn:hover {
            background-color: hsl(220, 13%, 28%);
        }
        
        .account-management-add-btn:active {
            transform: translateY(1px);
        }
        
        /* Mobile responsive adjustments for account management */
        @media (max-width: 480px) {
            .account-management-content {
                padding: 16px 16px 32px;
            }
            
            .account-management-title {
                font-size: 1.2rem;
            }
            
            .account-management-list-item {
                padding: 10px 12px;
            }
            
            .account-management-delete-btn {
                padding: 8px 12px;
                font-size: 0.75rem;
                min-width: 50px;
            }
            
            .account-management-input {
                padding: 10px 14px;
                font-size: 0.95rem;
            }
            
            .account-management-add-btn {
                padding: 10px 16px;
                font-size: 0.95rem;
            }
        }

        /* Custom Datepicker Styles */
        .custom-datepicker {
            position: relative;
            width: 100%;
        }

        .datepicker-trigger {
            display: flex;
            align-items: center;
            justify-content: space-between;
            min-height: 44px; /* iOS recommended minimum touch target */
            padding: 8px 12px;
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            background-color: hsl(var(--background));
            cursor: pointer;
            transition: all 150ms ease;
            font-size: 0.875rem;
        }

        .datepicker-trigger:hover {
            border-color: hsl(var(--ring));
        }

        .datepicker-trigger:focus {
            outline: none;
            border-color: hsl(var(--ring));
            box-shadow: 0 0 0 2px hsl(var(--ring) / 0.2);
        }
        
        .datepicker-trigger:focus-visible {
            outline: 2px solid hsl(var(--ring));
            outline-offset: 2px;
        }

        .datepicker-value {
            color: hsl(var(--foreground));
            flex: 1;
        }

        .datepicker-trigger .w-4 {
            width: 16px;
            height: 16px;
            color: hsl(var(--muted-foreground));
        }

        .datepicker-popup {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            z-index: 1000;
            background-color: hsl(var(--popover));
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            padding: 16px;
            margin-top: 4px;
            display: none;
            min-width: 280px;
        }

        .datepicker-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 16px;
        }

        .datepicker-nav {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            border: none;
            background: none;
            cursor: pointer;
            border-radius: var(--radius);
            transition: all 150ms ease;
        }

        .datepicker-nav:hover {
            background-color: hsl(var(--muted));
        }

        .datepicker-nav .w-4 {
            width: 16px;
            height: 16px;
            color: hsl(var(--foreground));
        }

        .datepicker-month-year {
            font-weight: 600;
            color: hsl(var(--foreground));
            font-size: 0.875rem;
        }

        .datepicker-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 2px;
            margin-bottom: 16px;
        }

        .datepicker-day-header {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 32px;
            font-size: 0.75rem;
            font-weight: 500;
            color: hsl(var(--muted-foreground));
        }

        .datepicker-day {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 32px;
            border-radius: var(--radius);
            cursor: pointer;
            transition: all 150ms ease;
            font-size: 0.875rem;
            color: hsl(var(--foreground));
        }

        .datepicker-day:hover {
            background-color: hsl(var(--muted));
        }

        .datepicker-day.empty {
            cursor: default;
        }

        .datepicker-day.empty:hover {
            background-color: transparent;
        }

        .datepicker-day.today {
            background-color: hsl(var(--muted));
            font-weight: 500;
        }

        .datepicker-day.selected {
            background-color: hsl(var(--primary));
            color: hsl(var(--primary-foreground));
        }

        .datepicker-day.selected:hover {
            background-color: hsl(var(--primary));
        }

        .datepicker-footer {
            display: flex;
            justify-content: space-between;
            gap: 8px;
        }

        .datepicker-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 8px 16px;
            border-radius: var(--radius);
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 150ms ease;
            border: 1px solid transparent;
            flex: 1;
        }

        .datepicker-btn-secondary {
            background-color: hsl(var(--secondary));
            color: hsl(var(--secondary-foreground));
            border-color: hsl(var(--border));
        }

        .datepicker-btn-secondary:hover {
            background-color: hsl(var(--secondary) / 0.8);
        }

        .datepicker-btn-primary {
            background-color: hsl(var(--primary));
            color: hsl(var(--primary-foreground));
        }

        .datepicker-btn-primary:hover {
            background-color: hsl(var(--primary) / 0.9);
        }

        /* Mobile responsive adjustments */
        @media (max-width: 480px) {
            .datepicker-popup {
                min-width: calc(100vw - 40px);
                left: 50%;
                transform: translateX(-50%);
            }
        }

        /* --- Slide-out form full-width fields --- */
        .slide-out-form .form-group {
            /* width: 100%; */
            box-sizing: border-box;
        }
        .slide-out-form .input-row {
            display: flex;
            flex-direction: row;
            gap: 0.5rem;
            /* width: 100%; */
            /* max-width: 100%; */
        }
        .slide-out-form .input-row .form-group,
        .slide-out-form .input-row .select-container {
            flex: 1 1 0;
            min-width: 0;
        }
        .slide-out-form input,
        .slide-out-form select,
        .slide-out-form .select-trigger {
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
        }
        .slide-out-form .select-trigger {
            display: flex;
        }
        .slide-out-form .select-content {
            min-width: 100%;
        }
        @media (max-width: 600px) {
            .slide-out-form .input-row {
                flex-direction: column;
                gap: 0.5rem;
            }
        }
        /* --- Slide-out form: Amount and Category side by side, override global input-group rules --- */
        .slide-out-form .input-row {
            display: flex;
            flex-direction: row;
            gap: 0.5rem;
        }
        .slide-out-form .input-row .form-group {
            flex: 1 1 0;
            min-width: 0;
            margin-bottom: 0;
        }
        .slide-out-form .input-row .form-group label,
        .slide-out-form .input-row .form-group input,
        .slide-out-form .input-row .form-group select,
        .slide-out-form .input-row .select-container {
            display: initial;
            width: 100%;
            margin-bottom: 0.5rem;
        }

        /* Floating Action Button (FAB) Styles */
        .fab-container {
            position: fixed;
            bottom: 80px; /* Above bottom nav */
            right: 20px;
            z-index: 1000;
        }

        .fab-primary {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: hsl(var(--primary));
            color: hsl(var(--primary-foreground));
            border: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .fab-primary:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
        }

        .fab-menu {
            position: absolute;
            bottom: 70px;
            right: 0;
            display: none;
            flex-direction: column;
            gap: 12px;
            align-items: flex-end;
        }

        .fab-menu.active {
            display: flex;
        }

        .fab-option {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            background: hsl(var(--card));
            border: 1px solid hsl(var(--border));
            border-radius: 24px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
        }

        .fab-option:hover {
            background: hsl(var(--accent));
            transform: translateX(-4px);
        }

        .fab-option-icon {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .quick-action-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 2em;
            height: 2em;
            background: #ffffff48;
            border-radius: 50%;
            color: hsl(var(--primary));
            font-size: 1.1em;
        }
        .quick-action-title {
            font-size: 1.08rem;
            font-weight: 500;
            margin: 0;
            padding: 0;
            color: #fff;
        }

        /* Hide old action buttons - now using Quick Action Cards */
        .action-buttons {
            display: none !important;
        }

        /* Hide FAB - now using Quick Action Cards */
        .fab-container {
            display: none !important;
        }

        /* Better spacing between card sections */
        
        .expense-input {
            margin-bottom: 32px;
        }
        
        /* Quick actions spacing */
        .quick-actions {
            position: sticky;
            z-index: 100000;
            display: flex;
            justify-content: center;
            /* width: max-content; */
            /* right: auto; */
            bottom: 0;
            transform: translateY(0);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .quick-actions.hidden {
            transform: translateY(100%);
        }
        
        /* Savings section spacing */
        .savings-accounts-section {
            margin-top: 8px;
        }

        .quick-action-card {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 0.5em 1.4em;
            background: linear-gradient(135deg, hsl(260deg 58.02% 57.98%), hsl(260deg 54.55% 69.74%));
            color: #ffffff;
            border: 2px solid hsl(260deg 15.51% 46.37%);
            border-radius: 11rem;
            font-size: 1.08rem;
            font-weight: 500;
            cursor: pointer;
            transition: box-shadow 0.16s, background 0.16s, transform 0.12s;
            box-shadow: 0 2px 19px 11px rgb(100 48 141 / 12%);
            margin: 0;
            min-height: 44px;
            outline: none;
        }
        .quick-action-card:hover,
        .quick-action-card:focus {
            background: linear-gradient(135deg, hsl(260deg 58.02% 57.98%), hsl(260deg 54.55% 69.74%));
            box-shadow: 0 4px 12px 0 rgba(0,0,0,0.25);
        }
        .quick-action-card:active {
            background: linear-gradient(135deg, hsl(260, 46%, 38%), hsl(260, 39%, 40%));
            transform: scale(0.98);
            color: #ffffff;
        }
        .quick-action-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 1.7em;
            height: 1.7em;
            background: none;
            border-radius: 50%;
            color: #ffffff;
            font-size: 1.1em;
            margin: 0;
        }
        .quick-action-title {
            font-size: 1.08rem;
            font-weight: 500;
            margin: 0;
            padding: 0;
            color: #ffffff;
            letter-spacing: 0.01em;
        }

        .fab-option:active {
            transform: translateY(2px);
        }

        .chart-overlay.visible .chart-tooltip {
            opacity: 1;
            transform: translateY(0);
        }
        
        .chart-overlay.visible .chart-crosshair {
            opacity: 1;
        }

        .fab-option:active {
            transform: translateY(2px);
        }

        /* Make form containers use grid for full-width buttons */
        .slide-out-form,
        .form-group:has(.add-btn),
        .form-group:has(.balance-add-btn),
        .form-group:has(.account-management-add-btn) {
            display: grid;
            grid-template-columns: 1fr;
            gap: 0.5rem;
        }
        
        /* Ensure the button container takes full width */
        .slide-out-form > .add-btn,
        .slide-out-form > .balance-add-btn,
        .account-management-add-form > .account-management-add-btn {
            grid-column: 1 / -1;
            width: 100%;
            max-width: none;
        }
        
        /* Make main expense form use grid for full-width button */
        .expense-input {
            display: grid;
            grid-template-columns: 1fr;
            gap: 0.5rem;
        }
        
        .expense-input > .add-btn {
            grid-column: 1 / -1;
            width: 100%;
            max-width: none;
        }

        .expense-amount.positive {
          color: hsl(var(--foreground));
        }


        .header-actions {
            display: flex;
            align-items: center;
            gap: 18px;
        }

        .icon-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0;
            display: flex;
            align-items: center;
        }

        /* Settings Screen Styles */
        .form-group {
            margin-bottom: 0.75rem; /* consistent spacing */
        }

        .form-label {
            display: block;
            font-size: 0.875rem;
            font-weight: 500;
            color: hsl(var(--foreground));
            margin-bottom: 0.5rem;
        }

        .form-input {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            font-size: 0.875rem;
            background-color: hsl(var(--background));
            color: hsl(var(--foreground));
            transition: border-color 0.2s ease;
            min-height: 44px;
        }

        .form-input:focus {
            outline: none;
            border-color: hsl(var(--ring));
            box-shadow: 0 0 0 2px hsl(var(--ring) / 0.2);
        }

        .form-help {
            font-size: 0.75rem;
            color: hsl(var(--muted-foreground));
            margin-top: 0.25rem;
        }

        .budget-summary {
            display: grid;
            gap: 0.75rem; /* consistent spacing */
        }

        .budget-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            background-color: hsl(var(--muted));
            border-radius: var(--radius);
        }

        .budget-label {
            font-size: 0.875rem;
            color: hsl(var(--muted-foreground));
        }

        .budget-value {
            font-size: 1rem;
            font-weight: 600;
            color: hsl(var(--foreground));
        }

        .budget-value.positive {
            color: hsl(var(--success));
        }

        .budget-value.negative {
            color: hsl(var(--destructive));
        }

        .budget-value.warning {
            color: hsl(var(--warning));
        }

        /* Tax Calculator Styles */
        .tax-calculator-section {
            margin-bottom: 1rem;
        }

        .tax-calculator-header {
            margin-bottom: 0.75rem;
        }

        .tax-calculator-inputs {
            display: grid;
            gap: 0.75rem;
            margin-bottom: 0.75rem;
        }

        .tax-calculator-inputs .form-group {
            margin-bottom: 0;
        }

        .calculate-btn {
            background-color: hsl(var(--primary));
            color: hsl(var(--primary-foreground));
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: var(--radius);
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 150ms ease;
            width: 100%;
        }

        .calculate-btn:hover {
            background-color: hsl(var(--primary) / 0.9);
        }

        .tax-results {
            background-color: hsl(var(--muted));
            border-radius: var(--radius);
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .tax-summary {
            display: grid;
            gap: 0.75rem;
        }

        .tax-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0;
            border-bottom: 1px solid hsl(var(--border));
        }

        .tax-item:last-child {
            border-bottom: none;
        }

        .tax-item.total {
            border-top: 2px solid hsl(var(--border));
            border-bottom: none;
            padding-top: 0.75rem;
            margin-top: 0.5rem;
            font-weight: 600;
        }

        .tax-label {
            font-size: 0.875rem;
            color: hsl(var(--muted-foreground));
        }

        .tax-value {
            font-size: 0.875rem;
            font-weight: 500;
            color: hsl(var(--foreground));
        }

        .tax-item.total .tax-label,
        .tax-item.total .tax-value {
            font-weight: 600;
            color: hsl(var(--foreground));
        }

        .form-divider {
            height: 1px;
            background-color: hsl(var(--border));
            margin: 1rem 0;
        }

        .manual-override-section {
            margin-top: 1rem;
        }

        /* Accordion Styles */
        .accordion-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem;
            background-color: hsl(var(--muted));
            border-radius: var(--radius);
            cursor: pointer;
            transition: all 150ms ease;
            user-select: none;
        }

        .accordion-header:hover {
            background-color: hsl(var(--muted) / 0.8);
        }

        .accordion-header h4 {
            margin: 0;
        }

        .accordion-icon {
            width: 1.25rem;
            height: 1.25rem;
            transition: transform 150ms ease;
            color: hsl(var(--muted-foreground));
        }

        .accordion-header.expanded .accordion-icon {
            transform: rotate(180deg);
        }

        .accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 150ms ease;
        }

        .accordion-content.expanded {
            max-height: 1000px;
            padding-top: 1rem;
        }

        /* Settings Slide-out Panel */
        .settings-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: transparent;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .settings-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .settings-panel {
            position: fixed;
            top: 0;
            right: -100%;
            width: 100%;
            height: 100%;
            background-color: hsl(var(--background));
            z-index: 1001;
            overflow-y: auto;
            transition: right 0.3s ease, transform 0.3s ease;
            box-sizing: border-box;
            box-shadow: -4px 0 20px rgba(0, 0, 0, 0.15);
        }

        .settings-panel.active {
            right: 0;
        }

        /* Budget panel transition */
        .budget-panel {
            position: fixed;
            top: 0;
            right: -100%;
            width: 100%;
            height: 100%;
            background-color: hsl(var(--background));
            z-index: 1002;
            overflow-y: auto;
            transition: right 0.3s ease;
            box-sizing: border-box;
            box-shadow: -4px 0 20px rgba(0, 0, 0, 0.15);
        }

        .budget-panel.active {
            right: 0;
        }

        /* Settings panel slide transition when budget is open */
        .settings-panel.budget-open {
            transform: translateX(-10px);
        }

        /* Main content slide transition */
        .app-container {
            transition: transform 0.3s ease;
        }

        .app-container.settings-open {
            transform: translateX(-10px);
        }

        /* Account Detail Screen */
        .account-detail-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: transparent;
            z-index: 1100;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .account-detail-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .account-detail-screen {
            position: fixed;
            top: 0;
            right: -100%;
            width: 100%;
            height: 100%;
            background-color: hsl(var(--background));
            transition: right 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            overflow-y: auto;
            padding: 0;
            box-shadow: -4px 0 20px rgba(0, 0, 0, 0.15);
        }

        .account-detail-overlay.active .account-detail-screen {
            right: 0;
        }

        .account-detail-header {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            background-color: hsl(var(--background));
            border-bottom: 1px solid hsl(var(--border));
            position: sticky;
            top: 0;
            z-index: 10;
            position: relative;
        }

        .account-detail-back {
            background: none;
            border: none;
            padding: 0.5rem;
            border-radius: 50%;
            cursor: pointer;
            transition: background-color 0.2s ease;
            color: hsl(var(--foreground));
            position: absolute;
            left: 1rem;
            top: 50%;
            transform: translateY(-50%);
        }

        .account-detail-back:hover {
            background-color: hsl(var(--accent));
        }

        .account-detail-title-container {
            flex: 1;
            text-align: center;
        }

        .account-detail-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin: 0;
            color: hsl(var(--foreground));
        }

        .account-detail-balance {
            font-size: 1.125rem;
            color: hsl(var(--muted-foreground));
            margin-top: 0.25rem;
        }

        .account-detail-chart-card {
            margin: 0;
            margin-bottom: 0.5rem;
            border-radius: 0;
            border-left: none;
            border-right: none;
        }

        .account-detail-activity {
            margin: 0.5rem 1rem;
        }

        .account-detail-transactions {
            margin: 0.5rem 1rem 1rem;
        }

        /* Canvas styling for account detail chart */
        #accountDetailCanvas {
            padding: 0;
            margin: 0;
            display: block;
            width: 100%;
            height: 100%;
        }

        .settings-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1rem;
            border-bottom: 1px solid hsl(var(--border));
            background-color: hsl(var(--background));
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .settings-title {
            font-size: 1.125rem;
            font-weight: 600;
            color: hsl(var(--foreground));
            flex: 1;
            text-align: center;
        }

        .settings-back {
            background: none;
            border: none;
            color: hsl(var(--muted-foreground));
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 0.5rem;
            transition: background-color 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .settings-back:hover {
            background-color: hsl(var(--muted));
        }

        .settings-content {
            padding: 1rem;
        }

        @media (min-width: 768px) {
            .settings-panel {
                width: 400px;
            }
            .budget-panel {
                width: 400px;
            }
        }

        .card-content > *:not(:last-child) {
            margin-bottom: 0.75rem; /* consistent spacing between groups in a card */
        }

        .card {
            margin-bottom: 0.85rem; /* consistent spacing between cards */
        }

        .settings-menu-list {
  list-style: none;
  padding: 0;
  margin: 0;
}
.settings-menu-item {
  display: flex;
  align-items: center;
  padding: 2rem 0.5rem;
  border-bottom: 1px solid #eee;
  cursor: pointer;
  color: #111;
  font-size: 1.08rem;
  font-weight: 500;
  background: none;
}
.settings-menu-item:last-child {
  border-bottom: none;
}
.settings-menu-icon {
  margin-right: 1rem;
  display: flex;
  align-items: center;
  color: #111;
}
.settings-menu-arrow {
  margin-left: auto;
  color: #111;
  display: flex;
  align-items: center;
}
.settings-menu-btn-item {
  padding: 1rem 0.5rem 0rem 0.5rem;
}

/* Loading spinner for settings menu items */
.settings-menu-arrow .spinner-circle {
  width: 16px;
  height: 16px;
  border: 2px solid #e0e0e0;
  border-top: 2px solid #111;
  border-radius: 50%;
  animation: spin 1s linear infinite;
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}
.settings-menu-btn {
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: flex-start;
  gap: 1rem;
  font-size: 1.08rem;
  font-weight: 500;
  background: hsl(var(--primary));
  color: hsl(var(--primary-foreground));
  border: none;
  border-radius: var(--radius);
  padding: 0.75rem 1.5rem;
  cursor: pointer;
  margin: 0;
}
.settings-menu-btn .settings-menu-icon {
  color: #fff;
}

.account-accordion {
  border: 1px solid #e5e7eb;
  border-radius: 12px;
  margin-bottom: 1.2rem;
  background: #fff;
  box-shadow: 0 1px 2px rgba(0,0,0,0.02);
}
.account-accordion-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.5rem;
  cursor: pointer;
  font-weight: bold;
  background: #fff;
  border-bottom: 1px solid #f3f4f6;
  border-radius: 12px 12px 0 0;
}
.account-accordion-title {
  font-size: 1.1rem;
  font-weight: 600;
}
.account-accordion-value {
  font-size: 1.1rem;
  font-weight: 700;
  color: hsl(var(--success));
  margin-left: auto;
}
.account-accordion-chevron {
  font-size: 1.2rem;
  margin-left: 0.5rem;
  color: #888;
}
.account-accordion-body {
  padding: 0.5rem 1.5rem 1rem 1.5rem;
  background: #fafbfc;
  border-radius: 0 0 12px 12px;
}
.account-accordion-updates {
  margin: 0;
  padding: 0;
}
.account-update-row {
  display: flex;
  align-items: flex-end;
  justify-content: space-between;
  padding: 0.5rem 0;
  border-bottom: 1px solid #eee;
  font-size: 1rem;
}
.account-update-row:last-child {
  border-bottom: none;
}
.account-update-date {
  font-size: 1rem;
  color: #333;
  font-weight: 500;
}
.account-update-diff {
  font-size: 1.1rem;
  font-weight: 600;
  margin-left: 1rem;
}
.account-update-percent {
  font-size: 0.95rem;
  margin-left: 1rem;
  margin-top: 0.1rem;
  color: #888;
}
.account-update-percent.positive {
  color: #27ae60;
}
.account-update-percent.negative {
  color: #e74c3c;
}
.account-update-percent.neutral {
  color: #888;
}

/* Modern Wealthsimple-style Account Accordion Styles */
.modern-account-accordion {
    background: transparent;
    box-shadow: none;
    transition: none;
    border-bottom: 1px solid #eeeeee;
    margin: 0 -1rem;
    padding: 0;
    width: calc(100% + 2rem);
}
.modern-account-accordion.expanded {
    border-bottom: none;
}
.account-type-section .modern-account-accordion:last-child {
    border-bottom: none;
    margin-bottom: 0;
}
.modern-account-accordion-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem;
  cursor: pointer;
  border-radius: 18px 18px 0 0;
  background: transparent;
  transition: none;
  box-shadow: none;
  margin: 0 -1rem;
  width: calc(100% + 2rem);
}

.modern-account-header-left {
  flex: 1 1 auto;
  display: flex;
  flex-direction: column;
  justify-content: center;
}
.modern-account-title {
 font-size: 0.9rem;
text-transform: uppercase;
font-weight: 800;
color: #787878;
letter-spacing: 0.04em;
}
.modern-account-header-right {
  display: flex;
margin-right: 0.5rem;   
  flex-direction: column;
  align-items: flex-end;
  margin-left: 1.2rem;
  font-size: 0.98rem;
  transition: opacity 0.2s;
}
.modern-account-accordion-header.expanded .modern-account-header-right {
  display: none;
}
.modern-account-balance {
  font-size: 1rem;
  font-weight: 700;
  color: #222;
  line-height: 1.1;
}

.modern-account-change {
  font-size: 0.8rem;
  font-weight: 500;
  margin-top: 0.2rem;
  display: flex;
  align-items: center;
  gap: 0.25rem;
}

.modern-account-change.positive {
  color: #10b981;
}

.modern-account-change.negative {
  color: #ef4444;
}

.modern-account-change .change-arrow {
  width: 12px;
  height: 12px;
  transform: rotate(-45deg);
}

.modern-account-change.negative .change-arrow {
  transform: rotate(45deg);
}
.modern-account-balance.debt {
  color: hsl(var(--foreground));
}
.modern-update-diff.debt {
  color: hsl(var(--foreground));
}
.modern-account-percent {
  font-size: 1.02rem;
  font-weight: 600;
  margin-top: 0.18rem;
  color: #27ae60;
}
.modern-account-percent.negative {
  color: #e74c3c;
}
.account-chevron {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 30px;
    height: 30px;
    background: none;
    box-shadow: none;
}
.modern-account-chevron {
    font-size: 1.45rem;
    display: flex;
    color: #666;
    align-self: center;
    align-items: center;
    justify-content: center;
    transition: transform 0.3s cubic-bezier(0.4,0,0.2,1);
    background: none !important;
    border-radius: 0 !important;
    width: 18px;
    box-shadow: none;
}
.modern-account-accordion-header.expanded .modern-account-chevron {
  transform: rotate(180deg);
  background: none;
}

/* Account sections by type - using same styling as home sections */
.account-type-section {
  margin-bottom: 1rem;
  cursor: pointer;
  position: relative;
  background-color: hsl(var(--card)) !important;
  border: 2px solid hsl(var(--border) / 0.5) !important;
  border-radius: 12px;
  box-shadow: none !important;
  padding: 0rem 2rem;
  overflow: hidden;
}

.account-type-section.expanded {
  border-color: hsl(var(--primary) / 0.3) !important;
  box-shadow: 0 0 0 1px hsl(var(--primary) / 0.1) !important;
}
.account-type-section .card-header {
  background-color: transparent;
  border-bottom: none;
  display: flex;
  justify-content: space-between;
  align-items: center;
  cursor: pointer;
  margin: 0 -1rem;
  /* padding: 1rem; */
  width: calc(100% + 2rem);
}
.account-type-section .section-title {
  font-size: 1.25rem;
  font-weight: 600;
  margin: 0;
  color: hsl(var(--foreground));
}
.account-type-section .card-body {
  padding: 0;
  display: block;
  margin-top: 0.5rem;
}
.account-type-section.collapsed .card-body {
  display: none;
}
.account-type-section .account-chevron {
  transition: transform 0.2s ease;
}
.account-type-section .modern-account-chevron {
  width: 18px;
  height: 18px;
}
.modern-account-accordion-body {
  padding: 0;
  background: none;
  border-radius: 0 0 18px 18px;
  box-shadow: none;
  max-height: 0;
  overflow: hidden;
  opacity: 0;
  transition: max-height 0.35s cubic-bezier(0.4,0,0.2,1), opacity 0.25s cubic-bezier(0.4,0,0.2,1);
}
.modern-account-accordion-body.expanded {
  max-height: 1000px;
  opacity: 1;
  transition: max-height 0.45s cubic-bezier(0.4,0,0.2,1), opacity 0.25s cubic-bezier(0.4,0,0.2,1);
}
.modern-account-updates {
  margin: 0;
  padding: 0;
}
.modern-account-update-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0.75rem 1rem;
  margin-bottom: 0;
  background: #fff;
  border-radius: 0;
  box-shadow: none;
  width: 100%;
  font-size: 0.875rem;
  width: 100%;
  border-bottom: none;
}
.modern-account-updates .swipe-container {
  margin: 0 -1rem 0 -1rem;
  border-radius: 0;
  width: calc(100% + 2rem);
}
.modern-account-updates .swipe-container:last-child {
  margin-bottom: 0;
}
.modern-account-updates .swipe-container:last-child .swipe-content {
  border-bottom: none !important;
}
.modern-update-date {
  font-size: 0.875rem;
  color: #444;
  font-weight: 500;
  flex: 1 1 40%;
  align-self: center;
}
.modern-update-amount-stack {
  display: flex;
  flex-direction: column;
  align-items: flex-end;
  flex: 0 0 auto;
  min-width: 0;
  gap: 0.125rem;
  text-align: right;
}
.modern-update-diff {
  font-size: 0.875rem;
  font-weight: 600;
  color: #222;
  margin-left: 0;
  margin-bottom: 0;
}
.modern-update-percent {
  font-size: 0.75rem;
  color: #27ae60;
  font-weight: 500;
  margin-left: 0;
}
.modern-update-percent.negative {
  color: #e74c3c;
}
.modern-update-percent.neutral {
  color: #888;
}

        

    
        /* Modern Balance Card Styling */
        .modern-balance-card {
            flex-direction: row;
            justify-content: space-between;
            /* align-items: center; */
            padding: 20px;
            /* background-color: white; */
            border-radius: 16px;
            /* box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05); */
            margin-bottom: 20px;
        }
        
        .balance-date-modern {
            font-size: 1rem;
            font-weight: 500;
            color: hsl(var(--muted-foreground));
        }
        
        .balance-right-stack {
            display: flex;
            flex-direction: column;
        }
        
        .current-balance-modern {
            font-size: 1.8rem;
            font-weight: 700;
            color: hsl(var(--foreground));
            margin-bottom: 2px;
        }
        
        .balance-change-modern {
            font-size: 0.9rem;
            font-weight: 500;
            color: hsl(var(--muted-foreground));
        }
        
        .balance-change-modern.positive {
            color: hsl(var(--success));
        }
        
        .balance-change-modern.negative {
            color: #e74c3c;
        }
        
        /* Mobile responsiveness for modern balance card */
        @media (max-width: 480px) {
            .modern-balance-card {
                padding: 15px;
            }
            
            .current-balance-modern {
                font-size: 1.5rem;
            }
            
            .balance-date-modern {
                font-size: 0.9rem;
            }
        }

      

         
        .swipe-content {
            position: relative;
            align-items: center;
            justify-content: space-between;
            display: flex;
            background-color: hsl(var(--card));
            border-bottom: 1px solid hsl(var(--border));
            box-shadow: none;
            transform: translateX(0);
            transition: transform 0.2s ease;
            z-index: 2;
            /* border-radius: var(--radius); */
            width: 100%;
            /* will-change: transform; */
            overflow: hidden;
            position: relative;
            width: 100%;
            border-bottom: 1px solid hsl(var(--border));
        }
        
       

        .swipe-container.swiped .swipe-content {
            transform: translateX(-80px);
        }

        .swipe-container.deleting {
            animation: slide-out 0.3s ease-out forwards;
            height: 0;
            margin: 0;
            padding: 0;
            opacity: 0;
            pointer-events: none;
            overflow: hidden;
            transition: all 0.3s ease-out;
        }
        .swipe-container.deleting .swipe-content {
            transform: translateX(-100%);
            transition: transform 0.3s ease-out;
            opacity: 0;
        }

        @keyframes slide-out {
            0% {
                transform: translateX(0);
                opacity: 1;
                max-height: 100px;
                margin-bottom: 8px;
            }
            75% {
                transform: translateX(-100%);
                opacity: 0;
                max-height: 100px;
            }
            100% {
                transform: translateX(-100%);
                opacity: 0;
                max-height: 0px;
                margin: 0;
                padding: 0;
            }
        }
        
        /* Make sure balance items have the same swipe styling as expense items */
        .swipe-container .balance-item,
        .swipe-container .modern-balance-history-item {
            /* border: none; */
            box-shadow: none;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
        }

        .modern-balance-history-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }

        .balance-history-date {
            font-weight: 600;
            color: hsl(var(--foreground));
        }

        .balance-history-right {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }

        .balance-history-amount {
            font-size: 1.1rem;
            font-weight: 700;
            color: hsl(var(--foreground));
        }

        .balance-history-percent {
            font-size: 0.8rem;
            display: flex;
            align-items: center;
        }

        .balance-history-percent.positive {
            color: hsl(var(--success));
        }

        .balance-history-percent.negative {
            color: #e74c3c;
        }

        .balance-history-percent.neutral {
            color: #888;
        }

        .balance-arrow {
            margin-right: 4px;
        }

        .last-updated-note {
            font-size: 0.8rem; 
            color: #a2a2a2; 
            margin-top: 0; 
            margin-bottom: 10px; 
            text-align: left;  
            display: block; /* Always visible */
        }

    
    </style>
</head>
<body>
    <div id="app" class="app-container">
       

        <!-- Add this just above the screens wrapper -->
        <div class="app-header">
            <div id="user-avatar"></div>
            <div class="header-actions">
                <button class="icon-btn" id="settingsButton" onclick="openSettings()" aria-label="Settings">
                    <i data-lucide="menu" class="w-6 h-6"></i>
                </button>
            </div>
        </div>
        
        <div class="content-container">
            <div class="screens-wrapper" id="screensWrapper">
                <!-- Screen 0: Home -->
                <div class="screen">
                    <!-- Budget Overview Section -->
                    <div class="card home-section" onclick="openBudgetFlow()">
                        <div class="card-header">
                            <div class="home-section-header">
                                <h3 class="section-title">Budget</h3>
                                <div class="section-subtitle" id="budgetSubtitle">Monthly overview</div>
                            </div>
                            <div class="budget-timerange-toggle">
                                <button class="timerange-btn active" data-range="monthly" onclick="event.stopPropagation(); toggleBudgetTimeRange('monthly')">Month</button>
                                <button class="timerange-btn" data-range="yearly" onclick="event.stopPropagation(); toggleBudgetTimeRange('yearly')">Year</button>
                            </div>
                        </div>
                        <div class="card-content">
                            <!-- Savings Progress Bar -->
                            <div class="budget-bar-section">
                                <div class="budget-bar-header">
                                    <span class="budget-bar-label">Savings Goal</span>
                                    <span class="budget-bar-amount" id="savingsAmount">$1,200 / $2,000</span>
                                </div>
                                <div class="budget-progress-bar">
                                    <div class="budget-progress-fill savings-fill" id="savingsProgress" style="width: 60%"></div>
                                </div>
                            </div>
                            
                            <!-- Spending Breakdown Bar -->
                            <div class="budget-bar-section">
                                <div class="budget-bar-header">
                                    <span class="budget-bar-label">Spending Breakdown</span>
                                    <span class="budget-bar-amount" id="spendingAmount">$3,701 / $3,701</span>
                                </div>
                                <div class="budget-spending-bar">
                                    <div class="spending-segment fixed" id="fixedSpending" style="width: 66.2%" title="Fixed: $2,450"></div>
                                    <div class="spending-segment essential" id="essentialSpending" style="width: 20.3%" title="Essential: $750"></div>
                                    <div class="spending-segment discretionary" id="discretionarySpending" style="width: 13.5%" title="Discretionary: $501"></div>
                                </div>
                                <div class="budget-legend">
                                    <div class="legend-item">
                                        <div class="legend-dot fixed"></div>
                                        <span>Fixed</span>
                                    </div>
                                    <div class="legend-item">
                                        <div class="legend-dot essential"></div>
                                        <span>Essential</span>
                                    </div>
                                    <div class="legend-item">
                                        <div class="legend-dot discretionary"></div>
                                        <span>Discretionary</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Transactions Section -->
                    <div class="card home-section" onclick="goToScreen(1); scrollToTransactions()">
                        <div class="card-header home-section-header">
                            <div class="section-header-left">
                                <h3 class="section-title">Transactions</h3>
                                <div class="section-subtitle">Most recent</div>
                            </div>
                            <div class="section-header-right">
                                <div class="section-subtitle">View all <i data-lucide="chevron-right" class="w-4 h-4 inline"></i></div>
                            </div>
                        </div>
                        <div class="card-content">
                            <div id="homeTransactionsList">No recent transactions</div>
                        </div>
                    </div>
                    
                    <!-- Cashflow Section -->
                    <div class="card home-section">
                        <div class="card-header">
                            <div class="home-section-header">
                                <h3 class="section-title">Spending</h3>
                                <div class="section-subtitle" id="cashflowSubtitle">This week vs. last week</div>
                            </div>
                            <div class="cashflow-menu-container">
                                <button class="dot-menu-btn" onclick="toggleCashflowDropdown()" id="cashflowMenuBtn">
                                    <i data-lucide="more-horizontal" class="w-5 h-5"></i>
                                </button>
                                <div class="dropdown-menu dropdown-right" id="cashflowDropdown">
                                    <div class="dropdown-header">Select date range</div>
                                    <div class="dropdown-item active" onclick="updateCashflowRange('week')">This week vs. last week</div>
                                    <div class="dropdown-item" onclick="updateCashflowRange('month')">This month vs. last month</div>
                                    <div class="dropdown-item" onclick="updateCashflowRange('year')">This month vs. last year</div>
                                    <div class="dropdown-item" onclick="updateCashflowRange('average')">This month vs. average month</div>
                                    <div class="dropdown-item" onclick="updateCashflowRange('ytd')">This year vs. last year</div>
                                </div>
                            </div>
                        </div>
                        <div class="card-content">
                            <div class="chart-container full-width-chart">
                                <canvas id="homeCashflowCanvas"></canvas>
                                <div class="chart-overlay" id="homeCashflowOverlay">
                                    <div class="chart-crosshair" id="homeCashflowCrosshair"></div>
                                </div>
                            </div>
                            
                            <!-- Chart Legend -->
                            <div class="chart-legend" id="cashflowLegend">
                                <div class="legend-item">
                                    <div class="legend-color" style="background: linear-gradient(to bottom, #8b5cf6, #7c3aed);"></div>
                                    <span class="legend-label">This month</span>
                                </div>
                                <div class="legend-item">
                                    <div class="legend-color" style="background: #d1d5db;"></div>
                                    <span class="legend-label">Last month</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    

                    
                    <!-- Net Worth Section -->
                    <div class="card home-section" onclick="handleNetWorthCardClick(event)">
                        <div class="card-header home-section-header">
                            <div class="section-header-left">
                                <h3 class="section-title" id="netWorthTitle">$68,502 net worth</h3>
                                <div class="section-change" id="netWorthChange">
                                    <i data-lucide="arrow-up" class="w-4 h-4 inline"></i>
                                    <span>$210.32 (0.3%)</span>
                                </div>
                                <div class="section-subtitle" id="netWorthSubtitle">All time</div>
                            </div>
                            <div class="section-header-right">
                                <div class="cashflow-menu-container">
                                    <button class="dot-menu-btn" onclick="toggleNetWorthDropdown()" id="netWorthMenuBtn">
                                        <i data-lucide="more-horizontal" class="w-5 h-5"></i>
                                    </button>
                                    <div class="dropdown-menu dropdown-right" id="netWorthDropdown">
                                        <div class="dropdown-header">Select date range</div>
                                        <div class="dropdown-item" onclick="updateNetWorthRange('1m')">1 month</div>
                                        <div class="dropdown-item" onclick="updateNetWorthRange('3m')">3 months</div>
                                        <div class="dropdown-item" onclick="updateNetWorthRange('6m')">6 months</div>
                                        <div class="dropdown-item" onclick="updateNetWorthRange('ytd')">Year to date</div>
                                        <div class="dropdown-item" onclick="updateNetWorthRange('1y')">1 year</div>
                                        <div class="dropdown-item active" onclick="updateNetWorthRange('all')">All time</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="card-content">
                            <div class="chart-container full-width-chart">
                                <canvas id="homeNetWorthCanvas"></canvas>
                                <div class="chart-overlay" id="homeNetWorthOverlay">
                                    <div class="chart-crosshair" id="homeNetWorthCrosshair"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Screen 1: Cashflow (formerly Tracking) -->
                <div class="screen">
                    <!-- Budget Display Section -->
                    <div class="card home-section" id="budgetDisplay">
                        <div class="card-header">
                            <div class="home-section-header">
                                <div class="section-subtitle" style="margin-top: 0.7rem; margin-bottom: 0.7rem; text-align: center;">Monthly Overview</div>
                            </div>
                        </div>
                        <div class="card-content">
                            <div class="chart-carousel" id="chartCarousel">
                                <div class="chart-slide active" id="monthlyChartSlide">
                                    <div class="monthly-spending-chart" id="monthlySpendingChart">
                                        <!-- Monthly bars will be generated dynamically -->
                                    </div>
                                    <div id="selectedMonthTotal" class="selected-month-total">
                                        <!-- Total for selected month will be displayed here -->
                                    </div>
                                </div>
                                <div class="chart-slide" id="categoryChartSlide">
                                    <div class="category-spending-chart" id="categorySpendingChart">
                                        <!-- Category bars will be generated dynamically -->
                                    </div>
                                    <div id="selectedCategoryTotal" class="selected-month-total">
                                        <!-- Total for selected category will be displayed here -->
                                    </div>
                                </div>
                            </div>
                            <div class="chart-dots" id="chartDots">
                                <div class="dot active" onclick="switchToChart(0)"></div>
                                <div class="dot" onclick="switchToChart(1)"></div>
                            </div>
                        </div>
                    </div>
                    

                    
                    <!-- Add Expense -->
                    <div class="card expense-input" id="expenseInput" style="display: none;">
                        <h3 class="card-title mb-4" id="expenseInputTitle">Add Expense</h3>
                        
                        <!-- Date picker for month mode -->
                        <div class="form-group" id="datePickerGroup" style="display: none;">
                            <label class="form-label" for="expenseDate">Date</label>
                            <input type="date" id="expenseDate" class="form-input">
                        </div>
                        <div class="input-row">
                            <div class="form-group">
                                <label class="form-label" for="expenseAmount">Amount ($)</label>
                                <input type="number" id="expenseAmount" class="form-input" placeholder="0.00" step="0.01">
                            </div>
                            <div class="form-group">
                                <label class="form-label" for="expenseCategory">Category</label>
                                <select id="expenseCategory" class="form-input">
                                    <option value="groceries">Groceries</option>
                                    <option value="transportation">Transportation</option>
                                    <option value="dining">Dining Out</option>
                                    <option value="entertainment">Entertainment</option>
                                    <option value="personal">Personal Care</option>
                                    <option value="clothing">Clothing</option>
                                    <option value="health">Health/Fitness</option>
                                    <option value="subscriptions">Subscriptions</option>
                                    <option value="other">Other</option>
                                </select>
                            </div>
                        </div>
                        
                        <div class="form-group">
                            <label class="form-label" for="expenseDescription">Description (optional)</label>
                            <input type="text" id="expenseDescription" class="form-input" placeholder="What did you buy?">
                        </div>
                        
                        <button class="add-btn" onclick="addExpense()">Add Expense</button>
                    </div>
                    
                    <!-- Sticky Container -->
                    <div class="sticky-container">
                        <!-- Sticky Controls Section -->
                        <div class="sticky-controls-section" id="stickyControlsSection">
                            <div class="sticky-controls-content">
                                <div class="section-header-left">
                                    <h3 class="section-title" id="expensesListTitle">Transactions</h3>
                                    <div id="budgetTitleContainer"></div>
                                </div>
                                <div class="section-header-right">
                                    <div id="timeRangeContextMenu"></div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Period Expenses -->
                        <div class="expenses-list-card">
                            <div class="expenses-list" id="expensesList">
                                <div style="text-align: center; color: #7f8c8d; padding: 20px;">
                                    No transactions recorded this week
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Savings Accounts Section - Moved to Save Screen -->
                    <!-- <div class="card savings-accounts-section" id="savingsSection" style="display: none;">
                        <div class="section-header">
                            <h3 class="text-lg font-semibold">Account Balances</h3>
                            <button class="btn btn-outline btn-sm" onclick="showAccountManagementModal()">
                                <i data-lucide="settings" class="w-4 h-4 mr-2"></i>
                                Accounts
                            </button>
                        </div>
                        
                        <div class="account-balance-display stat-card">
                            <div class="current-balance" id="totalAccountBalance">$0.00</div>
                            <div class="balance-change" id="totalBalanceChange">Total across all accounts this month</div>
                        </div>
                        
                        <div class="balance-history" id="balanceHistory">
                            <div style="text-align: center; color: #7f8c8d; padding: 20px;">
                                No balance records this month
                            </div>
                        </div>
                    </div> -->
                    
                </div>
                
                <!-- Screen 2: Accounts (formerly Save) -->
                <div class="screen">
                    
                    
                    <!-- Sticky Period Selector for Save Screen -->
                    <div class="period-selector-sticky" id="savePeriodSelectorSticky" style="display: none;">
                        <!-- Period Selector Header with Toggle on Left, Dropdowns on Right -->
                        <div class="period-selector-header">
                            <div class="card-header" style="flex-direction: row; align-items: center; justify-content: space-between; padding-bottom: 0;">
                                <div class="period-title">July 2025</div>
                                
                                <!-- Icon-only Today/Month Toggle - Only this is included -->
                                <div class="period-icon-toggle">
                                    <button onclick="setSavePeriodMode('today')" class="period-icon-btn active" id="saveTodayBtnIcon" title="Today View">
                                        <i data-lucide="sun" class="w-4 h-4"></i>
                                    </button>
                                    <button onclick="setSavePeriodMode('month')" class="period-icon-btn" id="saveMonthBtnIcon" title="Month View">
                                        <i data-lucide="calendar" class="w-4 h-4"></i>
                                    </button>
                                </div>
                            </div>
                            
                            <!-- Original Toggle (Hidden) -->
                            <div class="period-mode-toggle-compact" style="display: none;">
                                <button onclick="setSavePeriodMode('today')" class="btn btn-ghost btn-sm period-mode-btn-compact active" id="saveTodayBtnCompact" title="Today View">
                                    <i data-lucide="sun" class="w-4 h-4 mr-2"></i>
                                    <span>Today</span>
                                </button>
                                <button onclick="setSavePeriodMode('month')" class="btn btn-ghost btn-sm period-mode-btn-compact" id="saveMonthBtnCompact" title="Month View">
                                    <i data-lucide="calendar" class="w-4 h-4 mr-2"></i>
                                    <span>Month</span>
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Daily/Monthly Saving Target Display -->
                    <div class="card" id="saveTargetDisplay" style="display: none;">
                        <div class="card-header" style="text-align:center;">
                            <div id="saveTargetTitleContainer" style="text-align:left;"></div>
                        </div>
                        <div class="card-content">
                            <div class="stat-card saving-target-card">
                                <div>
                                    <div class="text-sm text-muted-foreground">Saving Target</div>
                                    <div class="text-2xl font-semibold" id="saveTargetAmount">$144.43</div>
                                    <div class="change-indicator" id="saveTargetChange">
                                        <span class="change-arrow"></span>
                                        <span class="change-amount">Monthly</span>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="stat-card save-progress-card">
                                <div>
                                    <div class="text-sm text-muted-foreground" id="saveProgressLabel">Progress This Month</div>
                                    <div class="text-2xl font-semibold" id="saveProgressAmount">$0.00</div>
                                    <div class="change-indicator" id="saveProgressChange">
                                        <span class="change-arrow"></span>
                                        <span class="change-amount">On Track</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    
                    <!-- Savings Accounts Section -->
                    <div class="savings-accounts-section" id="saveSavingsSection">
                        <!-- Net Worth Chart -->
                        <div class="card home-section" onclick="handleAccountsNetWorthCardClick(event)">
                            <div class="card-header home-section-header">
                                <div class="section-header-left">
                                    <h3 class="section-title" id="accountsNetWorthTitle">$85,000 net worth</h3>
                                    <div class="section-change" id="accountsNetWorthChange">
                                        <i data-lucide="arrow-up" class="w-4 h-4 inline"></i>
                                        <span>$210.32 (0.3%)</span>
                                    </div>
                                    <div class="section-subtitle" id="accountsNetWorthSubtitle">All time</div>
                                </div>
                                <div class="section-header-right">
                                    <div class="cashflow-menu-container">
                                        <button class="dot-menu-btn" onclick="toggleAccountsNetWorthDropdown()" id="accountsNetWorthMenuBtn">
                                            <i data-lucide="more-horizontal" class="w-5 h-5"></i>
                                        </button>
                                        <div class="dropdown-menu dropdown-right" id="accountsNetWorthDropdown">
                                            <div class="dropdown-header">Select date range</div>
                                            <div class="dropdown-item" onclick="updateAccountsNetWorthRange('1m', event)">1 month</div>
                                            <div class="dropdown-item" onclick="updateAccountsNetWorthRange('3m', event)">3 months</div>
                                            <div class="dropdown-item" onclick="updateAccountsNetWorthRange('6m', event)">6 months</div>
                                            <div class="dropdown-item" onclick="updateAccountsNetWorthRange('ytd', event)">Year to date</div>
                                            <div class="dropdown-item" onclick="updateAccountsNetWorthRange('1y', event)">1 year</div>
                                            <div class="dropdown-item active" onclick="updateAccountsNetWorthRange('all', event)">All time</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="card-content">
                                <div class="chart-container full-width-chart" style="position: relative; height: 200px;">
                                    <canvas id="accountsNetWorthCanvas"></canvas>
                                    <div class="chart-overlay" id="accountsNetWorthOverlay">
                                        <div class="chart-crosshair" id="accountsNetWorthCrosshair"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <!-- Accounts Header -->
                        <div class="account-header-section">
                            <div class="account-title-info">
                                <h3 class="section-title" style="margin-bottom: 0.25rem;">Accounts</h3>
                            </div>
                        </div>
                        
                        <!-- Account Action Pills -->
                        <div class="account-action-pills">
                            <button class="account-pill-btn bold" onclick="connectPlaidAccount()">
                                <span>Connect</span>
                            </button>
                            <button class="account-pill-btn" onclick="showAccountManagementModal()">
                                <span>Manage</span>
                            </button>
                            <button class="account-pill-btn" onclick="showBalanceSlideOut()">
                                <span>Add Balance</span>
                            </button>
                        </div>
                        
                        <!-- New Accounts List -->
                        <div class="accounts-list" id="accountsListLoading" style="display: none;">
                          <!-- Skeleton placeholder rows -->
                          <div class="account-skeleton-row" style="display: flex; align-items: center; gap: 1rem; padding: 0.6rem 0;">
                            <div class="skeleton-icon" style="width: 40px; height: 40px; border-radius: 50%; background: #f3f4f6;"></div>
                            <div style="flex: 1;">
                              <div class="skeleton-line" style="width: 60%; height: 14px; border-radius: 7px; background: #f3f4f6; margin-bottom: 0.35rem;"></div>
                              <div class="skeleton-line" style="width: 40%; height: 12px; border-radius: 6px; background: #f3f4f6;"></div>
                            </div>
                            <div class="skeleton-amount" style="width: 60px; height: 16px; border-radius: 8px; background: #f3f4f6;"></div>
                          </div>
                          <div class="account-skeleton-row" style="display: flex; align-items: center; gap: 1rem; padding: 0.6rem 0;">
                            <div class="skeleton-icon" style="width: 40px; height: 40px; border-radius: 50%; background: #f3f4f6;"></div>
                            <div style="flex: 1;">
                              <div class="skeleton-line" style="width: 50%; height: 14px; border-radius: 7px; background: #f3f4f6; margin-bottom: 0.35rem;"></div>
                              <div class="skeleton-line" style="width: 30%; height: 12px; border-radius: 6px; background: #f3f4f6;"></div>
                            </div>
                            <div class="skeleton-amount" style="width: 50px; height: 16px; border-radius: 8px; background: #f3f4f6;"></div>
                          </div>
                          <div class="account-skeleton-row" style="display: flex; align-items: center; gap: 1rem; padding: 0.6rem 0;">
                            <div class="skeleton-icon" style="width: 40px; height: 40px; border-radius: 50%; background: #f3f4f6;"></div>
                            <div style="flex: 1;">
                              <div class="skeleton-line" style="width: 55%; height: 14px; border-radius: 7px; background: #f3f4f6; margin-bottom: 0.35rem;"></div>
                              <div class="skeleton-line" style="width: 35%; height: 12px; border-radius: 6px; background: #f3f4f6;"></div>
                            </div>
                            <div class="skeleton-amount" style="width: 55px; height: 16px; border-radius: 8px; background: #f3f4f6;"></div>
                          </div>
                        </div>
                        <div class="accounts-list" id="accountsList">
                            <!-- Account groups will be dynamically populated here -->
                        </div>
    <style>
    /* .accounts-list and .account-row styles are already present above or in the main style block. Remove duplicates. */
    /* Skeleton loading animation */
    .account-skeleton-row {
      margin: 0.2rem 1rem;
      border-radius: 1rem;
      background: none;
      display: flex;
      align-items: center;
      gap: 1rem;
      padding: 0.6rem 1rem;
    }
    .account-skeleton-row .skeleton-icon,
    .account-skeleton-row .skeleton-line,
    .account-skeleton-row .skeleton-amount {
      animation: skeleton-loading 1.2s infinite linear alternate;
      background-color: #f3f4f6;
      border-radius: 0.5rem;
    }
    .account-skeleton-row .skeleton-icon {
      width: 2.5rem;
      height: 2.5rem;
      margin-right: 1rem;
    }
    .account-skeleton-row .skeleton-line {
      height: 1.1rem;
      width: 40%;
      margin-bottom: 0.35rem;
    }
    .account-skeleton-row .skeleton-amount {
      height: 1.1rem;
      width: 20%;
      margin-left: auto;
    }
    @keyframes skeleton-loading {
      0% { background-color: #f6f5f3; }
      100% { background-color: #dad7d0; }
    }

    /* Transaction skeleton styles */
    .transaction-skeleton-row {
      display: flex;
      align-items: center;
      gap: 1rem;
      padding: 0.8rem 0;
      margin: 0 1rem;
      border-bottom: 1px solid #f0f0f0;
    }
    .transaction-skeleton-row .skeleton-icon,
    .transaction-skeleton-row .skeleton-line,
    .transaction-skeleton-row .skeleton-amount {
      animation: skeleton-loading 1.2s infinite linear alternate;
      background-color: #f3f4f6;
    }
    .transaction-skeleton-row .skeleton-icon {
      width: 32px;
      height: 32px;
      border-radius: 6px;
    }
    .transaction-skeleton-row .skeleton-line {
      border-radius: 6px;
    }
    .transaction-skeleton-row .skeleton-amount {
      border-radius: 8px;
      height: 16px;
    }

    /* Skeleton fade animations */
    .skeleton-fade-in {
      opacity: 0;
      animation: skeletonFadeIn 0.3s ease-out forwards;
    }
    .skeleton-fade-out {
      opacity: 1;
      animation: skeletonFadeOut 0.2s ease-in forwards;
    }
    @keyframes skeletonFadeIn {
      to { opacity: 1; }
    }
    @keyframes skeletonFadeOut {
      to { opacity: 0; }
    }

    /* Modern Sliding Loading Bar */
    .global-loading-bar {
      position: fixed;
      top: 40px; /* Just below the header */
      left: 50%;
      transform: translateX(-50%);
      width: 60%;
      height: 6px;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: opacity 0.3s ease, visibility 0.3s ease;
      pointer-events: none;
    }

    .global-loading-bar.show {
      opacity: 1;
      visibility: visible;
    }

    .loading-bar-track {
      width: 100%;
      height: 100%;
      background: rgba(139, 92, 246, 0.1);
      border-radius: 10px;
      overflow: hidden;
      position: relative;
    }

    .loading-bar-fill {
      height: 100%;
      background: linear-gradient(90deg, 
        rgba(139, 92, 246, 0.8) 0%, 
        rgba(139, 92, 246, 1) 50%, 
        rgba(139, 92, 246, 0.8) 100%);
      border-radius: 2px;
      position: absolute;
      top: 0;
      left: 0;
      width: 30%;
      animation: slideExpand 2s ease-in-out infinite;
      box-shadow: 0 0 8px rgba(139, 92, 246, 0.4);
    }

    @keyframes slideExpand {
      0% {
        left: -30%;
        width: 30%;
      }
      50% {
        left: 50%;
        width: 50%;
      }
      100% {
        left: 100%;
        width: 30%;
      }
    }


    .fade-in {
      opacity: 0;
      animation: fadeIn 0.5s ease-in forwards;
    }
    @keyframes fadeIn {
      to { opacity: 1; }
    }
    </style>
    
                    </div>
                    
                </div>
                
                <!-- Screen 3: Dashboard (formerly Reports) -->
                <div class="screen">
                    <!-- Weekly Summary -->
                    <div class="card weekly-summary">
                        <h3>This Week's Financial Health</h3>
                        <div class="combined-stats">
                            <div class="combined-stat">
                                <div class="combined-stat-value" id="weeklySpent">$0</div>
                                <div class="combined-stat-label">Spent</div>
                            </div>
                            <div class="stat-separator"></div>
                            <div class="combined-stat">
                                <div class="combined-stat-value" id="weeklyRemaining">$286</div>
                                <div class="combined-stat-label">Remaining</div>
                            </div>
                        </div>
                        <div class="weekly-stats" style="margin-top: 20px;">
                            <div class="weekly-stat">
                                <div class="weekly-stat-value" id="projectedMonthlySavings">$0</div>
                                <div class="weekly-stat-label">Projected Savings</div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Monthly Stats -->
                    <div class="stats-grid">
                        <div class="card stat-card">
                            <div class="stat-label" id="monthSpentLabel">July Spent</div>
                            <div class="stat-value" id="monthlySpent">$0</div>
                            <div class="stat-subtitle" id="monthSpentSubtitle">of $1,239 budget</div>
                        </div>
                        <div class="card stat-card">
                            <div class="stat-label">Daily Burn Rate</div>
                            <div class="stat-value" id="dailyBurnRate">$0</div>
                            <div class="stat-subtitle" id="burnRateStatus">vs $41.30 target</div>
                        </div>
                        <div class="card stat-card">
                            <div class="stat-label">Days Left in Budget</div>
                            <div class="stat-value" id="daysRemaining">--</div>
                            <div class="stat-subtitle" id="daysRemainingSubtitle">at current pace</div>
                        </div>
                        <div class="card stat-card">
                            <div class="stat-label">Savings Rate</div>
                            <div class="stat-value positive" id="savingsRate">--%</div>
                            <div class="stat-subtitle" id="savingsRateSubtitle">of income saved</div>
                        </div>
                    </div>
                    
                    <!-- Wealthsimple-Style Chart -->
                    <div class="chart-container-wrapper">
                        <!-- Chart Header with Two Rows: Savings and Spending -->
                        <div class="chart-header">
                             <!-- Date display that shows when chart is interacted with -->
                            <div class="chart-date-display" id="chartDateDisplay">
                                <span class="chart-selected-date">July 6, 2025</span>
                            </div>
                            <!-- Savings Row (Black) -->
                            <div class="chart-row savings-row">
                                <div class="chart-subtitle" id="chartSubtitle">Saved</div>
                                <div class="chart-main-value" id="chartMainValue">$0.00</div>
                                <div class="chart-growth" id="chartGrowth">+$0.00 (+0%)</div>
                            </div>
                            
                            <!-- Spending Row (Gray) -->
                            <div class="chart-row spending-row">
                                <div class="chart-subtitle spending" id="chartSpendingSubtitle">Spent</div>
                                <div class="chart-main-value spending" id="chartSpendingValue">$0.00</div>
                            </div>
                        </div>
                        
                        <!-- Chart Carousel Container -->
                        <div class="chart-carousel-container">
                            <div class="chart-carousel" id="chartCarousel">
                                <!-- Chart with Overlay -->
                                <div class="chart-slide active" id="spendingChartSlide">
                                    <div class="card chart-container full-width-chart">
                                        <canvas id="spendingChart"></canvas>
                                        <div class="chart-overlay" id="chartOverlay">
                                            <div class="chart-crosshair" id="chartCrosshair"></div>
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- Category Spending Chart -->
                                <div class="chart-slide" id="categoryChartSlide">
                                    <div class="card chart-container chart-with-header full-width-chart">
                                        <div class="chart-header">
                                            <h3>Top Categories</h3>
                                            <div class="chart-time-range" id="categoryChartTimeRange"></div>
                                        </div>
                                        <div class="chart-canvas-wrapper">
                                            <canvas id="categoryChart"></canvas>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Chart Navigation Dots -->
                            <div class="chart-dots" id="chartDots">
                                <div class="dot active" onclick="showChart(0)"></div>
                                <div class="dot" onclick="showChart(1)"></div>
                            </div>
                        </div>
                        
                        <!-- Chart Period Selector at Bottom -->
                        <div class="chart-period-selector-bottom">
                            <button class="chart-period-btn-wealthsimple" onclick="setChartPeriod('1M')" id="period1M">1M</button>
                            <button class="chart-period-btn-wealthsimple" onclick="setChartPeriod('3M')" id="period3M">3M</button>
                            <button class="chart-period-btn-wealthsimple" onclick="setChartPeriod('6M')" id="period6M">6M</button>
                            <button class="chart-period-btn-wealthsimple active" onclick="setChartPeriod('YTD')" id="periodYTD">YTD</button>
                            <button class="chart-period-btn-wealthsimple" onclick="setChartPeriod('1Y')" id="period1Y">1Y</button>
                            <button class="chart-period-btn-wealthsimple" onclick="setChartPeriod('ALL')" id="periodALL">ALL</button>
                        </div>
                    </div>
                </div>
                

            </div>
        </div>
        
        
        <div class="bottom-nav">
            <div class="nav-item active" onclick="goToScreen(0)">
                <div class="icon">
                    <i data-lucide="home" class="w-6 h-6"></i>
                </div>
                <div class="label">Home</div>
            </div>
            <div class="nav-item" onclick="goToScreen(1)">
                <div class="icon">
                    <i data-lucide="trending-up" class="w-6 h-6"></i>
                </div>
                <div class="label">Cashflow</div>
            </div>
            <div class="nav-item" onclick="goToScreen(2)">
                <div class="icon">
                    <i data-lucide="wallet" class="w-6 h-6"></i>
                </div>
                <div class="label">Accounts</div>
            </div>
            <div class="nav-item" onclick="goToScreen(3)">
                <div class="icon">
                    <i data-lucide="bar-chart-3" class="w-6 h-6"></i>
                </div>
                <div class="label">Dashboard</div>
            </div>
        </div>
    </div>

    <!-- Account Detail Screen -->
    <div class="account-detail-overlay" id="accountDetailOverlay">
        <div class="account-detail-screen" id="accountDetailScreen">
            <!-- Header with back button -->
            <div class="account-detail-header">
                <button class="account-detail-back" onclick="closeAccountDetail()" aria-label="Back">
                    <i data-lucide="arrow-left" class="w-6 h-6"></i>
                </button>
                <div class="account-detail-title-container">
                    <h2 class="account-detail-title" id="accountDetailTitle">Account Name</h2>
                    <div class="account-detail-balance" id="accountDetailBalance">$0.00</div>
                </div>
            </div>

            <!-- Account Balance Chart -->
            <div class="card account-detail-chart-card">
                <div class="card-content">
                    <div class="chart-container" style="position: relative; height: 200px;">
                        <canvas id="accountDetailCanvas"></canvas>
                        <div class="chart-overlay" id="accountDetailChartOverlay">
                            <div class="chart-crosshair" id="accountDetailCrosshair"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Activity Section -->
            <div class="account-detail-activity">
                <div class="card-header">
                    <div class="section-header">
                        <div class="section-header-left">
                            <h3 class="section-title">Activity</h3>
                            <div class="section-subtitle" id="accountDetailActivitySubtitle">This month</div>
                        </div>
                        <div class="section-header-right">
                            <div class="cashflow-menu-container">
                                <button class="dot-menu-btn" onclick="toggleAccountDetailTimeRange()" id="accountDetailTimeRangeBtn">
                                    <i data-lucide="more-horizontal" class="w-5 h-5"></i>
                                </button>
                                <div class="dropdown-menu dropdown-right" id="accountDetailTimeRangeDropdown">
                                    <div class="dropdown-header">Select time range</div>
                                    <div class="dropdown-item" onclick="updateAccountDetailTimeRange('week', event)">This week</div>
                                    <div class="dropdown-item active" onclick="updateAccountDetailTimeRange('month', event)">This month</div>
                                    <div class="dropdown-item" onclick="updateAccountDetailTimeRange('quarter', event)">This quarter</div>
                                    <div class="dropdown-item" onclick="updateAccountDetailTimeRange('year', event)">This year</div>
                                    <div class="dropdown-item" onclick="updateAccountDetailTimeRange('all', event)">All time</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Transaction List -->
            <div class="account-detail-transactions">
                <div class="expenses-list" id="accountDetailTransactionsList">
                    <div style="text-align: center; color: #7f8c8d; padding: 20px;">
                        No transactions found
                    </div>
                </div>
            </div>
        </div>
    </div>

     <!-- Settings Slide-out Panel -->
     <div class="settings-overlay" id="settingsOverlay">
        <div class="settings-panel" id="settingsPanel">
            <div class="settings-header">
                <button class="settings-back" onclick="closeSettings()" aria-label="Back">
                    <i data-lucide="arrow-left" class="w-6 h-6"></i>
                </button>
                <h2 class="settings-title">Settings</h2>
                <div style="width: 40px;"></div> <!-- Spacer for centering -->
            </div>

            <div class="settings-content" id="settingsMenu">
                <ul class="settings-menu-list">
                    <li class="settings-menu-item" onclick="openBudgetSetup()">
                      <span class="settings-menu-icon"><i data-lucide="wallet" class="w-5 h-5"></i></span>
                      <span class="settings-menu-label">Setup Budget</span>
                      <span class="settings-menu-arrow"><i data-lucide="chevron-right" class="w-5 h-5"></i></span>
                    </li>
                    <li class="settings-menu-item" onclick="openSupport()">
                        <span class="settings-menu-icon"><i data-lucide="headphones" class="w-5 h-5"></i></span>
                        <span class="settings-menu-label">Support</span>
                        <span class="settings-menu-arrow"><i data-lucide="chevron-right" class="w-5 h-5"></i></span>
                    </li>
                    <li class="settings-menu-item" onclick="loadSampleBudget()">
                        <span class="settings-menu-icon"><i data-lucide="database" class="w-5 h-5"></i></span>
                        <span class="settings-menu-label">Load Sample Data</span>
                        <span class="settings-menu-arrow"></span>
                    </li>
                    <li class="settings-menu-item" onclick="clearAllData()">
                        <span class="settings-menu-icon"><i data-lucide="trash-2" class="w-5 h-5"></i></span>
                        <span class="settings-menu-label">Clear All Data</span>
                        <span class="settings-menu-arrow"></span>
                    </li>
                  </ul>
            </div>
            <div class="settings-content" id="settingsForm" style="display:none;">
                <p class="text-center text-muted-foreground">Budget setup has been moved to its own page. Click "Setup Budget" to access it.</p>
            </div>

        </div>
    </div>
    
    <!-- Budget Flow Slide-out -->
    <div class="settings-overlay" id="budgetOverlay">
        <div class="budget-panel" id="budgetPanel">
            <div class="settings-header">
                <button class="settings-back" onclick="closeBudgetFlow()" aria-label="Back">
                    <i data-lucide="arrow-left" class="w-6 h-6"></i>
                </button>
                <h2 class="settings-title" id="budgetFlowTitle">Budget Setup</h2>
                <div style="width: 40px;"></div> <!-- Spacer for centering -->
            </div>
            
            <!-- Progress Indicator -->
            <div class="budget-progress-indicator">
                <div class="progress-dots">
                    <div class="progress-dot active" data-step="1"></div>
                    <div class="progress-dot" data-step="2"></div>
                    <div class="progress-dot" data-step="3"></div>
                    <div class="progress-dot" data-step="4"></div>
                    <div class="progress-dot" data-step="5"></div>
                    <div class="progress-dot" data-step="6"></div>
                </div>
                <div class="progress-label" id="budgetProgressLabel">Step 1 of 6: Income & Taxes</div>
            </div>

            <div class="settings-content">
                <!-- Budget Flow Screens -->
                <div class="budget-flow-screens">
                    <!-- Screen 1: Income & Taxes -->
                    <div class="budget-flow-screen active" id="budgetScreen1">
                        <div class="budget-screen-content">
                            <div class="budget-step-header">
                                <div class="budget-step-icon">
                                    <i data-lucide="dollar-sign" class="w-5 h-5"></i>
                                </div>
                                <div class="budget-step-content">
                                    <h3>Income & Taxes</h3>
                                    <p class="budget-step-description">Tell us about your income to calculate your take-home pay</p>
                                </div>
                            </div>
                        
                            <div class="budget-content-section">
                                <!-- Tax Calculator Section -->
                                <div class="tax-calculator-section">
                            <div class="tax-calculator-header">
                                <h4 class="text-md font-semibold mb-3">Tax Calculator</h4>
                                <p class="text-sm text-muted-foreground mb-4">Enter your gross yearly income and province to auto-calculate taxes (2024 rates)</p>
                            </div>
                            
                            <div class="tax-calculator-inputs">
                                <div class="form-group">
                                    <label class="form-label" for="budgetGrossYearlyIncome">Gross Yearly Income</label>
                                    <input type="number" class="form-input" id="budgetGrossYearlyIncome" placeholder="140000" min="0" step="1000">
                                </div>
                                
                                <div class="form-group">
                                    <label class="form-label" for="budgetProvinceSelect">Province/Territory</label>
                                    <div class="select-container">
                                        <div class="select-trigger" onclick="toggleSlideOutSelect('budgetProvince')" id="budgetProvinceTrigger">
                                            <span id="budgetProvinceValue">Ontario</span>
                                            <i data-lucide="chevron-down" class="w-4 h-4"></i>
                                        </div>
                                        <div class="select-content" id="budgetProvinceContent">
                                            <div class="select-item selected" data-value="ON">Ontario</div>
                                            <div class="select-item" data-value="BC">British Columbia</div>
                                            <div class="select-item" data-value="AB">Alberta</div>
                                            <div class="select-item" data-value="SK">Saskatchewan</div>
                                            <div class="select-item" data-value="MB">Manitoba</div>
                                            <div class="select-item" data-value="QC">Quebec</div>
                                            <div class="select-item" data-value="NB">New Brunswick</div>
                                            <div class="select-item" data-value="NS">Nova Scotia</div>
                                            <div class="select-item" data-value="PE">Prince Edward Island</div>
                                            <div class="select-item" data-value="NL">Newfoundland and Labrador</div>
                                            <div class="select-item" data-value="NT">Northwest Territories</div>
                                            <div class="select-item" data-value="NU">Nunavut</div>
                                            <div class="select-item" data-value="YT">Yukon</div>
                                        </div>
                                    </div>
                                </div>
                                
                                <button type="button" class="calculate-btn" onclick="calculateBudgetTaxes()">Calculate Taxes</button>
                            </div>
                            
                            <!-- Manual Override Section -->
                            <div class="manual-override-section">
                                <div class="accordion-header" onclick="toggleAccordion('budgetManualOverride')">
                                    <h4 class="text-md font-semibold">Manual Override (Optional)</h4>
                                    <i data-lucide="chevron-down" class="accordion-icon" id="budgetManualOverrideIcon"></i>
                                </div>
                                <div class="accordion-content" id="budgetManualOverrideContent">
                                    <p class="text-sm text-muted-foreground mb-4">You can manually adjust the calculated values below if needed</p>
                                    
                                    <div class="form-group">
                                        <label class="form-label" for="budgetGrossIncome">Gross Monthly Income</label>
                                        <input type="number" class="form-input" id="budgetGrossIncome" placeholder="11667" min="0" step="0.01">
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label" for="budgetFederalTax">Federal Tax</label>
                                        <input type="number" class="form-input" id="budgetFederalTax" placeholder="2500" min="0" step="0.01">
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label" for="budgetProvincialTax">Provincial Tax</label>
                                        <input type="number" class="form-input" id="budgetProvincialTax" placeholder="750" min="0" step="0.01">
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label" for="budgetCppEi">CPP/EI</label>
                                        <input type="number" class="form-input" id="budgetCppEi" placeholder="333" min="0" step="0.01">
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label" for="budgetNetIncome">Net Monthly Income</label>
                                        <input type="number" class="form-input" id="budgetNetIncome" placeholder="8084" min="0" step="0.01">
                                        <div class="form-help">Auto-calculated, but you can override if needed.</div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="form-divider"></div>
                            
                            <div class="tax-results" id="budgetTaxResults" style="display: none;">
                                <div class="tax-summary">
                                    <div class="tax-item">
                                        <div class="tax-label">Monthly Gross Income</div>
                                        <div class="tax-value" id="budgetMonthlyGrossResult">$0.00</div>
                                    </div>
                                    <div class="tax-item">
                                        <div class="tax-label">Federal Tax (Monthly)</div>
                                        <div class="tax-value" id="budgetFederalTaxResult">$0.00</div>
                                    </div>
                                    <div class="tax-item">
                                        <div class="tax-label">Provincial Tax (Monthly)</div>
                                        <div class="tax-value" id="budgetProvincialTaxResult">$0.00</div>
                                    </div>
                                    <div class="tax-item">
                                        <div class="tax-label">CPP/EI (Monthly)</div>
                                        <div class="tax-value" id="budgetCppEiResult">$0.00</div>
                                    </div>
                                    <div class="tax-item total">
                                        <div class="tax-label">Net Monthly Income</div>
                                        <div class="tax-value" id="budgetNetIncomeResult">$0.00</div>
                                    </div>
                                </div>
                                </div>
                                </div>
                            </div>
                            
                            <!-- Interactive Income Visualization -->
                            <div class="interactive-chart-container" id="incomeVisualization" style="display: none;">
                                <div class="chart-title">
                                    <i data-lucide="pie-chart" class="w-4 h-4"></i>
                                    Income Breakdown
                                </div>
                                <canvas id="incomeBreakdownChart" width="300" height="150"></canvas>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Screen 2: Savings Goals -->
                    <div class="budget-flow-screen" id="budgetScreen2">
                        <div class="budget-screen-content">
                            <div class="budget-step-header">
                                <div class="budget-step-icon">
                                    <i data-lucide="piggy-bank" class="w-5 h-5"></i>
                                </div>
                                <div class="budget-step-content">
                                    <h3>Savings Goals</h3>
                                    <p class="budget-step-description">Set your savings target to build your future</p>
                                </div>
                            </div>
                            
                            <div class="budget-content-section">
                                <div class="form-group">
                                    <label class="form-label" for="budgetAnnualSavingsGoal">Annual Savings Goal</label>
                                    <input type="number" class="form-input" id="budgetAnnualSavingsGoal" placeholder="52000" min="0" step="100" oninput="updateSavingsVisualization()">
                                    <div class="form-help">How much do you want to save per year?</div>
                                </div>
                                <div class="form-group">
                                    <label class="form-label" for="budgetMonthlySavingsTarget">Monthly Savings Target</label>
                                    <input type="number" class="form-input" id="budgetMonthlySavingsTarget" placeholder="4333" min="0" step="0.01" readonly>
                                    <div class="form-help">Auto-calculated from annual savings goal.</div>
                                </div>
                                
                                <!-- Savings Rate Display -->
                                <div class="interactive-chart-container" id="savingsVisualization" style="display: none;">
                                    <div class="chart-title">
                                        <i data-lucide="trending-up" class="w-4 h-4"></i>
                                        Savings Rate
                                    </div>
                                    <div class="savings-rate-display" id="savingsRateDisplay">0%</div>
                                        <div class="text-center text-sm text-muted-foreground" id="savingsRateDescription">of your net income</div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Screen 3: Fixed Expenses -->
                    <div class="budget-flow-screen" id="budgetScreen3">
                        <div class="budget-screen-content">
                            <div class="budget-step-header">
                                <div class="budget-step-icon">
                                    <i data-lucide="home" class="w-5 h-5"></i>
                                </div>
                                <div class="budget-step-content">
                                    <h3>Fixed Expenses</h3>
                                    <p class="budget-step-description">Regular expenses that stay the same each month</p>
                                </div>
                            </div>
                            
                            <div class="budget-content-section">
                                <div class="form-group">
                                    <label class="form-label" for="budgetFixedExpenses">Monthly Fixed Expenses</label>
                                    <input type="number" class="form-input" id="budgetFixedExpenses" placeholder="2450" min="0" step="0.01" oninput="updateFixedExpenseVisualization()">
                                    <div class="form-help">Rent, insurance, loan payments, subscriptions</div>
                                </div>
                                
                                <!-- Fixed Expenses Percentage Display -->
                                <div class="interactive-chart-container" id="fixedExpenseVisualization" style="display: none;">
                                    <div class="chart-title">
                                        <i data-lucide="home" class="w-4 h-4"></i>
                                        Fixed Expenses Rate
                                    </div>
                                    <div class="savings-rate-display" id="fixedExpenseRateDisplay">0%</div>
                                    <div class="text-center text-sm text-muted-foreground" id="fixedExpenseRateDescription">of your net income</div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Screen 4: Essential Expenses -->
                    <div class="budget-flow-screen" id="budgetScreen4">
                        <div class="budget-screen-content">
                            <div class="budget-step-header">
                                <div class="budget-step-icon">
                                    <i data-lucide="shopping-cart" class="w-5 h-5"></i>
                                </div>
                                <div class="budget-step-content">
                                    <h3>Essential Expenses</h3>
                                    <p class="budget-step-description">Necessary expenses that can vary month to month</p>
                                </div>
                            </div>
                            
                            <div class="budget-content-section">
                                <div class="form-group">
                                    <label class="form-label" for="budgetEssentialExpenses">Monthly Essential Expenses</label>
                                    <input type="number" class="form-input" id="budgetEssentialExpenses" placeholder="750" min="0" step="0.01" oninput="updateEssentialExpenseVisualization()">
                                    <div class="form-help">Groceries, utilities, gas, phone, internet</div>
                                </div>
                                
                                <!-- Essential Expenses Percentage Display -->
                                <div class="interactive-chart-container" id="essentialExpenseVisualization" style="display: none;">
                                    <div class="chart-title">
                                        <i data-lucide="shopping-cart" class="w-4 h-4"></i>
                                        Essential Expenses Rate
                                    </div>
                                    <div class="savings-rate-display" id="essentialExpenseRateDisplay">0%</div>
                                    <div class="text-center text-sm text-muted-foreground" id="essentialExpenseRateDescription">of your net income</div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Screen 5: Discretionary Expenses -->
                    <div class="budget-flow-screen" id="budgetScreen5">
                        <div class="budget-screen-content">
                            <div class="budget-step-header">
                                <div class="budget-step-icon">
                                    <i data-lucide="coffee" class="w-5 h-5"></i>
                                </div>
                                <div class="budget-step-content">
                                    <h3>Discretionary Expenses</h3>
                                    <p class="budget-step-description">Fun spending and lifestyle choices</p>
                                </div>
                            </div>
                            
                            <div class="budget-content-section">
                                <div class="form-group">
                                    <label class="form-label" for="budgetDiscretionaryExpenses">Monthly Discretionary Expenses</label>
                                    <input type="number" class="form-input" id="budgetDiscretionaryExpenses" placeholder="501" min="0" step="0.01" oninput="updateDiscretionaryExpenseVisualization()">
                                    <div class="form-help">Entertainment, dining out, hobbies, shopping</div>
                                </div>
                                
                                <!-- Discretionary Expenses Percentage Display -->
                                <div class="interactive-chart-container" id="discretionaryExpenseVisualization" style="display: none;">
                                    <div class="chart-title">
                                        <i data-lucide="coffee" class="w-4 h-4"></i>
                                        Discretionary Expenses Rate
                                    </div>
                                    <div class="savings-rate-display" id="discretionaryExpenseRateDisplay">0%</div>
                                    <div class="text-center text-sm text-muted-foreground" id="discretionaryExpenseRateDescription">of your net income</div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Screen 6: Review & Summary -->
                    <div class="budget-flow-screen" id="budgetScreen6">
                        <div class="budget-screen-content">
                            <div class="budget-step-header">
                                <div class="budget-step-icon">
                                    <i data-lucide="check-circle" class="w-5 h-5"></i>
                                </div>
                                <div class="budget-step-content">
                                    <h3>Budget Summary</h3>
                                    <p class="budget-step-description">Your complete financial picture at a glance</p>
                                </div>
                            </div>
                            
                            <!-- Summary Cards Grid -->
                            <div class="summary-grid">
                                <div class="summary-card">
                                <div class="summary-card-header">
                                    <div class="summary-card-icon income-icon">
                                        <i data-lucide="dollar-sign" class="w-4 h-4"></i>
                                    </div>
                                    <h4 class="summary-card-title">Net Income</h4>
                                </div>
                                <div class="summary-card-value" id="budgetNetIncomeSummary">$0</div>
                                <div class="summary-card-chart">
                                    <canvas id="incomeChart" width="200" height="60"></canvas>
                                </div>
                            </div>
                            
                            <div class="summary-card">
                                <div class="summary-card-header">
                                    <div class="summary-card-icon expenses-icon">
                                        <i data-lucide="credit-card" class="w-4 h-4"></i>
                                    </div>
                                    <h4 class="summary-card-title">Total Expenses</h4>
                                </div>
                                <div class="summary-card-value" id="budgetTotalExpensesSummary">$0</div>
                                <div class="summary-card-chart">
                                    <canvas id="expensesChart" width="200" height="60"></canvas>
                                </div>
                            </div>
                            
                            <div class="summary-card">
                                <div class="summary-card-header">
                                    <div class="summary-card-icon savings-icon">
                                        <i data-lucide="piggy-bank" class="w-4 h-4"></i>
                                    </div>
                                    <h4 class="summary-card-title">Savings Target</h4>
                                </div>
                                <div class="summary-card-value" id="budgetMonthlySavingsSummary">$0</div>
                                <div class="summary-card-chart">
                                    <canvas id="savingsChart" width="200" height="60"></canvas>
                                </div>
                            </div>
                            
                            <div class="summary-card">
                                <div class="summary-card-header">
                                    <div class="summary-card-icon remaining-icon">
                                        <i data-lucide="wallet" class="w-4 h-4"></i>
                                    </div>
                                    <h4 class="summary-card-title">Remaining</h4>
                                </div>
                                <div class="summary-card-value" id="budgetRemainingBudgetSummary">$0</div>
                                <div class="summary-card-chart">
                                    <canvas id="remainingChart" width="200" height="60"></canvas>
                                </div>
                            </div>
                            </div>
                            
                            <!-- Main Budget Visualization -->
                            <div class="budget-content-section" style="margin-top: 1.5rem;">
                                <div class="chart-title">
                                    <i data-lucide="pie-chart" class="w-4 h-4"></i>
                                    Budget Breakdown
                                </div>
                                <canvas id="budgetSummaryChart" width="400" height="180"></canvas>
                                
                                <div style="text-align: center; margin-top: 0.75rem;">
                                    <div class="savings-rate-display" id="budgetSavingsRateSummary">0%</div>
                                    <div class="text-sm text-muted-foreground">Savings Rate</div>
                                    <div class="text-sm font-medium" id="budgetValidationSummary" style="margin-top: 0.25rem;">-</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Navigation Buttons -->
                <div class="budget-flow-navigation">
                    <button type="button" class="btn btn-secondary" id="budgetPrevBtn" onclick="previousBudgetStep()" disabled style="gap: 0.5rem; padding: 10px 16px;">
                        <i data-lucide="arrow-left" class="w-4 h-4"></i>
                        Previous
                    </button>
                    <button type="button" class="add-btn" id="budgetNextBtn" onclick="nextBudgetStep()" style="display: flex; align-items: center; gap: 0.5rem; width: auto; padding: 10px 16px;">
                        Next
                        <i data-lucide="arrow-right" class="w-4 h-4"></i>
                    </button>
                    <button type="button" class="add-btn" id="budgetSaveBtn" onclick="saveBudgetSettings()" style="display: none; align-items: center; gap: 0.5rem; width: auto; padding: 10px 16px;">
                        <i data-lucide="check" class="w-4 h-4"></i>
                        Save Budget
                    </button>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Support Page Slide-out -->
    <div class="settings-overlay" id="supportOverlay">
        <div class="budget-panel" id="supportPanel">
            <div class="settings-header">
                <button class="settings-back" onclick="closeSupport()" aria-label="Back">
                    <i data-lucide="arrow-left" class="w-6 h-6"></i>
                </button>
                <h2 class="settings-title">Support</h2>
                <div style="width: 40px;"></div> <!-- Spacer for centering -->
            </div>

            <div class="settings-content">
                <div class="card">
                    <div class="card-header">
                        <h3 class="text-lg font-semibold">Contact Us</h3>
                    </div>
                    <div class="card-content">
                        <p class="text-sm text-muted-foreground mb-4">Need help? Send us a message and we'll get back to you as soon as possible.</p>
                        
                        <div class="form-group">
                            <label class="form-label" for="supportTitle">Subject</label>
                            <input type="text" class="form-input" id="supportTitle" placeholder="Brief description of your issue">
                        </div>
                        
                        <div class="form-group">
                            <label class="form-label" for="supportDescription">Message</label>
                            <textarea class="form-input" id="supportDescription" rows="6" placeholder="Please describe your issue or question in detail..."></textarea>
                        </div>
                        
                        <button type="button" class="add-btn" onclick="sendSupportEmail()">Send Message</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Expense Slide-out -->
    <div class="slide-out-overlay" id="expenseSlideOut">
        <div class="slide-out-content">
            <div class="slide-out-header">
                <h3 class="slide-out-title">Add Expense</h3>
                <button class="slide-out-close" onclick="hideExpenseSlideOut()">
                    <i data-lucide="x" class="w-5 h-5"></i>
                </button>
            </div>
            
            <div class="slide-out-form">
                <!-- Date picker for month mode -->
                <div class="form-group" id="slideOutDatePickerGroup" style="display: none;">
                    <label class="form-label" for="slideOutExpenseDate">Date</label>
                    <div class="custom-datepicker" id="expenseCustomDatepicker">
                        <div class="datepicker-trigger" onclick="toggleDatepicker('expenseCustomDatepicker')" 
                             role="button" tabindex="0" aria-label="Select date" aria-expanded="false">
                            <span class="datepicker-value" id="expenseCustomDatepickerValue">Select date</span>
                            <i data-lucide="calendar" class="w-4 h-4"></i>
                        </div>
                        <div class="datepicker-popup" id="expenseCustomDatepickerPopup">
                            <div class="datepicker-header">
                                <button type="button" class="datepicker-nav" onclick="navigateMonth('expenseCustomDatepicker', -1)">
                                    <i data-lucide="chevron-left" class="w-4 h-4"></i>
                                </button>
                                <div class="datepicker-month-year" id="expenseCustomDatepickerMonthYear">
                                    December 2024
                                </div>
                                <button type="button" class="datepicker-nav" onclick="navigateMonth('expenseCustomDatepicker', 1)">
                                    <i data-lucide="chevron-right" class="w-4 h-4"></i>
                                </button>
                            </div>
                            <div class="datepicker-grid" id="expenseCustomDatepickerGrid">
                                <!-- Calendar grid will be populated by JavaScript -->
                            </div>
                            <div class="datepicker-footer">
                                <button type="button" class="datepicker-btn datepicker-btn-secondary" onclick="clearDate('expenseCustomDatepicker')">
                                    Clear
                                </button>
                                <button type="button" class="datepicker-btn datepicker-btn-primary" onclick="selectToday('expenseCustomDatepicker')">
                                    Today
                                </button>
                            </div>
                        </div>
                        <input type="hidden" id="slideOutExpenseDate" name="slideOutExpenseDate">
                    </div>
                </div>
                
                <!-- Amount and Category side by side -->
                <div class="input-row">
                  <div class="form-group">
                    <label class="form-label" for="slideOutExpenseAmount">Amount ($)</label>
                    <input type="number" class="form-input" id="slideOutExpenseAmount" placeholder="0.00" step="0.01">
                  </div>
                  <div class="form-group">
                    <label class="form-label" for="slideOutExpenseCategory">Category</label>
                    <div class="select-container">
                      <div class="select-trigger" onclick="toggleSlideOutSelect('expenseCategory')" id="expenseCategoryTrigger">
                        <span id="expenseCategoryValue"><i data-lucide="shopping-cart" class="w-4 h-4 inline mr-2"></i>Groceries</span>
                        <i data-lucide="chevron-down" class="w-4 h-4"></i>
                      </div>
                      <div class="select-content" id="expenseCategoryContent">
                        <div class="select-item selected" data-value="groceries"><i data-lucide="shopping-cart" class="w-4 h-4 inline mr-2"></i>Groceries</div>
                        <div class="select-item" data-value="transportation"><i data-lucide="car" class="w-4 h-4 inline mr-2"></i>Transportation</div>
                        <div class="select-item" data-value="dining"><i data-lucide="utensils" class="w-4 h-4 inline mr-2"></i>Dining Out</div>
                        <div class="select-item" data-value="entertainment"><i data-lucide="film" class="w-4 h-4 inline mr-2"></i>Entertainment</div>
                        <div class="select-item" data-value="personal"><i data-lucide="user" class="w-4 h-4 inline mr-2"></i>Personal Care</div>
                        <div class="select-item" data-value="clothing"><i data-lucide="shirt" class="w-4 h-4 inline mr-2"></i>Clothing</div>
                        <div class="select-item" data-value="health"><i data-lucide="heart-pulse" class="w-4 h-4 inline mr-2"></i>Health/Fitness</div>
                        <div class="select-item" data-value="subscriptions"><i data-lucide="tv" class="w-4 h-4 inline mr-2"></i>Subscriptions</div>
                        <div class="select-item" data-value="mortgage"><i data-lucide="home" class="w-4 h-4 inline mr-2"></i>Mortgage</div>
                        <div class="select-item" data-value="loan"><i data-lucide="dollar-sign" class="w-4 h-4 inline mr-2"></i>Loan Repayment</div>
                        <div class="select-item" data-value="garbage"><i data-lucide="trash-2" class="w-4 h-4 inline mr-2"></i>Garbage</div>
                        <div class="select-item" data-value="home improvement"><i data-lucide="hammer" class="w-4 h-4 inline mr-2"></i>Home Improvement</div>
                        <div class="select-item" data-value="insurance"><i data-lucide="umbrella" class="w-4 h-4 inline mr-2"></i>Insurance</div>
                        <div class="select-item" data-value="pets"><i data-lucide="dog" class="w-4 h-4 inline mr-2"></i>Pets</div>
                        <div class="select-item" data-value="phone"><i data-lucide="smartphone" class="w-4 h-4 inline mr-2"></i>Phone</div>
                        <div class="select-item" data-value="internet"><i data-lucide="globe" class="w-4 h-4 inline mr-2"></i>Internet & Cable</div>
                        <div class="select-item" data-value="utilities"><i data-lucide="zap" class="w-4 h-4 inline mr-2"></i>Utilities</div>
                        <div class="select-item" data-value="other"><i data-lucide="more-horizontal" class="w-4 h-4 inline mr-2"></i>Other</div>
                      </div>
                    </div>
                    <!-- Hidden native select for compatibility -->
                    <select id="slideOutExpenseCategory" style="display: none;">
                      <option value="groceries">Groceries</option>
                      <option value="transportation">Transportation</option>
                      <option value="dining">Dining Out</option>
                      <option value="entertainment">Entertainment</option>
                      <option value="personal">Personal Care</option>
                      <option value="clothing">Clothing</option>
                      <option value="health">Health/Fitness</option>
                      <option value="subscriptions">Subscriptions</option>
                      <option value="mortgage">Mortgage</option>
                      <option value="loan">Loan Repayment</option>
                      <option value="garbage">Garbage</option>
                      <option value="home improvement">Home Improvement</option>
                      <option value="insurance">Insurance</option>
                      <option value="pets">Pets</option>
                      <option value="phone">Phone</option>
                      <option value="internet">Internet & Cable</option>
                      <option value="utilities">Utilities</option>
                      <option value="other">Other</option>
                    </select>
                  </div>
                </div>
                
                <div class="form-group">
                    <label class="form-label" for="slideOutExpenseDescription">Description (optional)</label>
                    <input type="text" class="form-input" id="slideOutExpenseDescription" placeholder="What did you buy?">
                </div>
                
                <button type="button" class="add-btn" onclick="addExpenseFromSlideOut()">Add Expense</button>
            </div>
        </div>
    </div>
    
    <!-- Balance Slide-out -->
    <div class="slide-out-overlay" id="balanceSlideOut">
        <div class="slide-out-content">
            <div class="slide-out-header">
                <h3 class="slide-out-title">Record Balance</h3>
                <button class="slide-out-close" onclick="hideBalanceSlideOut()">
                    <i data-lucide="x" class="w-5 h-5"></i>
                </button>
            </div>
            
            <div class="slide-out-form">
                <!-- Date field above -->
                <div class="form-group">
                  <label class="form-label" for="slideOutBalanceDate">Date</label>
                  <div class="custom-datepicker" id="balanceCustomDatepicker">
                    <div class="datepicker-trigger" onclick="toggleDatepicker('balanceCustomDatepicker')"
                         role="button" tabindex="0" aria-label="Select date" aria-expanded="false">
                      <span class="datepicker-value" id="balanceCustomDatepickerValue">Select date</span>
                      <i data-lucide="calendar" class="w-4 h-4"></i>
                    </div>
                    <div class="datepicker-popup" id="balanceCustomDatepickerPopup">
                      <div class="datepicker-header">
                        <button type="button" class="datepicker-nav" onclick="navigateMonth('balanceCustomDatepicker', -1)">
                          <i data-lucide="chevron-left" class="w-4 h-4"></i>
                        </button>
                        <div class="datepicker-month-year" id="balanceCustomDatepickerMonthYear">
                          December 2024
                        </div>
                        <button type="button" class="datepicker-nav" onclick="navigateMonth('balanceCustomDatepicker', 1)">
                          <i data-lucide="chevron-right" class="w-4 h-4"></i>
                        </button>
                      </div>
                      <div class="datepicker-grid" id="balanceCustomDatepickerGrid">
                        <!-- Calendar grid will be populated by JavaScript -->
                      </div>
                      <div class="datepicker-footer">
                        <button type="button" class="datepicker-btn datepicker-btn-secondary" onclick="clearDate('balanceCustomDatepicker')">
                          Clear
                        </button>
                        <button type="button" class="datepicker-btn datepicker-btn-primary" onclick="selectToday('balanceCustomDatepicker')">
                          Today
                        </button>
                      </div>
                    </div>
                    <input type="hidden" id="slideOutBalanceDate" name="slideOutBalanceDate">
                  </div>
                </div>
                <!-- Account and Balance side by side -->
                <div class="input-row">
                  <div class="form-group">
                    <label class="form-label" for="slideOutBalanceAccount">Account</label>
                    <div class="select-container">
                      <div class="select-trigger" onclick="toggleSlideOutSelect('balanceAccount')" id="balanceAccountTrigger">
                        <span id="balanceAccountValue">Checking</span>
                        <i data-lucide="chevron-down" class="w-4 h-4"></i>
                      </div>
                      <div class="select-content" id="balanceAccountContent">
                        <!-- Options will be populated by JavaScript -->
                      </div>
                    </div>
                    <!-- Hidden native select for compatibility -->
                    <select id="slideOutBalanceAccount" style="display: none;">
                      <!-- Options will be populated by JavaScript -->
                    </select>
                  </div>
                  <div class="form-group">
                    <label class="form-label" for="slideOutBalanceAmount">Balance ($)</label>
                    <input type="number" class="form-input" id="slideOutBalanceAmount" placeholder="0.00" step="0.01">
                  </div>
                </div>
                
                <button type="button" class="balance-add-btn" onclick="addBalanceFromSlideOut()">Add Balance</button>
            </div>
        </div>
    </div>
    
    <!-- Account Management Slide-out -->
    <div class="account-management-slide-out" id="accountManagementSlideOut">
        <div class="account-management-content">
            <div class="account-management-header">
                <h3 class="account-management-title">Manage Accounts</h3>
                <button class="account-management-close" onclick="hideAccountManagementSlideOut()">
                    <i data-lucide="x" class="w-5 h-5"></i>
                </button>
            </div>
            
            <div class="account-management-list" id="accountManagementList">
                <!-- Account list will be populated by JavaScript -->
            </div>
            
            <div class="account-management-add-form">
                <h4 class="account-management-add-title">Add New Account</h4>
                <div class="account-management-input-group">
                    <input type="text" class="account-management-input" id="newAccountNameSlideOut" placeholder="e.g., Emergency Fund">
                </div>
                <button class="account-management-add-btn" onclick="addNewAccountFromSlideOut()">Add Account</button>
            </div>
        </div>
    </div>
    
    <!-- Legacy Account Management Modal (hidden for backwards compatibility) -->
    <div class="modal-overlay" id="accountManagementModal" style="display: none !important;">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">Manage Accounts</h3>
                <button class="modal-close" onclick="hideAccountManagementModal()"></button>
            </div>
            
            <div class="account-list" id="accountList">
                <!-- Account list will be populated by JavaScript -->
            </div>
            
            <div class="add-account-form">
                <h4 class="text-lg font-semibold mb-4">Add New Account</h4>
                <div class="form-group">
                    <label class="form-label" for="newAccountName">Account Name</label>
                    <input type="text" id="newAccountName" class="form-input" placeholder="e.g., Emergency Fund">
                </div>
                <button class="add-account-btn" onclick="addNewAccount()">Add Account</button>
            </div>
        </div>
    </div>
    
    <!-- Month/Year Slide-out -->
    <div class="slide-out-overlay" id="monthYearSlideOut">
        <div class="slide-out-content">
            <div class="slide-out-handle"></div>
            <div class="slide-out-header">
                <h3 class="slide-out-title">Select Month & Year</h3>
                <button class="slide-out-close" onclick="hideMonthYearSlideOut()"></button>
            </div>
            <div class="slide-out-form">
                <div class="form-group">
                    <label class="form-label" for="monthInput">Month</label>
                    <div class="select-container">
                        <div class="select-trigger" onclick="toggleSlideOutSelect('monthSelect')" id="monthSelectTrigger">
                            <span id="monthSelectValue">January</span>
                            <i data-lucide="chevron-down" class="w-4 h-4"></i>
                        </div>
                        <div class="select-content" id="monthSelectContent">
                            <div class="select-item" data-value="0">January</div>
                            <div class="select-item" data-value="1">February</div>
                            <div class="select-item" data-value="2">March</div>
                            <div class="select-item" data-value="3">April</div>
                            <div class="select-item" data-value="4">May</div>
                            <div class="select-item" data-value="5">June</div>
                            <div class="select-item" data-value="6">July</div>
                            <div class="select-item" data-value="7">August</div>
                            <div class="select-item" data-value="8">September</div>
                            <div class="select-item" data-value="9">October</div>
                            <div class="select-item" data-value="10">November</div>
                            <div class="select-item" data-value="11">December</div>
                        </div>
                    </div>
                    <!-- Hidden native select for compatibility -->
                    <select class="form-input" id="monthInput" style="display: none;">
                        <option value="0">January</option>
                        <option value="1">February</option>
                        <option value="2">March</option>
                        <option value="3">April</option>
                        <option value="4">May</option>
                        <option value="5">June</option>
                        <option value="6">July</option>
                        <option value="7">August</option>
                        <option value="8">September</option>
                        <option value="9">October</option>
                        <option value="10">November</div>
                        <option value="11">December</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label" for="yearInput">Year</label>
                    <div class="select-container">
                        <div class="select-trigger" onclick="toggleSlideOutSelect('monthYear')" id="monthYearTrigger">
                            <span id="monthYearValue">2024</span>
                            <i data-lucide="chevron-down" class="w-4 h-4"></i>
                        </div>
                        <div class="select-content" id="monthYearContent">
                            <!-- Year options will be populated by JavaScript -->
                        </div>
                    </div>
                    <!-- Hidden native select for compatibility -->
                    <select id="yearInput" style="display: none;">
                        <!-- Options will be populated by JavaScript -->
                    </select>
                </div>
                <button type="button" class="add-btn" id="applyMonthYearBtn" style="margin-top:1rem;">Apply</button>
            </div>
        </div>
    </div>
    
      <!-- Clerk -->
    <script>
        window.addEventListener('load', async function () {
            await Clerk.load({
                appearance: {
                    theme: 'light',
                    variables: {
                        colorPrimary: 'hsl(260, 58%, 58%)',
                        colorBackground: 'hsl(0 0% 100%)',
                        colorText: 'hsl(222.2 84% 4.9%)',
                        colorTextSecondary: 'hsl(215.4 24.61% 40.65%)',
                        colorInputBackground: 'hsl(0 0% 100%)',
                        colorInputText: 'hsl(222.2 84% 4.9%)',
                        colorDanger: 'hsl(0 84.2% 60.2%)',
                        colorSuccess: 'hsl(142.1 76.2% 36.3%)',
                        colorWarning: 'hsl(47.9 95.8% 53.1%)',
                        borderRadius: '0.5rem',
                        fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif',
                        fontSize: '0.875rem',
                        fontWeight: {
                            normal: '400',
                            medium: '500',
                            semibold: '600',
                            bold: '700'
                        }
                    },
                    elements: {
                        userButtonPopoverCard: {
                            borderRadius: '12px',
                            boxShadow: '0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)',
                            backgroundColor: 'hsl(var(--card))',
                            borderBottom: '1px solid hsl(var(--border))'
                        },
                        userButtonPopoverActionButton: {
                            color: 'hsl(var(--foreground))',
                            fontSize: '0.875rem',
                            fontWeight: '500',
                            padding: '0.75rem 1rem',
                            borderRadius: '0.5rem',
                            margin: '0.25rem 0.5rem',
                            transition: 'all 0.2s ease',
                            display: 'flex',
                            alignItems: 'center',
                            gap: '0.75rem'
                        },
                        userButtonPopoverActionButton__hover: {
                            backgroundColor: 'hsl(var(--accent))',
                            color: 'hsl(var(--accent-foreground))'
                        },
                        userButtonPopoverActionButtonIcon: {
                            color: 'hsl(var(--muted-foreground))',
                            width: '1.5rem',
                            height: '1.5rem',
                            fontSize: '1.5rem',
                            display: 'inline-flex',
                            alignItems: 'center',
                            justifyContent: 'center'
                        },
                        userButtonPopoverFooter: {
                            display: 'none !important'
                        },
                        userButtonPopoverActionButton__signOut: {
                            color: 'hsl(var(--destructive))',
                            fontWeight: '500'
                        },
                        userButtonPopoverActionButton__signOut__hover: {
                            backgroundColor: 'hsl(var(--destructive) / 0.1)',
                            color: 'hsl(var(--destructive))'
                        },
                        userButtonTrigger: {
                            borderRadius: '50%',
                            border: '2px solid hsl(var(--border))',
                            width: '40px',
                            height: '40px',
                            transition: 'all 0.2s ease'
                        },
                        userButtonTrigger__hover: {
                            borderColor: 'hsl(var(--ring))',
                            transform: 'scale(1.05)'
                        },
                        userButtonAvatarImage: {
                            borderRadius: '50%'
                        },
                        badge: {
                            backgroundColor: 'hsl(var(--primary))',
                            color: 'hsl(var(--primary-foreground))',
                            fontSize: '0.75rem',
                            fontWeight: '600',
                            borderRadius: '9999px',
                            padding: '0.125rem 0.375rem'
                        }
                    },
                    layout: {
                        logoImageUrl: '',
                        showOptionalFields: false
                    }
                }
            });

            if (Clerk.user) {
                const userButton = document.createElement('div');
                userButton.setAttribute('id', 'user-button');
                const app = document.querySelector('#user-avatar');
                if (!app) {
                    console.error('App element not found');
                    return;
                } else {
                    app.appendChild(userButton);
                }
                const userButtonDiv = document.getElementById('user-button');
                Clerk.mountUserButton(userButtonDiv, {
                    showName: false,
                    appearance: {
                        elements: {
                            userButtonTrigger: {
                                '&:focus': {
                                    outline: '2px solid hsl(var(--ring))',
                                    outlineOffset: '2px'
                                }
                            }
                        }
                    }
                });
            } else {
                document.getElementById('app').innerHTML = `
            <div id="sign-in"></div>
          `;
                const signInDiv = document.getElementById('sign-in');
                Clerk.mountSignIn(signInDiv, {
                    appearance: {
                        variables: {
                            colorPrimary: 'hsl(260, 58%, 58%)',
                            colorBackground: 'hsl(0 0% 100%)',
                            colorText: 'hsl(222.2 84% 4.9%)',
                            borderRadius: '0.5rem',
                            fontFamily: '-apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif'
                        },
                        elements: {
                            card: {
                                borderRadius: '12px',
                                boxShadow: '0 10px 15px -3px rgba(0, 0, 0, 0.1)',
                                border: '2px solid hsl(var(--border) / 0.5)'
                            },
                            formButtonPrimary: {
                                backgroundColor: 'hsl(260, 58%, 58%)',
                                borderRadius: '0.5rem',
                                fontSize: '0.875rem',
                                fontWeight: '500',
                                padding: '0.75rem 1.5rem'
                            }
                        }
                    }
                });
            }
        });
    </script>
    <script>
        // Firebase configuration (add your actual config)
        const firebaseConfig = {
            // Replace with your Firebase config
            apiKey: "your-api-key",
            authDomain: "your-project.firebaseapp.com",
            projectId: "your-project-id",
            storageBucket: "your-project.appspot.com",
            messagingSenderId: "123456789",
            appId: "your-app-id"
        };

        // Initialize Firebase (uncomment when you have real config)
        // firebase.initializeApp(firebaseConfig);
        // const db = firebase.firestore();

        // Period tracking variables
        let currentPeriodMode = 'month'; // 'today' or 'month'
        let currentSavePeriodMode = 'month'; // 'today' or 'month' for save screen
        let selectedMonthDate = new Date(2025, 6, 7); // Hard-coded to July 7, 2025
        let selectedSaveMonthDate = new Date(2025, 6, 7); // Separate month date for save screen, July 7, 2025
        let currentChartPeriod = 'ALL'; // '1M', '3M', '6M', 'YTD', '1Y', 'ALL' - Changed from YTD to ALL to show all balance data

        let currentScreen = 0;
        let spendingChart;
        let categoryChart;

        // Storage keys
        const EXPENSES_KEY = 'dailyExpenses';
        const MONTHLY_DATA_KEY = 'monthlyData';
        const SAVINGS_ACCOUNTS_KEY = 'savingsAccounts';
        const ACCOUNT_BALANCES_KEY = 'accountBalances';

        // Budget functions that get values from settings
        function getDailyBudget() {
            const settings = getSimpleBudgetSettings();
            const discretionaryBudget = settings.discretionaryExpenses || 501;
            const dailyBudget = discretionaryBudget / 30; // Daily discretionary budget
            return dailyBudget;
        }

        function getWeeklyBudget() {
            return getDailyBudget() * 7;
        }

        function getMonthlyBudget() {
            const settings = getSimpleBudgetSettings();
            const budget = (settings.essentialExpenses || 750) + (settings.discretionaryExpenses || 501);
            return budget;
        }

        function getMonthlySavingsTarget() {
            const settings = getSimpleBudgetSettings();
            return settings.monthlySavingsTarget || 4333;
        }

        function getSimpleBudgetSettings() {
            const savedSettings = localStorage.getItem('simpleBudgetSettings');
            if (savedSettings) {
                return JSON.parse(savedSettings);
            }
            // Return default values if no settings saved
            return {
                grossIncome: 11667,
                federalTax: 2500,
                provincialTax: 750,
                cppEi: 333,
                netIncome: 8084,
                annualSavingsGoal: 52000,
                monthlySavingsTarget: 4333,
                fixedExpenses: 2450,
                essentialExpenses: 750,
                discretionaryExpenses: 501
            };
        }

        // Savings tracking variables
        savingsAccounts = [];

        // No default accounts - empty array
        const defaultAccounts = [];

        async function goToScreen(screenIndex) {
            // If we're already on this screen, just scroll to top
            if (currentScreen === screenIndex) {
                const screens = document.querySelectorAll('.screen');
                if (screens[screenIndex]) {
                    // Use faster, more responsive scroll
                    screens[screenIndex].scrollTo({ 
                        top: 0, 
                        behavior: 'smooth'
                    });
                    
                    // Apply custom faster scroll animation
                    screens[screenIndex].style.scrollBehavior = 'auto';
                    const startTime = performance.now();
                    const startScrollTop = screens[screenIndex].scrollTop;
                    
                    function animateScroll(currentTime) {
                        const elapsed = currentTime - startTime;
                        const progress = Math.min(elapsed / 300, 1); // 300ms duration
                        const easeProgress = 1 - Math.pow(1 - progress, 3); // ease-out cubic
                        
                        screens[screenIndex].scrollTop = startScrollTop * (1 - easeProgress);
                        
                        if (progress < 1) {
                            requestAnimationFrame(animateScroll);
                        } else {
                            screens[screenIndex].style.scrollBehavior = 'smooth';
                        }
                    }
                    
                    requestAnimationFrame(animateScroll);
                }
                return;
            }

            currentScreen = screenIndex;
            const wrapper = document.getElementById('screensWrapper');
            wrapper.style.transform = `translateX(-${screenIndex * 100}vw)`;

            // Update nav items
            document.querySelectorAll('.nav-item').forEach((item, index) => {
                item.classList.toggle('active', index === screenIndex);
            });

            // Header title removed - navigation labels now in bottom nav

            if (screenIndex === 0) {
                // Home screen - show spinner while updating
                showGlobalSpinner();
                
                // Use the same exact logic as DOMContentLoaded
                updateHomeScreen().then(() => {
                    hideGlobalSpinner();
                }).catch(error => {
                    console.error('Error updating home screen:', error);
                    hideGlobalSpinner();
                });
            } else if (screenIndex === 1) {
                // Cashflow screen (formerly Spend)
                setPeriodMode('month');
                // Add chart click listener for spending screen
                if (typeof window.addChartClickListener === 'function') {
                    window.addChartClickListener();
                }
                // Ensure monthly chart is generated
                setTimeout(async () => {
                    await generateMonthlyChart();
                    // Re-initialize swipe functionality after chart render
                    if (typeof initializeChartSwipe === 'function') {
                        initializeChartSwipe();
                    }
                    // Also refresh the expenses list to ensure fresh data
                    updateTransactionsForTimeRange();
                }, 100);
                // updateCashflowPeriodDisplay(); // Function not defined - commented out to fix ReferenceError
                await updateBudgetDisplay();
                updateTransactionsForTimeRange();
                
                // Ensure icons are initialized after all content is loaded
                setTimeout(() => {
                    if (window.initializeTransactionIcons) {
                        window.initializeTransactionIcons();
                    }
                }, 200);
            } else {
                // Remove chart click listener when not on spending screen
                if (typeof window.removeChartClickListener === 'function') {
                    window.removeChartClickListener();
                }
                
                if (screenIndex === 2) {
                    // Accounts screen (formerly Save)
                    setSavePeriodMode('month');
                    updateSaveScreen();
                } else if (screenIndex === 3) {
                    // Dashboard screen (formerly Reports)
                    updateReports();
                    setTimeout(updateChart, 300);
                }
            }
        }


        function getCurrentDate() {
            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }

        async function loadAccountBalances() {
            try {
                // Get Clerk session token
                const sessionToken = await window.plaidService.getClerkSessionToken();
                
                // Fetch accounts from database
                const response = await fetch(`${window.plaidService.baseUrl}/api/accounts`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${sessionToken}`,
                    }
                });

                if (!response.ok) {
                    throw new Error(`Failed to load accounts: ${response.status}`);
                }

                const data = await response.json();
                
                // Convert accounts to the balance format expected by the app
                const balances = {};
                
                if (data.accounts && Array.isArray(data.accounts)) {
                    data.accounts.forEach(account => {
                        // Create a balance entry for today's date for each account
                        const today = new Date().toISOString().split('T')[0];
                        const accountKey = account.name.toLowerCase().replace(/\s+/g, '_');
                        
                        if (!balances[accountKey]) {
                            balances[accountKey] = {};
                        }
                        
                        balances[accountKey][today] = {
                            amount: account.current_balance || 0,
                            date: today
                        };
                    });
                }
                
                return balances;
            } catch (error) {
                console.error('Error loading account balances from database:', error);
                return {}; // Return empty object if error
            }
        }

        function saveAccountBalances(balances) {
            localStorage.setItem('accountBalances', JSON.stringify(balances));
        }

        async function updatePeriodView() {
            await updateBudgetDisplay();
            await updateExpensesList();
            updateTotalSavingsDisplay(); // Always update, regardless of mode
            updateSaveScreen(); // Update save screen as well
        }

        async function updateBudgetDisplay() {
            const expenses = await loadExpenses();
            const settings = getSimpleBudgetSettings();
            let totalSpent = 0;
            let monthlyIncome = settings.netIncome || 8084;

            if (currentPeriodMode === 'today') {
                // Calculate this week's spending
                const weekDates = getCurrentWeekDates();
                weekDates.forEach(date => {
                    const dayExpenses = expenses[date] || [];
                    totalSpent += dayExpenses.reduce((sum, expense) => sum + expense.amount, 0);
                });

                // Calculate weekly income (monthly income / ~4.33 weeks)
                monthlyIncome = monthlyIncome / 4.33;
            } else {
                // Monthly calculation
                const monthKey = getCurrentPeriodKey();
                Object.keys(expenses).forEach(date => {
                    if (date.startsWith(monthKey)) {
                        const dayExpenses = expenses[date] || [];
                        totalSpent += dayExpenses.reduce((sum, expense) => sum + expense.amount, 0);
                    }
                });

            }

            // Generate monthly spending chart instead of income/spending bars
            await generateMonthlyChart();

            // Update change indicators (calculate monthly status once)
            updateMonthlyStatus();
        }

        let lastMonthlyStatusUpdate = null;

        async function updateMonthlyStatus() {
            const expenses = await loadExpenses();
            const monthlyBudget = getMonthlyBudget();
            let monthlySpent = 0;
            const monthKey = getCurrentPeriodKey();

            Object.keys(expenses).forEach(date => {
                if (date.startsWith(monthKey)) {
                    const dayExpenses = expenses[date] || [];
                    monthlySpent += dayExpenses.reduce((sum, expense) => sum + expense.amount, 0);
                }
            });

            // Only update if values actually changed
            const currentValues = { monthlySpent, monthlyBudget, monthKey };
            if (!lastMonthlyStatusUpdate || JSON.stringify(lastMonthlyStatusUpdate) !== JSON.stringify(currentValues)) {
                lastMonthlyStatusUpdate = currentValues;
                updateChangeIndicators(monthlySpent, monthlyBudget - monthlySpent, monthlyBudget);
            }
        }

        function getCurrentWeekDates() {
            const today = new Date();
            const currentDay = today.getDay(); // 0 = Sunday, 1 = Monday, etc.
            const mondayOffset = currentDay === 0 ? -6 : 1 - currentDay; // Calculate days to Monday

            const weekDates = [];
            for (let i = 0; i < 7; i++) {
                const date = new Date(today);
                date.setDate(today.getDate() + mondayOffset + i);
                weekDates.push(date.toISOString().split('T')[0]); // YYYY-MM-DD format
            }
            return weekDates;
        }

        function updateBudgetLabels() {
            const spentLabel = document.querySelector('.spending-card .text-muted-foreground');
            const remainingLabel = document.querySelector('.remaining-card .text-muted-foreground');

            if (currentPeriodMode === 'today') {
                if (spentLabel) spentLabel.textContent = 'Spent This Week';
                if (remainingLabel) remainingLabel.textContent = 'Remaining This Week';
            } else {
                if (spentLabel) spentLabel.textContent = 'Spent This Month';
                if (remainingLabel) remainingLabel.textContent = 'Remaining This Month';
            }
        }

        async function calculateMonthOverMonthChange(currentMonthSpent) {
            const expenses = await loadExpenses();
            const currentDate = new Date(selectedMonthDate);

            // Get previous month
            const previousMonth = new Date(currentDate);
            previousMonth.setMonth(previousMonth.getMonth() - 1);
            const previousMonthKey = previousMonth.toISOString().substring(0, 7); // YYYY-MM format

            // Calculate previous month spending
            let previousMonthSpent = 0;
            Object.keys(expenses).forEach(date => {
                if (date.startsWith(previousMonthKey)) {
                    const dayExpenses = expenses[date] || [];
                    previousMonthSpent += dayExpenses.reduce((sum, expense) => sum + expense.amount, 0);
                }
            });

            // Calculate percentage change
            if (previousMonthSpent === 0) {
                return currentMonthSpent > 0 ? 100 : null; // 100% increase from 0, or null if both are 0
            }

            return ((currentMonthSpent - previousMonthSpent) / previousMonthSpent) * 100;
        }

        async function updateChangeIndicators(monthlySpent, monthlyRemaining, monthlyBudget) {
            const spentChange = document.getElementById('spentChange');
            const remainingChange = document.getElementById('remainingChange');

            // Calculate monthly percentage used
            const monthlyPercentUsed = (monthlySpent / monthlyBudget) * 100;

            // Calculate month-over-month change for spending
            const monthOverMonthChange = await calculateMonthOverMonthChange(monthlySpent);

            // Update spent change indicator with month-over-month percentage
            if (spentChange) {
                const spentArrow = spentChange.querySelector('.change-arrow');
                const spentAmount = spentChange.querySelector('.change-amount');

                if (monthOverMonthChange === null) {
                    if (spentArrow) spentArrow.textContent = '';
                    if (spentAmount) spentAmount.textContent = 'No data';
                } else {
                    const isIncrease = monthOverMonthChange > 0;
                    if (spentArrow) spentArrow.textContent = isIncrease ? '' : '';
                    if (spentAmount) spentAmount.textContent = `${Math.abs(monthOverMonthChange).toFixed(1)}%`;

                    // Update color based on increase/decrease
                    const changeIndicator = spentChange;
                    if (changeIndicator) {
                        changeIndicator.style.color = isIncrease ? '#ef4444' : '#5fa42e'; // red for increase, green for decrease
                    }
                }
            }

            // Update remaining change indicator based on MONTHLY budget status
            if (remainingChange) {
                const remainingArrow = remainingChange.querySelector('.change-arrow');
                const remainingStatus = remainingChange.querySelector('.change-amount');
                const remainingCard = document.querySelector('.remaining-card .change-indicator');

                // Debug log

                if (monthlyPercentUsed >= 100) {
                    if (remainingArrow) remainingArrow.textContent = '';
                    if (remainingStatus) remainingStatus.textContent = 'Over Budget';
                    if (remainingCard) remainingCard.classList.add('over-budget');
                } else if (monthlyPercentUsed >= 75) {
                    if (remainingArrow) remainingArrow.textContent = '';
                    if (remainingStatus) remainingStatus.textContent = 'Warning';
                    if (remainingCard) remainingCard.classList.remove('over-budget');
                } else {
                    if (remainingArrow) remainingArrow.textContent = '';
                    if (remainingStatus) remainingStatus.textContent = 'On Track';
                    if (remainingCard) remainingCard.classList.remove('over-budget');
                }
            }
        }

        async function updateExpensesList() {
            const expenses = await loadExpenses();
            const listContainer = document.getElementById('expensesList');
            const titleElement = document.getElementById('expensesListTitle');

            if (!listContainer) return;

            let periodExpenses = [];

            if (currentPeriodMode === 'today') {
                // Show this week's transactions
                const weekDates = getCurrentWeekDates();
                weekDates.forEach(date => {
                    const dayExpenses = expenses[date] || [];
                    dayExpenses.forEach(expense => {
                        periodExpenses.push({
                            ...expense,
                            date: date
                        });
                    });
                });

                // Sort by timestamp, newest first
                periodExpenses.sort((a, b) => {
                    return b.timestamp - a.timestamp;
                });

                if (titleElement) titleElement.textContent = "Transactions";
            } else {
                // Month mode: gather all expenses for the selected month
                const monthKey = getCurrentPeriodKey();
                Object.keys(expenses).forEach(date => {
                    if (date.startsWith(monthKey)) {
                        const dayExpenses = expenses[date] || [];
                        dayExpenses.forEach(expense => {
                            periodExpenses.push({
                                ...expense,
                                date: date
                            });
                        });
                    }
                });

                // Sort: by date (desc), then by created (asc), then by timestamp for stability
                periodExpenses.sort((a, b) => {
                    if (a.date !== b.date) {
                        return new Date(b.date) - new Date(a.date); // latest date first
                    }
                    // If same date, sort by created descending (newest first)
                    const createdA = a.created || a.timestamp;
                    const createdB = b.created || b.timestamp;
                    if (createdA !== createdB) {
                        return createdB - createdA; // Reversed order
                    }
                    // If created timestamps are the same, use timestamp for stable ordering
                    return b.timestamp - a.timestamp; // Reversed order
                });

                const monthName = selectedMonthDate.toLocaleDateString('en-US', { month: 'long' });
                if (titleElement) titleElement.textContent = "Transactions";
            }

            if (periodExpenses.length === 0) {
                const noExpensesText = currentPeriodMode === 'today' ? 'No transactions recorded this week' : 'No transactions recorded this month';
                listContainer.innerHTML = `<div style="text-align: center; color: #7f8c8d; padding: 20px;">${noExpensesText}</div>`;
            } else {
                // Group expenses by date
                const expensesByDate = {};
                periodExpenses.forEach(expense => {
                    if (!expensesByDate[expense.date]) {
                        expensesByDate[expense.date] = [];
                    }
                    expensesByDate[expense.date].push(expense);
                });

                // Generate HTML with date grouping
                let html = '';
                Object.keys(expensesByDate).sort((a, b) => new Date(b) - new Date(a)).forEach(date => {
                    const expenses = expensesByDate[date];
                    const dateParts = date.split('-').map(Number);
                    const dateObj = new Date(dateParts[0], dateParts[1] - 1, dateParts[2]);
                    const dateTitle = dateObj.toLocaleDateString('en-US', {
                        month: 'long',
                        day: 'numeric',
                        year: 'numeric'
                    });

                    // Calculate daily total
                    const dayTotal = expenses.reduce((sum, expense) => sum + parseFloat(expense.amount), 0);

                    html += `
                            <div class="date-group">
                                <div class="date-header">
                                    <span class="date-title">${dateTitle}</span>
                                    <span class="date-total">$${dayTotal.toFixed(2)}</span>
                                </div>
                                <div class="date-transactions">
                        `;

                    expenses.forEach(expense => {
                        html += `
                                <div class="swipe-container" data-type="expense" data-date="${expense.date}" data-timestamp="${expense.timestamp}">
                                    <div class="swipe-content">
                                        <div class="expense-item">
                                            <div class="expense-icon">${getCategoryEmoji(expense.category)}</div>
                                            <div class="expense-details">
                                                <div class="expense-description">${expense.description ? expense.description : `${expense.category} expense`}</div>
                                            </div>
                                            <div class="expense-amount">$${parseFloat(expense.amount).toFixed(2)}</div>
                                        </div>
                                    </div>
                                    <div class="swipe-action" onclick="handleExpenseDelete(this); event.stopPropagation(); return false;"><i data-lucide="x" class="w-5 h-5"></i></div>
                                </div>
                            `;
                    });

                    html += `
                                </div>
                            </div>
                        `;
                });

                listContainer.innerHTML = html;
                
                // Initialize icons for the newly inserted expense items
                if (window.initializeTransactionIcons) {
                    window.initializeTransactionIcons();
                }
            }
        }

        async function deleteExpense(date, timestamp) {
            timestamp = parseInt(timestamp, 10); // Ensure timestamp is a number

            if (!date || isNaN(timestamp)) {
                console.error('Invalid date or timestamp:', { date, timestamp });
                alert('Invalid date or timestamp. Cannot delete expense.');
                return;
            }

            try {
                const expenses = await loadExpenses();

                // Handle the case where date might be undefined for today mode
                const targetDate = date || getCurrentDate();

                if (expenses[targetDate]) {

                    // Filter out the expense with the matching timestamp
                    const originalLength = expenses[targetDate].length;
                    expenses[targetDate] = expenses[targetDate].filter(expense => {
                        const match = expense.timestamp !== timestamp;
                        return expense.timestamp !== timestamp;
                    });

                    // Check if the expense was actually removed
                    if (expenses[targetDate].length === originalLength) {
                        console.error('Expense not found with timestamp:', timestamp);
                        alert('Could not find expense to delete. Please refresh and try again.');

                        // Remove the 'deleting' class from the element to restore it
                        const swipeContainer = document.querySelector(`.swipe-container[data-timestamp="${timestamp}"]`);
                        if (swipeContainer) {
                            swipeContainer.classList.remove('deleting');
                        }

                        return;
                    }


                    // Remove the date entry if no expenses left for that date
                    if (expenses[targetDate].length === 0) {
                        delete expenses[targetDate];
                    }

                    // Save the updated expenses
                    saveExpenses(expenses);

                    // Force refresh UI
                    const listContainer = document.getElementById('expensesList');
                    if (listContainer) {
                        updateExpensesList();
                    }

                    // Update the rest of the display
                    await updatePeriodView();
                    updateChart();
                    
                    // Update monthly spending chart
                    if (typeof generateMonthlyChart === 'function') {
                        await generateMonthlyChart();
                    }



                } else {
                    console.error('No expenses found for date:', targetDate);
                    alert('Could not find expenses for this date. Please refresh and try again.');

                    // Remove the 'deleting' class from the element to restore it
                    const swipeContainer = document.querySelector(`.swipe-container[data-timestamp="${timestamp}"]`);
                    if (swipeContainer) {
                        swipeContainer.classList.remove('deleting');
                    }
                }
            } catch (error) {
                console.error('Error in deleteExpense function:', error);
                alert('An error occurred while deleting the expense. Please try again.');

                // Remove the 'deleting' class from the element to restore it
                const swipeContainer = document.querySelector(`.swipe-container[data-timestamp="${timestamp}"]`);
                if (swipeContainer) {
                    swipeContainer.classList.remove('deleting');
                }
            }
        }

        async function updateReports() {
            // Update weekly and monthly stats
            const expenses = await loadExpenses();
            const today = new Date(2025, 6, 7); // Hard-coded to July 7, 2025
            const dayOfMonth = today.getDate();
            const daysInMonth = new Date(today.getFullYear(), today.getMonth() + 1, 0).getDate();
            const remainingDaysInMonth = daysInMonth - dayOfMonth;

            // Calculate weekly spending
            let weeklySpent = 0;
            let monthlySpent = 0; // <-- Add this missing declaration
            for (let i = 0; i < 7; i++) {
                const date = new Date(today);
                date.setDate(today.getDate() - i);
                const dateKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
                const dayExpenses = expenses[dateKey] || [];
                weeklySpent += dayExpenses.reduce((sum, expense) => sum + expense.amount, 0);
            }

            // Calculate monthly spending
            Object.keys(expenses).forEach(date => {
                if (date.startsWith(getCurrentMonth())) {
                    const dayExpenses = expenses[date] || [];
                    monthlySpent += dayExpenses.reduce((sum, expense) => sum + expense.amount, 0);
                }
            });

            // Calculate daily burn rate (average spent per day)
            const dailyBurnRate = monthlySpent / dayOfMonth;

            // Calculate projected spending for the rest of the month
            const projectedAdditionalSpending = dailyBurnRate * remainingDaysInMonth;
            const projectedTotalSpending = monthlySpent + projectedAdditionalSpending;

            // Calculate projected monthly savings
            const projectedMonthlySavings = Math.max(0, getMonthlyBudget() - projectedTotalSpending);

            // Calculate days left in budget (at current burn rate)
            const remainingBudget = getMonthlyBudget() - monthlySpent;
            const daysLeftInBudget = dailyBurnRate > 0 ? Math.floor(remainingBudget / dailyBurnRate) : remainingDaysInMonth;

            // Calculate savings rate (assuming budget = income - required savings)
            // This is an approximation - in reality, we'd need income data
            const assumedIncome = getMonthlyBudget() + getMonthlySavingsTarget();
            const projectedSavings = assumedIncome - projectedTotalSpending;
            const savingsRate = (projectedSavings / assumedIncome) * 100;

            // Update weekly metrics
            const weeklySpentEl = document.getElementById('weeklySpent');
            const weeklyRemainingEl = document.getElementById('weeklyRemaining');
            const projectedMonthlySavingsEl = document.getElementById('projectedMonthlySavings');

            if (weeklySpentEl) weeklySpentEl.textContent = formatCurrencyWhole(weeklySpent);
            if (weeklyRemainingEl) weeklyRemainingEl.textContent = formatCurrencyWhole(Math.max(0, getWeeklyBudget() - weeklySpent));
            if (projectedMonthlySavingsEl) projectedMonthlySavingsEl.textContent = formatCurrencyWhole(projectedMonthlySavings);

            // Update monthly stats
            const monthlySpentEl = document.getElementById('monthlySpent');
            const monthSpentSubtitleEl = document.getElementById('monthSpentSubtitle');
            const dailyBurnRateEl = document.getElementById('dailyBurnRate');
            const burnRateStatusEl = document.getElementById('burnRateStatus');
            const daysRemainingEl = document.getElementById('daysRemaining');
            const daysRemainingSubtitleEl = document.getElementById('daysRemainingSubtitle');
            const savingsRateEl = document.getElementById('savingsRate');
            const savingsRateSubtitleEl = document.getElementById('savingsRateSubtitle');

            // Update month spent with percentage indicator
            if (monthlySpentEl) monthlySpentEl.textContent = formatCurrencyWhole(monthlySpent);
            if (monthSpentSubtitleEl) {
                const percentUsed = (monthlySpent / getMonthlyBudget()) * 100;
                monthSpentSubtitleEl.textContent = `${percentUsed.toFixed(0)}% of ${formatCurrency(getMonthlyBudget())} budget`;
            }

            // Update daily burn rate with status
            if (dailyBurnRateEl) dailyBurnRateEl.textContent = formatCurrencyWhole(dailyBurnRate);
            if (burnRateStatusEl) {
                const dailyTarget = getMonthlyBudget() / daysInMonth;
                const difference = dailyTarget - dailyBurnRate;
                let burnRateStatus = '';

                if (difference > 0) {
                    burnRateStatus = `${formatCurrencyWhole(difference)} under target`;
                    burnRateStatusEl.className = 'stat-subtitle positive';
                } else if (difference < 0) {
                    burnRateStatus = `${formatCurrencyWhole(Math.abs(difference))} over target`;
                    burnRateStatusEl.className = 'stat-subtitle negative';
                } else {
                    burnRateStatus = 'right on target';
                    burnRateStatusEl.className = 'stat-subtitle';
                }

                burnRateStatusEl.textContent = burnRateStatus;
            }

            // Update days left in budget
            if (daysRemainingEl) {
                if (daysLeftInBudget >= remainingDaysInMonth) {
                    daysRemainingEl.textContent = remainingDaysInMonth;
                    daysRemainingEl.className = 'stat-value positive';
                } else if (daysLeftInBudget <= 0) {
                    daysRemainingEl.textContent = '0';
                    daysRemainingEl.className = 'stat-value negative';
                } else {
                    daysRemainingEl.textContent = daysLeftInBudget;
                    if (daysLeftInBudget < 7) {
                        daysRemainingEl.className = 'stat-value warning';
                    } else {
                        daysRemainingEl.className = 'stat-value';
                    }
                }
            }

            if (daysRemainingSubtitleEl) {
                const daysMessage = daysLeftInBudget >= remainingDaysInMonth ?
                    'on track' : `${remainingDaysInMonth - daysLeftInBudget} days short`;
                daysRemainingSubtitleEl.textContent = daysMessage;
            }

            // Update savings rate
            if (savingsRateEl) {
                savingsRateEl.textContent = `${Math.max(0, savingsRate).toFixed(0)}%`;

                // Styling based on savings goal
                const targetSavingsRate = (getMonthlySavingsTarget() / assumedIncome) * 100;
                if (savingsRate >= targetSavingsRate) {
                    savingsRateEl.className = 'stat-value positive';
                } else if (savingsRate >= targetSavingsRate * 0.7) {
                    savingsRateEl.className = 'stat-value warning';
                } else {
                    savingsRateEl.className = 'stat-value negative';
                }
            }

            if (savingsRateSubtitleEl) {
                savingsRateSubtitleEl.textContent = `vs ${(getMonthlySavingsTarget() / assumedIncome * 100).toFixed(0)}% target`;
            }

            // Update month name in labels
            updateMonthLabel();
        }

        function updateMonthLabel() {
            // Hard-coded date for consistency: July 7, 2025
            const monthName = new Date(2025, 6, 7).toLocaleDateString('en-US', { month: 'long' });
            const monthSpentLabelEl = document.getElementById('monthSpentLabel');

            if (monthSpentLabelEl) {
                monthSpentLabelEl.textContent = `${monthName} Spent`;
            }
        }

        function setChartPeriod(period) {
            // If it's the same period, don't do anything
            if (currentChartPeriod === period) return;

            // Store the previous period for animation
            const previousPeriod = currentChartPeriod;
            currentChartPeriod = period;

            // Update button states with smooth transition
            document.querySelectorAll('.chart-period-btn-wealthsimple').forEach(btn => {
                btn.classList.remove('active');
            });

            const periodBtn = document.getElementById('period' + period);
            if (periodBtn) {
                // Small delay for visual feedback
                setTimeout(() => {
                    periodBtn.classList.add('active');
                }, 10);
            }

            // Add loading indicator if needed for longer data sets
            const chartContainer = document.querySelector('.chart-container');
            if (period === 'ALL') {
                chartContainer.classList.add('loading');
            }

            // Slight delay for animation
            setTimeout(() => {
                updateChart();
                chartContainer.classList.remove('loading');
            }, 100);
        }

        async function updateChart() {
            // Get expenses and balances
            const expenses = await loadExpenses();
            const balances = loadAccountBalances();

            // Get chart canvas
            const ctx = document.getElementById('spendingChart').getContext('2d');

            // Calculate date range based on selected time range
            const dateRange = getDateRangeForTimeRange(currentTimeRange);
            const startDate = dateRange.startDate;
            const endDate = dateRange.endDate;

            // Helper to find the nearest data index from x coordinate
            function getNearestIndex(x) {
                const chartArea = spendingChart.chartArea;
                if (!chartArea) return savingsData.length - 1;
                const xScale = spendingChart.scales.x;
                let minDist = Infinity;
                let nearest = 0;
                for (let i = 0; i < labels.length; i++) {
                    const px = xScale.getPixelForValue(i);
                    const dist = Math.abs(px - x);
                    if (dist < minDist) {
                        minDist = dist;
                        nearest = i;
                    }
                }
                return nearest;
            }

            // Generate dates between start and end date
            const dates = [];
            const currentDate = new Date(startDate);
            while (currentDate <= endDate) {
                dates.push(new Date(currentDate));
                currentDate.setDate(currentDate.getDate() + 1);
            }

            // Format dates for labels and lookup
            const labels = dates.map(date => {
                return date.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });
            });

            const dateKeys = dates.map(date => {
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            });

            // Calculate cumulative spending
            const spendingData = [];
            let cumulativeSpending = 0;

            dateKeys.forEach(dateKey => {
                const dayExpenses = expenses[dateKey] || [];
                const dayTotal = dayExpenses.reduce((sum, expense) => sum + expense.amount, 0);
                cumulativeSpending += dayTotal;
                spendingData.push(cumulativeSpending);
            });

            // Calculate account balances over time
            const savingsData = new Array(dates.length).fill(null);

            // Get all balance records and sort by date
            const balanceRecords = [];

            // Create a map to sum up all account balances for each date
            const dateBalanceMap = new Map();

            Object.keys(balances).forEach(accountId => {
                const accountBalances = balances[accountId] || {};
                Object.keys(accountBalances).forEach(date => {
                    if (date >= dateKeys[0] && date <= dateKeys[dateKeys.length - 1]) {
                        const currentBalance = dateBalanceMap.get(date) || 0;
                        const accountBalance = accountBalances[date];
                        const newTotal = currentBalance + accountBalance;
                        dateBalanceMap.set(date, newTotal);
                    } else {
                    }
                });
            });

            // Convert the map to balance records array
            dateBalanceMap.forEach((totalAmount, date) => {
                balanceRecords.push({
                    date: date,
                    amount: totalAmount
                });
            });


            // Sort balance records by date
            balanceRecords.sort((a, b) => a.date.localeCompare(b.date));

            // Calculate total balance for each date
            let lastKnownBalance = 0;
            balanceRecords.forEach(record => {
                const dateIndex = dateKeys.indexOf(record.date);
                if (dateIndex !== -1) {
                    lastKnownBalance = record.amount;
                    savingsData[dateIndex] = lastKnownBalance;
                }
            });

            // Fill in missing balance data using last known balance
            for (let i = 0; i < savingsData.length; i++) {
                if (savingsData[i] === null) {
                    if (i > 0 && savingsData[i - 1] !== null) {
                        savingsData[i] = savingsData[i - 1];
                    } else {
                        savingsData[i] = 0; // Default if no previous balance
                    }
                }
            }

            // Calculate total savings and growth
            const initialSavings = savingsData[0] || 0;
            const finalSavings = savingsData[savingsData.length - 1] || 0;
            const savingsGrowth = finalSavings - initialSavings;
            const savingsGrowthPercent = initialSavings > 0 ? (savingsGrowth / initialSavings) * 100 : 0;

            // Calculate total spending and growth
            const initialSpending = spendingData[0] || 0;
            const finalSpending = spendingData[spendingData.length - 1] || 0;
            const spendingGrowth = finalSpending - initialSpending;
            const spendingGrowthPercent = initialSpending > 0 ? (spendingGrowth / initialSpending) * 100 : 0;

            // Chart header DOM elements for both rows
            const chartMainValue = document.getElementById('chartMainValue');
            const chartSubtitle = document.getElementById('chartSubtitle');
            const chartGrowth = document.getElementById('chartGrowth');
            const chartSpendingValue = document.getElementById('chartSpendingValue');
            const chartSpendingSubtitle = document.getElementById('chartSpendingSubtitle');
            // chartSpendingGrowth removed - no longer displaying spending growth
            const chartDateDisplay = document.getElementById('chartDateDisplay');

            /**
             * Updates chart header for a given index showing both savings and spending values.
             * @param {number} index - The data index to display.
             */
            function updateChartHeader(index) {
                if (!chartMainValue || !chartSubtitle || !chartGrowth ||
                    !chartSpendingValue || !chartSpendingSubtitle) return;

                const saved = savingsData[index];
                const spent = spendingData[index];
                const dateLabel = labels[index];

                // Update date display at the top
                if (chartDateDisplay) {
                    chartDateDisplay.innerHTML = `<span class="chart-selected-date">${dateLabel}</span>`;
                    chartDateDisplay.classList.add('visible');
                }

                // Update savings row
                chartMainValue.textContent = formatCurrency(saved);
                chartSubtitle.textContent = `Saved`;

                // Calculate savings growth from start to this point
                const savingsGrowthToDate = saved - initialSavings;
                const savingsGrowthPercentToDate = initialSavings > 0 ? (savingsGrowthToDate / initialSavings) * 100 : 0;
                const savingsGrowthPrefix = savingsGrowthToDate >= 0 ? '+' : '';

                // Add period context for interactive view as well
                let periodText = '';
                switch (currentChartPeriod) {
                    case '1M': periodText = 'since last month'; break;
                    case '3M': periodText = 'past 3 months'; break;
                    case '6M': periodText = 'past 6 months'; break;
                    case 'YTD': periodText = 'year to date'; break;
                    case '1Y': periodText = 'past year'; break;
                    case 'ALL': periodText = 'all time'; break;
                    default: periodText = 'all time';
                }

                chartGrowth.textContent = `${savingsGrowthPrefix}${formatCurrency(savingsGrowthToDate)} (${savingsGrowthPrefix}${savingsGrowthPercentToDate.toFixed(1)}%) ${periodText}`;
                chartGrowth.className = 'chart-growth ' + (savingsGrowthToDate >= 0 ? 'positive' : 'negative');

                // Update spending row - just show current value
                chartSpendingValue.textContent = formatCurrency(spent);
                chartSpendingSubtitle.textContent = `Spent`;
            }

            /**
             * Resets chart header to show latest total values for both savings and spending.
             */
            function resetChartHeader() {
                if (!chartMainValue || !chartSubtitle || !chartGrowth ||
                    !chartSpendingValue || !chartSpendingSubtitle) return;

                // Hide date display
                if (chartDateDisplay) {
                    chartDateDisplay.classList.remove('visible');
                }

                // Update savings row with final values
                chartMainValue.textContent = formatCurrency(finalSavings);
                chartSubtitle.textContent = 'Saved';
                const savingsGrowthPrefix = savingsGrowth >= 0 ? '+' : '';

                // Add period context to the savings growth text
                let savingsPeriodText = '';
                switch (currentChartPeriod) {
                    case '1M': savingsPeriodText = 'past month'; break;
                    case '3M': savingsPeriodText = 'past 3 months'; break;
                    case '6M': savingsPeriodText = 'past 6 months'; break;
                    case 'YTD': savingsPeriodText = 'year to date'; break;
                    case '1Y': savingsPeriodText = 'past year'; break;
                    case 'ALL': savingsPeriodText = 'all time'; break;
                    default: savingsPeriodText = 'all time';
                }

                chartGrowth.textContent = `${savingsGrowthPrefix}${formatCurrency(savingsGrowth)} (${savingsGrowthPrefix}${savingsGrowthPercent.toFixed(1)}%) ${savingsPeriodText}`;
                chartGrowth.className = 'chart-growth ' + (savingsGrowth >= 0 ? 'positive' : 'negative');

                // Update spending row with final values - only showing the amount
                chartSpendingValue.textContent = formatCurrency(finalSpending);
                chartSpendingSubtitle.textContent = 'Spent';
            }

            // Set default header
            resetChartHeader();

            // Destroy previous chart instance if it exists
            if (spendingChart) {
                // Clean up any existing interaction state
                hideChartInteraction();
                spendingChart.destroy();
            }

            // Create enhanced gradient for savings (Wealthsimple style) with fade to transparent
            const savingsGradient = ctx.createLinearGradient(0, 0, 0, 400);
            savingsGradient.addColorStop(0, 'rgba(16, 185, 129, 0.25)'); // Green with transparency
            savingsGradient.addColorStop(0.6, 'rgba(16, 185, 129, 0.05)');
            savingsGradient.addColorStop(0.8, 'rgba(16, 185, 129, 0.02)');
            savingsGradient.addColorStop(1, 'rgba(16, 185, 129, 0)');


            spendingChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Saved',
                            data: savingsData,
                            borderColor: 'rgb(16, 185, 129)',
                            backgroundColor: savingsGradient,
                            tension: 0.6,
                            fill: true,
                            pointRadius: 0,
                            borderWidth: 3,
                            z: 10,
                            pointHitRadius: 20,
                            pointBackgroundColor: 'transparent',
                            pointBorderColor: 'transparent',
                            pointBorderWidth: 0
                        },
                        {
                            label: 'Spent',
                            data: spendingData,
                            borderColor: 'rgb(107, 114, 128)', // Gray
                            backgroundColor: 'transparent', // No fill
                            tension: 0.6,
                            fill: false, // No fill for spending
                            borderDash: [4, 4], // Dotted line
                            pointRadius: 0,
                            borderWidth: 2.5,
                            z: 5,
                            pointHitRadius: 15,
                            pointBackgroundColor: 'transparent',
                            pointBorderColor: 'transparent',
                            pointBorderWidth: 0
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: {
                        duration: 1000,
                        easing: 'easeInOutQuart',
                        onProgress: function(animation) {
                            // Store animation progress for gradient plugin
                            this.gradientProgress = animation.currentStep / animation.numSteps;
                        },
                        onComplete: function() {
                            this.gradientProgress = 1;
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: { enabled: false }
                    },
                    scales: {
                        x: {
                            grid: { display: false },
                            ticks: {
                                display: false // Hide x-axis labels
                            },
                            border: { display: false }
                        },
                        y: {
                            grid: { display: false }, // Remove all horizontal grid lines
                            border: { display: false },
                            ticks: {
                                display: false // Hide y-axis labels
                            }
                        }
                    },
                    interaction: { intersect: false, mode: 'nearest' },
                    hover: { intersect: false, mode: 'nearest', enabled: false },
                    elements: {
                        point: {
                            hitRadius: 30,
                            hoverRadius: 0,
                            radius: 0,
                            hoverBackgroundColor: 'transparent',
                            hoverBorderColor: 'transparent',
                            hoverBorderWidth: 0
                        },
                        line: { tension: 0.6 }
                    }
                }
            });

            // --- INTERACTION: IMMEDIATE RESPONSIVE CROSSHAIR ---
            let interactionEnabled = false;
            let lastActiveIndex = null;

            /**
             * Enables chart interaction and shows crosshair/tooltip at the given x position.
             * @param {number} x - The x coordinate relative to the chart canvas.
             */
            function enableChartInteraction(x) {
                interactionEnabled = true;
                const index = getNearestIndex(x);
                updateChartHeader(index);
                showChartInteraction(index);
                lastActiveIndex = index;
            }

            /**
             * Disables chart interaction and hides crosshair/tooltip.
             */
            function disableChartInteraction() {
                interactionEnabled = false;
                resetChartHeader();
                hideChartInteraction();
                lastActiveIndex = null;
            }

            const chartCanvas = ctx.canvas;

            // Remove all previous listeners (Chart.js re-creates canvas, so this is safe)
            chartCanvas.onmousedown = null;
            chartCanvas.onmousemove = null;
            chartCanvas.onmouseup = null;
            chartCanvas.onmouseleave = null;
            chartCanvas.onclick = null;
            chartCanvas.ontouchstart = null;
            chartCanvas.ontouchmove = null;
            chartCanvas.ontouchend = null;
            chartCanvas.ontouchcancel = null;

            // Mouse events: immediate interaction on mouse down
            chartCanvas.addEventListener('mousedown', function (e) {
                const x = e.clientX - chartCanvas.getBoundingClientRect().left;
                enableChartInteraction(x);
            });
            chartCanvas.addEventListener('mousemove', function (e) {
                if (!interactionEnabled) return;
                const x = e.clientX - chartCanvas.getBoundingClientRect().left;
                const index = getNearestIndex(x);
                if (index !== lastActiveIndex) {
                    updateChartHeader(index);
                    showChartInteraction(index);
                    lastActiveIndex = index;
                }
            });
            chartCanvas.addEventListener('mouseup', function () {
                if (interactionEnabled) disableChartInteraction();
            });
            chartCanvas.addEventListener('mouseleave', function () {
                if (interactionEnabled) disableChartInteraction();
            });

            // Touch events: immediate interaction with direction detection
            let initialTouchY = 0;
            let initialTouchX = 0;
            let touchDirection = null; // 'vertical' or 'horizontal'

            chartCanvas.addEventListener('touchstart', function (e) {
                if (!e.touches || e.touches.length === 0) return;

                // Store initial touch position
                initialTouchX = e.touches[0].clientX;
                initialTouchY = e.touches[0].clientY;
                touchDirection = null; // Reset direction on new touch

                // Enable interaction immediately on touch
                const x = e.touches[0].clientX - chartCanvas.getBoundingClientRect().left;
                enableChartInteraction(x);
            });

            chartCanvas.addEventListener('touchmove', function (e) {
                if (!e.touches || e.touches.length === 0) return;

                // If we haven't determined direction yet, do so based on movement
                if (touchDirection === null) {
                    const deltaX = Math.abs(e.touches[0].clientX - initialTouchX);
                    const deltaY = Math.abs(e.touches[0].clientY - initialTouchY);

                    // If moving more vertically than horizontally, allow normal scroll
                    if (deltaY > deltaX && deltaY > 10) {
                        touchDirection = 'vertical';
                        return;
                    } else if (deltaX > 10) {
                        touchDirection = 'horizontal';
                    }
                }

                // If scrolling vertically, allow normal browser behavior
                if (touchDirection === 'vertical') return;

                // Only prevent default for horizontal movements when interaction is enabled
                if (interactionEnabled) {
                    e.preventDefault(); // Prevent scrolling when interacting with chart
                    const rect = chartCanvas.getBoundingClientRect();
                    const x = e.touches[0].clientX - rect.left;
                    
                    // Constrain to chart bounds to prevent edge effects
                    const constrainedX = Math.max(0, Math.min(rect.width, x));
                    const index = getNearestIndex(constrainedX);
                    if (index !== lastActiveIndex) {
                        updateChartHeader(index);
                        showChartInteraction(index);
                        // Enhanced haptic feedback - try multiple methods
                        // First try our utility
                        if (window.Haptics) {
                            window.Haptics.impact('medium');
                        }
                        // Also directly try Capacitor haptics
                        if (window.Capacitor && window.Capacitor.Plugins && window.Capacitor.Plugins.Haptics) {
                            window.Capacitor.Plugins.Haptics.impact({ style: 'medium' });
                        }
                        // For iOS, make sure we trigger a click-like event that can engage haptics
                        const el = document.activeElement || document.body;
                        el.dispatchEvent(new CustomEvent('haptic', { bubbles: true }));
                        lastActiveIndex = index;
                    }
                }
            }, { passive: false }); // Need to set passive: false to call preventDefault
            chartCanvas.addEventListener('touchend', function () {
                if (interactionEnabled) disableChartInteraction();
            });
            chartCanvas.addEventListener('touchcancel', function () {
                if (interactionEnabled) disableChartInteraction();
            });

            // Helper functions to show/hide chart interaction effects
            function showChartInteraction(activeIndex) {
                if (!spendingChart || !spendingChart.data || !spendingChart.data.datasets) return;

                // Show only the active point with hollow shapes
                spendingChart.data.datasets.forEach((dataset, datasetIndex) => {
                    // Reset all point properties to ensure clean state
                    dataset.pointRadius = new Array(dataset.data.length).fill(0);
                    dataset.pointBackgroundColor = new Array(dataset.data.length).fill('transparent');
                    dataset.pointBorderColor = new Array(dataset.data.length).fill('transparent');
                    dataset.pointBorderWidth = new Array(dataset.data.length).fill(0);
                    dataset.pointStyle = new Array(dataset.data.length).fill('circle');
                    dataset.pointHoverRadius = new Array(dataset.data.length).fill(0);
                    dataset.pointHoverBackgroundColor = new Array(dataset.data.length).fill('transparent');
                    dataset.pointHoverBorderColor = new Array(dataset.data.length).fill('transparent');
                    dataset.pointHoverBorderWidth = new Array(dataset.data.length).fill(0);

                    // Show only the active point with hollow shape
                    if (activeIndex >= 0 && activeIndex < dataset.data.length) {
                        if (datasetIndex === 0) {
                            // Savings dataset - hollow green circle
                            dataset.pointRadius[activeIndex] = 8;
                            dataset.pointBackgroundColor[activeIndex] = '#fff';
                            dataset.pointBorderColor[activeIndex] = 'rgb(16, 185, 129)';
                            dataset.pointBorderWidth[activeIndex] = 3;
                            dataset.pointStyle[activeIndex] = 'circle';
                            // Also set hover properties for the active point
                            dataset.pointHoverRadius[activeIndex] = 8;
                            dataset.pointHoverBackgroundColor[activeIndex] = '#fff';
                            dataset.pointHoverBorderColor[activeIndex] = 'rgb(16, 185, 129)';
                            dataset.pointHoverBorderWidth[activeIndex] = 3;
                        } else {
                            // Spending dataset - hollow gray square
                            dataset.pointRadius[activeIndex] = 7;
                            dataset.pointBackgroundColor[activeIndex] = '#fff';
                            dataset.pointBorderColor[activeIndex] = 'rgb(107, 114, 128)';
                            dataset.pointBorderWidth[activeIndex] = 2.5;
                            dataset.pointStyle[activeIndex] = 'rect';
                            // Also set hover properties for the active point
                            dataset.pointHoverRadius[activeIndex] = 7;
                            dataset.pointHoverBackgroundColor[activeIndex] = '#fff';
                            dataset.pointHoverBorderColor[activeIndex] = 'rgb(107, 114, 128)';
                            dataset.pointHoverBorderWidth[activeIndex] = 2.5;
                        }
                    }
                    // Keep normal line width
                    dataset.borderWidth = datasetIndex === 0 ? 3 : 2.5;
                });

                // Show and position the vertical crosshair line
                const chartOverlay = document.getElementById('chartOverlay');
                const chartCrosshair = document.getElementById('chartCrosshair');

                if (chartOverlay && chartCrosshair) {
                    const xScale = spendingChart.scales.x;
                    const pixelX = xScale.getPixelForValue(activeIndex);

                    // Position the crosshair at the selected point
                    chartCrosshair.style.left = `${pixelX}px`;
                    // Ensure overlay is visible immediately on interaction
                    chartOverlay.classList.add('visible');
                }

                spendingChart.update('none'); // Update without animation for immediate response
            }

            /**
             * Hides chart interaction effects (crosshair, tooltip) with a delay for better UX.
             */
            function hideChartInteraction() {
                if (!spendingChart || !spendingChart.data || !spendingChart.data.datasets) return;

                // Hide date display
                if (chartDateDisplay) {
                    chartDateDisplay.classList.remove('visible');
                }

                // Completely reset all data points to ensure no sticky dots
                spendingChart.data.datasets.forEach((dataset, datasetIndex) => {
                    // Reset all point properties to clean state
                    dataset.pointRadius = 0; // Hide all points
                    dataset.pointBackgroundColor = 'transparent';
                    dataset.pointBorderColor = 'transparent';
                    dataset.pointBorderWidth = 0;
                    dataset.borderWidth = datasetIndex === 0 ? 3 : 2.5; // Keep normal line width
                });

                // Hide the vertical crosshair line with a delay
                const chartOverlay = document.getElementById('chartOverlay');
                if (chartOverlay) {
                    setTimeout(() => {
                        chartOverlay.classList.remove('visible');
                    }, 200); // 200ms delay for smoother UX
                }
                spendingChart.update('none'); // Update without animation for immediate response
            }
        }

        // Global variables
        currentPeriodMode = 'month'; // or 'month'
        savingsAccounts = [];

        async function updateCategoryChart() {
            // Get expenses and filter by time range
            const expenses = await loadExpenses();
            const dateRange = getDateRangeForTimeRange(currentTimeRange);
            const startDate = dateRange.startDate;
            const endDate = dateRange.endDate;

            // Update time range label
            const timeRangeLabel = document.getElementById('categoryChartTimeRange');
            if (timeRangeLabel) {
                timeRangeLabel.textContent = getTimeRangeLabel(currentTimeRange);
            }

            // Filter expenses by date range
            const filteredExpenses = {};
            Object.keys(expenses).forEach(dateKey => {
                const date = new Date(dateKey);
                if (date >= startDate && date <= endDate) {
                    filteredExpenses[dateKey] = expenses[dateKey];
                }
            });

            // Calculate category totals
            const categoryTotals = {};
            Object.values(filteredExpenses).flat().forEach(expense => {
                const category = expense.category || 'Other';
                categoryTotals[category] = (categoryTotals[category] || 0) + expense.amount;
            });

            // Get top 6 categories
            const sortedCategories = Object.entries(categoryTotals)
                .sort(([, a], [, b]) => b - a)
                .slice(0, 6);

            // Prepare chart data
            const labels = sortedCategories.map(([category]) => category);
            const data = sortedCategories.map(([, total]) => total);
            const colors = [
                '#3b82f6', // blue
                '#ef4444', // red
                '#f59e0b', // amber
                '#10b981', // emerald
                '#8b5cf6', // violet
                '#f97316'  // orange
            ];

            // Get chart canvas
            const ctx = document.getElementById('categoryChart').getContext('2d');

            // Destroy existing chart if it exists
            if (categoryChart) {
                categoryChart.destroy();
            }

            // Create new chart
            categoryChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Spending',
                        data: data,
                        backgroundColor: colors.slice(0, labels.length),
                        borderColor: colors.slice(0, labels.length),
                        borderWidth: 1,
                        borderRadius: 8,
                        borderSkipped: false
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    resizeDelay: 0,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function (context) {
                                    return `$${context.parsed.y.toFixed(2)}`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            suggestedMax: data.length > 0 ? Math.max(...data) * 1.1 : 100, // Add 10% padding above highest value
                            ticks: {
                                callback: function (value) {
                                    return '$' + value.toFixed(0);
                                }
                            },
                            grid: {
                                color: 'rgba(0, 0, 0, 0.05)'
                            }
                        },
                        x: {
                            grid: {
                                display: false
                            },
                            ticks: {
                                maxRotation: 45,
                                minRotation: 0
                            }
                        }
                    }
                }
            });

            // Force resize after chart creation to ensure proper dimensions
            setTimeout(() => {
                if (categoryChart) {
                    categoryChart.resize();
                }
            }, 100);
        }

        let currentChartIndex = 0;
        let previousCategoryAmount = 0;

        function showChart(index) {
            const carousel = document.getElementById('chartCarousel');
            if (!carousel) return;

            // Move carousel to show selected chart
            const translateX = index * -50; // Each slide is 50% width
            carousel.style.transform = `translateX(${translateX}%)`;

            // Update dots
            const dots = document.querySelectorAll('.chart-dots .dot');
            dots.forEach((dot, i) => {
                if (i === index) {
                    dot.classList.add('active');
                } else {
                    dot.classList.remove('active');
                }
            });

            // Update slide active states
            const slides = document.querySelectorAll('.chart-slide');
            slides.forEach((slide, i) => {
                if (i === index) {
                    slide.classList.add('active');
                } else {
                    slide.classList.remove('active');
                }
            });

            currentChartIndex = index;

            // Initialize chart if needed
            if (index === 1 && typeof updateCategoryChart === 'function') {
                updateCategoryChart();
            }
        }

        function initializeChartSwipe() {
            // Look for the budgetDisplay chart carousel
            const budgetDisplay = document.getElementById('budgetDisplay');
            const carouselContainer = budgetDisplay ? budgetDisplay.querySelector('.chart-carousel') : null;
            if (!carouselContainer) {
                return;
            }

            let startX = 0;
            let startY = 0;
            let isScrolling = false;
            let hasSwiped = false;
            let isDragging = false;

            // Use document-level events to avoid interference from Chart.js
            function isInsideCarousel(x, y) {
                const rect = carouselContainer.getBoundingClientRect();
                return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;
            }

            document.addEventListener('mousedown', function (e) {
                if (isInsideCarousel(e.clientX, e.clientY)) {
                    isDragging = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    isScrolling = false;
                    hasSwiped = false;
                    carouselContainer.style.cursor = 'grabbing';
                    e.preventDefault();
                }
            });

            document.addEventListener('mousemove', function (e) {
                if (!isDragging || !startX || !startY) return;

                const currentX = e.clientX;
                const currentY = e.clientY;
                const diffX = startX - currentX;
                const diffY = startY - currentY;

                if (Math.abs(diffY) > Math.abs(diffX)) {
                    isScrolling = true;
                    return;
                }

                if (!isScrolling && !hasSwiped && Math.abs(diffX) > 50) {
                    hasSwiped = true;
                    if (diffX > 0 && currentChartIndex < 1) {
                        switchToChart(currentChartIndex + 1);
                    } else if (diffX < 0 && currentChartIndex > 0) {
                        switchToChart(currentChartIndex - 1);
                    }
                }
            });

            document.addEventListener('mouseup', function () {
                if (isDragging) {
                    isDragging = false;
                    startX = 0;
                    startY = 0;
                    isScrolling = false;
                    hasSwiped = false;
                    carouselContainer.style.cursor = 'grab';
                }
            });

            // Touch events for mobile
            function handleTouchStart(e) {
                startX = e.touches[0].clientX;
                startY = e.touches[0].clientY;
                isScrolling = false;
                hasSwiped = false;
            }

            carouselContainer.addEventListener('touchstart', handleTouchStart);

            // Note: budgetDisplay uses bar charts, not a canvas, so we only need container events

            function handleTouchMove(e) {
                if (!startX || !startY) return;

                const currentX = e.touches[0].clientX;
                const currentY = e.touches[0].clientY;
                const diffX = startX - currentX;
                const diffY = startY - currentY;


                // Determine scroll direction
                if (Math.abs(diffY) > Math.abs(diffX)) {
                    isScrolling = true;
                    return;
                }

                // Prevent default to stop scrolling during horizontal swipe
                if (!isScrolling && Math.abs(diffX) > 20) {
                    e.preventDefault();
                }

                // Trigger swipe on sufficient horizontal movement
                if (!isScrolling && !hasSwiped && Math.abs(diffX) > 50) {
                    hasSwiped = true;
                    if (diffX > 0 && currentChartIndex < 1) {
                        switchToChart(currentChartIndex + 1);
                    } else if (diffX < 0 && currentChartIndex > 0) {
                        switchToChart(currentChartIndex - 1);
                    }
                }
            }

            carouselContainer.addEventListener('touchmove', handleTouchMove, { passive: false });

            function handleTouchEnd() {
                startX = 0;
                startY = 0;
                isScrolling = false;
                hasSwiped = false;
            }

            carouselContainer.addEventListener('touchend', handleTouchEnd);

            // Add document click listener to clear selections when clicking outside charts
            // Only add this listener when we're on the spending page (screen 1)
            let chartClickListener = null;
            
            function addChartClickListener() {
                if (chartClickListener) return; // Prevent duplicate listeners
                
                chartClickListener = function (e) {
                    // Only handle clicks when on spending screen
                    if (currentScreen !== 1) return;
                    
                    // Check if click is outside both chart containers
                    const monthlyChart = document.getElementById('monthlySpendingChart');
                    const categoryChart = document.getElementById('categorySpendingChart');

                    if (monthlyChart && categoryChart) {
                        const isInsideMonthly = monthlyChart.contains(e.target);
                        const isInsideCategory = categoryChart.contains(e.target);

                        if (!isInsideMonthly && !isInsideCategory) {
                            clearChartSelections().catch(console.error);
                        }
                    }
                };
                
                document.addEventListener('click', chartClickListener);
            }
            
            function removeChartClickListener() {
                if (chartClickListener) {
                    document.removeEventListener('click', chartClickListener);
                    chartClickListener = null;
                }
            }
            
            // Add listener initially if on spending screen
            if (currentScreen === 1) {
                addChartClickListener();
            }
            
            // Store functions globally so they can be called when navigating screens
            window.addChartClickListener = addChartClickListener;
            window.removeChartClickListener = removeChartClickListener;
        }

        function getCurrentPeriodKey() {
            if (currentPeriodMode === 'today') {
                return getCurrentDate();
            } else {
                return `${selectedMonthDate.getFullYear()}-${String(selectedMonthDate.getMonth() + 1).padStart(2, '0')}`;
            }
        }

        function getCurrentMonth() {
            // Hard-coded date for consistency: July 7, 2025
            const now = new Date(2025, 6, 7); // Month is 0-indexed (6 = July)
            return `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
        }

        function getSelectedSaveMonthKey() {
            // Ensure the month is zero-padded (e.g., "01" for January, not "1")
            const month = String(selectedSaveMonthDate.getMonth() + 1).padStart(2, '0');
            const year = selectedSaveMonthDate.getFullYear();
            const key = `${year}-${month}`;
            return key;
        }

        function isCurrentMonth() {
            const now = new Date(2025, 6, 7); // Hard-coded to July 7, 2025
            return selectedMonthDate.getMonth() === now.getMonth() &&
                selectedMonthDate.getFullYear() === now.getFullYear();
        }

        async function loadExpenses() {
            try {
                // Get Clerk session token
                const sessionToken = await window.plaidService.getClerkSessionToken();
                
                // Fetch transactions from database
                const response = await fetch(`${window.plaidService.baseUrl}/api/transactions`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${sessionToken}`,
                    }
                });

                if (!response.ok) {
                    throw new Error(`Failed to load transactions: ${response.status}`);
                }

                const data = await response.json();
                
                // Convert transactions to the expenses format expected by the app
                const expenses = {};
                
                if (data.transactions && Array.isArray(data.transactions)) {
                    data.transactions.forEach(transaction => {
                        // Only include expense transactions (positive amounts in the database are expenses/outgoing)
                        if (transaction.amount > 0) {
                            const date = transaction.date;
                            if (!expenses[date]) {
                                expenses[date] = [];
                            }
                            
                            expenses[date].push({
                                amount: transaction.amount,
                                category: transaction.category || 'other',
                                description: transaction.description || transaction.name,
                                timestamp: new Date(transaction.date).getTime(),
                                created: new Date(transaction.created_at).getTime(),
                                updated: new Date(transaction.updated_at).getTime()
                            });
                        }
                    });
                }
                
                return expenses;
            } catch (error) {
                console.error('Error loading expenses from database:', error);
                return {}; // Return empty object if error
            }
        }

        // Monthly spending chart functions
        async function calculateMonthlySpending() {
            const expenses = await loadExpenses();
            const monthlyTotals = {};

            // Initialize months from January to current month
            const currentDate = new Date();
            const currentYear = currentDate.getFullYear();
            const currentMonth = currentDate.getMonth();

            for (let month = 0; month <= currentMonth; month++) {
                const key = `${currentYear}-${month}`;
                monthlyTotals[key] = 0;
            }

            // Calculate totals for each month
            Object.keys(expenses).forEach(dateKey => {
                const date = new Date(dateKey);
                if (date.getFullYear() === currentYear && date.getMonth() <= currentMonth) {
                    const monthKey = `${date.getFullYear()}-${date.getMonth()}`;
                    const dayExpenses = expenses[dateKey];
                    const dayTotal = dayExpenses.reduce((sum, expense) => sum + (expense.amount || 0), 0);
                    monthlyTotals[monthKey] += dayTotal;
                }
            });

            return monthlyTotals;
        }

        async function generateMonthlyChart() {
            const chartContainer = document.getElementById('monthlySpendingChart');
            if (!chartContainer) {
                console.error('Monthly chart container not found!');
                return;
            }

            const monthlyTotals = await calculateMonthlySpending();
            const currentDate = new Date();
            const currentMonth = currentDate.getMonth();
            const currentYear = currentDate.getFullYear();

            // Clear existing content
            chartContainer.innerHTML = '';

            // Find max value for scaling
            const maxValue = Math.max(...Object.values(monthlyTotals), 1);

            // Month names
            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

            // Generate bars for each month
            for (let month = 0; month <= currentMonth; month++) {
                const monthKey = `${currentYear}-${month}`;
                const amount = monthlyTotals[monthKey] || 0;
                const height = Math.max((amount / maxValue) * 100, 10); // Min height 10px

                const chartBar = document.createElement('div');
                chartBar.className = 'chart-bar spending-bar';
                chartBar.dataset.month = month;
                chartBar.dataset.year = currentYear;

                // Add current month class (but don't auto-select)
                if (month === currentMonth) {
                    chartBar.classList.add('current-month');
                }
                // Only add selected class if month was manually selected
                if (selectedMonth !== null && month === selectedMonth && currentYear === selectedYear) {
                    chartBar.classList.add('selected');
                }

                // Month label
                const barAmount = document.createElement('div');
                barAmount.className = 'bar-amount';
                barAmount.textContent = monthNames[month];

                // Bar visual
                const barVisual = document.createElement('div');
                barVisual.className = 'bar-visual spending-visual';
                if (amount <= 0) {
                    barVisual.classList.add('zero-or-negative');
                }
                barVisual.style.height = `${height}px`;

                // Click handler for month selection
                chartBar.onclick = async (event) => {
                    event.preventDefault();
                    event.stopPropagation();
                    await selectChartMonth(month, currentYear);
                };

                chartBar.appendChild(barVisual);
                chartBar.appendChild(barAmount);
                chartContainer.appendChild(chartBar);
            }

            // Show current month total by default (but don't select the bar)
            const currentMonthKey = `${currentYear}-${currentMonth}`;
            const currentMonthTotal = monthlyTotals[currentMonthKey] || 0;
            previousTotal = currentMonthTotal;

            // Update display to show current month amount
            const totalElement = document.getElementById('selectedMonthTotal');
            if (totalElement) {
                const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
                totalElement.innerHTML = `
                        <span class="month-name">${monthNames[currentMonth]} ${currentYear}</span>
                        <span class="month-amount ${currentMonthTotal <= 0 ? 'zero-or-negative' : ''}">$${currentMonthTotal.toFixed(2)}</span>
                    `;
            }

            // Scroll to current month
            scrollToCurrentMonth();
        }

        async function selectChartMonth(month, year) {
            selectedMonth = month;
            selectedYear = year;

            const chartContainer = document.getElementById('monthlySpendingChart');
            const chartBars = document.querySelectorAll('#monthlySpendingChart .chart-bar');

            // Add has-selection class to container for fade effect
            chartContainer.classList.add('has-selection');

            // Update selected state
            chartBars.forEach(bar => {
                bar.classList.remove('selected');
                if (parseInt(bar.dataset.month) === month && parseInt(bar.dataset.year) === year) {
                    bar.classList.add('selected');
                }
            });

            // Update total display only (don't trigger other updates)
            await updateSelectedMonthTotal();
        }

        function animateCountUp(element, startValue, endValue, duration = 300) {
            const startTime = performance.now();
            const difference = endValue - startValue;

            function updateCount(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);

                // Use easeOutQuad for more subtle animation
                const easeProgress = 1 - Math.pow(1 - progress, 2);
                const currentValue = startValue + (difference * easeProgress);

                element.textContent = `$${currentValue.toFixed(2)}`;

                if (progress < 1) {
                    requestAnimationFrame(updateCount);
                }
            }

            requestAnimationFrame(updateCount);
        }

        async function updateSelectedMonthTotal() {
            const monthlyTotals = await calculateMonthlySpending();
            const monthKey = `${selectedYear}-${selectedMonth}`;
            const total = monthlyTotals[monthKey] || 0;

            const totalElement = document.getElementById('selectedMonthTotal');
            if (totalElement) {
                const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];

                // Update the month name immediately
                totalElement.innerHTML = `
                        <span class="month-name">${monthNames[selectedMonth]} ${selectedYear}</span>
                        <span class="month-amount ${total <= 0 ? 'zero-or-negative' : ''}" id="animatedAmount">$${previousTotal.toFixed(2)}</span>
                    `;

                // Animate the amount
                const amountElement = document.getElementById('animatedAmount');
                if (amountElement) {
                    animateCountUp(amountElement, previousTotal, total);
                }


                // Update previous total for next animation
                previousTotal = total;
            } else {
                console.error('selectedMonthTotal element not found!');
            }
        }

        function scrollToCurrentMonth() {
            const chartContainer = document.getElementById('monthlySpendingChart');
            const currentMonthBar = chartContainer.querySelector('.chart-bar.current-month');

            if (currentMonthBar && chartContainer) {
                // Scroll to show current month in center
                const containerWidth = chartContainer.offsetWidth;
                const barOffsetLeft = currentMonthBar.offsetLeft;
                const barWidth = currentMonthBar.offsetWidth;
                const scrollPosition = barOffsetLeft - (containerWidth / 2) + (barWidth / 2);

                chartContainer.scrollLeft = Math.max(0, scrollPosition);
            }
        }

        function switchToChart(index) {
            currentChartIndex = index;

            // Find the budgetDisplay carousel specifically 
            const budgetDisplay = document.getElementById('budgetDisplay');
            const carousel = budgetDisplay ? budgetDisplay.querySelector('.chart-carousel') : null;

            if (carousel) {
                // Transform the carousel
                const translateX = index * -50; // Each slide is 50% width
                carousel.style.transform = `translateX(${translateX}%)`;
            }

            // Update subtitle based on current chart
            const subtitle = budgetDisplay ? budgetDisplay.querySelector('.section-subtitle') : null;
            if (subtitle) {
                subtitle.textContent = index === 0 ? 'Monthly Overview' : 'Category Spending';
            }

            // Update dots in budgetDisplay
            const dots = budgetDisplay ? budgetDisplay.querySelectorAll('.chart-dots .dot') : [];
            dots.forEach((dot, i) => {
                dot.classList.toggle('active', i === index);
            });

            // Update slide active states in budgetDisplay
            const slides = budgetDisplay ? budgetDisplay.querySelectorAll('.chart-slide') : [];
            slides.forEach((slide, i) => {
                slide.classList.toggle('active', i === index);
            });

            // Generate appropriate chart content
            if (index === 1) {
                generateCategoryChart();
            }
        }

        async function generateCategoryChart() {
            const chartContainer = document.getElementById('categorySpendingChart');
            if (!chartContainer) return;

            const expenses = await loadExpenses();
            const categoryTotals = {};

            // Calculate category totals for the selected time range
            const { startDate, endDate } = getDateRangeForTimeRange(currentTimeRange);
            const startDateStr = startDate.toISOString().split('T')[0];
            const endDateStr = endDate.toISOString().split('T')[0];

            Object.keys(expenses).forEach(dateKey => {
                if (dateKey >= startDateStr && dateKey <= endDateStr) {
                    const dayExpenses = expenses[dateKey];
                    dayExpenses.forEach(expense => {
                        const category = expense.category || 'other';
                        categoryTotals[category] = (categoryTotals[category] || 0) + (expense.amount || 0);
                    });
                }
            });

            // Get top 6 categories
            const sortedCategories = Object.entries(categoryTotals)
                .sort(([, a], [, b]) => b - a)
                .slice(0, 6);

            // Clear existing content
            chartContainer.innerHTML = '';

            if (sortedCategories.length === 0) {
                chartContainer.innerHTML = '<div style="text-align: center; color: hsl(var(--muted-foreground)); padding: 40px;">No spending data for this period</div>';
                return;
            }

            // Category CSS class mapping
            const categoryClasses = [
                'food',          // Orange
                'transportation', // Blue  
                'health',        // Green
                'entertainment', // Purple
                'shopping',      // Amber -> Red (swapped)
                'utilities',     // Red -> Orange (swapped)
                'other'          // Gray
            ];

            // Find max value for scaling
            const maxValue = Math.max(...sortedCategories.map(([, amount]) => amount), 1);

            // Generate bars for each category
            sortedCategories.forEach(([category, amount], index) => {
                const height = Math.max((amount / maxValue) * 100, 10);
                const categoryClass = categoryClasses[index % categoryClasses.length];

                const chartBar = document.createElement('div');
                chartBar.className = 'chart-bar category-bar';
                chartBar.dataset.category = category;

                // Category icon (using emoji for now)
                const barAmount = document.createElement('div');
                barAmount.className = 'bar-amount';
                barAmount.innerHTML = `<span class="bar-amount-icon">${getCategoryEmoji(category)}</span>`;

                // Bar visual
                const barVisual = document.createElement('div');
                barVisual.className = `bar-visual category-visual ${categoryClass}`;
                barVisual.style.height = `${height}px`;

                // Click handler for category selection
                chartBar.onclick = (event) => {
                    event.preventDefault();
                    event.stopPropagation();
                    selectCategory(category, amount);
                };

                chartBar.appendChild(barVisual);
                chartBar.appendChild(barAmount);
                chartContainer.appendChild(chartBar);
            });

            // Update category total display
            await updateSelectedCategoryTotal();

            // Initialize Lucide icons for the new category icons
            if (window.safeInitLucideIcons) {
                window.safeInitLucideIcons();
            }
        }

        function fadeChartUpdate(chartContainer, updateFunction) {
            if (!chartContainer) return;

            // Start fade out
            chartContainer.classList.add('chart-fade-transition');

            // After fade out, update content and fade back in
            setTimeout(() => {
                updateFunction();
                chartContainer.classList.add('chart-fade-in');

                // Remove classes after animation
                setTimeout(() => {
                    chartContainer.classList.remove('chart-fade-transition', 'chart-fade-in');
                }, 200);
            }, 100); // Half the transition time for smooth crossfade
        }

        function slideChartUpdate(chartContainer, updateFunction) {
            if (!chartContainer) return;

            // Start slide out to right
            chartContainer.classList.add('chart-fade-slide-out');

            // After slide out, update content and slide in from left
            setTimeout(() => {
                updateFunction();
                chartContainer.classList.remove('chart-fade-slide-out');
                chartContainer.classList.add('chart-fade-slide-in');

                // Remove classes after animation
                setTimeout(() => {
                    chartContainer.classList.remove('chart-fade-slide-in');
                }, 300);
            }, 300); // Wait for slide out animation to complete
        }

        function staggeredBarUpdate(chartContainer, updateFunction) {
            if (!chartContainer) return;

            // Update content immediately
            updateFunction();

            // Apply staggered animation to all chart bars
            const chartBars = chartContainer.querySelectorAll('.chart-bar');
            chartBars.forEach((bar, index) => {
                // Set initial state
                bar.style.opacity = '0';

                // Apply staggered animation with delay
                setTimeout(() => {
                    bar.classList.add('chart-bar-stagger-in');

                    // Clean up class after animation
                    setTimeout(() => {
                        bar.classList.remove('chart-bar-stagger-in');
                        bar.style.opacity = '';
                    }, 300);
                }, index * 40); // 40ms delay between each bar
            });
        }

        function getCategoryColorFromBar(categoryBar) {
            // Get the category visual element to determine its CSS class
            const categoryVisual = categoryBar.querySelector('.category-visual');
            if (!categoryVisual) return '#6b7280';

            // Map CSS classes to their corresponding colors
            const classColorMap = {
                'food': '#f59e0b',
                'transportation': '#3b82f6',
                'health': '#10b981',
                'entertainment': '#8b5cf6',
                'shopping': '#ef4444',
                'utilities': '#f97316',
                'other': '#6b7280'
            };

            // Check which category class this visual has
            for (const cssClass of Object.keys(classColorMap)) {
                if (categoryVisual.classList.contains(cssClass)) {
                    return classColorMap[cssClass];
                }
            }

            return '#6b7280'; // default color
        }

        function selectCategory(category, amount) {
            const chartContainer = document.getElementById('categorySpendingChart');
            const chartBars = document.querySelectorAll('#categorySpendingChart .chart-bar');

            // Add has-selection class to container for fade effect
            chartContainer.classList.add('has-selection');

            // Update selected state and icon colors
            chartBars.forEach(bar => {
                bar.classList.remove('selected');
                const barIcon = bar.querySelector('.bar-amount-icon svg');
                if (bar.dataset.category === category) {
                    bar.classList.add('selected');
                    // Change icon color to match the actual bar color
                    if (barIcon) {
                        const color = getCategoryColorFromBar(bar);
                        barIcon.style.setProperty('color', color, 'important');
                    }
                } else {
                    // Reset other icons to default color
                    if (barIcon) {
                        barIcon.style.color = '';
                    }
                }
            });

            // Update total display with animation
            const totalElement = document.getElementById('selectedCategoryTotal');
            if (totalElement) {
                const categoryName = category.charAt(0).toUpperCase() + category.slice(1).replace('_', ' ');
                totalElement.innerHTML = `
                        <span class="month-name">${categoryName}</span>
                        <span class="month-amount ${amount <= 0 ? 'zero-or-negative' : ''}" id="animatedCategoryAmount">$${previousCategoryAmount.toFixed(2)}</span>
                    `;

                // Animate the amount
                const amountElement = document.getElementById('animatedCategoryAmount');
                if (amountElement) {
                    animateCountUp(amountElement, previousCategoryAmount, amount);
                }

                previousCategoryAmount = amount;
            }
        }

        function calculateTotalSpending(expenses) {
            return expenses.reduce((total, expense) => total + parseFloat(expense.amount || 0), 0);
        }

        async function clearChartSelections() {
            // Only clear selections if charts actually have selections
            const monthlyContainer = document.getElementById('monthlySpendingChart');
            const categoryContainer = document.getElementById('categorySpendingChart');
            
            const hasMonthlySelection = monthlyContainer && monthlyContainer.classList.contains('has-selection');
            const hasCategorySelection = categoryContainer && categoryContainer.classList.contains('has-selection');
            
            // If no selections exist, don't make any API calls
            if (!hasMonthlySelection && !hasCategorySelection) {
                return;
            }
            
            // Load expenses data only once for both charts
            const expenses = await loadExpenses();
            
            // Clear monthly chart selection
            const monthlyBars = document.querySelectorAll('#monthlySpendingChart .chart-bar');
            if (hasMonthlySelection && monthlyContainer) {
                monthlyContainer.classList.remove('has-selection');
                monthlyBars.forEach(bar => bar.classList.remove('selected'));

                // Reset selected month/year to null so next selection animates properly
                selectedMonth = null;
                selectedYear = null;

                // Show current month + year by default
                const totalElement = document.getElementById('selectedMonthTotal');
                if (totalElement) {
                    const currentDate = new Date();
                    const currentMonth = currentDate.getMonth();
                    const currentYear = currentDate.getFullYear();
                    const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];

                    // Calculate monthly totals from the already loaded expenses
                    const monthlyTotals = {};
                    for (let month = 0; month <= currentMonth; month++) {
                        monthlyTotals[`${currentYear}-${month}`] = 0;
                    }
                    
                    Object.keys(expenses).forEach(dateKey => {
                        const date = new Date(dateKey);
                        if (date.getFullYear() === currentYear && date.getMonth() <= currentMonth) {
                            const monthKey = `${date.getFullYear()}-${date.getMonth()}`;
                            const dayExpenses = expenses[dateKey];
                            const dayTotal = dayExpenses.reduce((sum, expense) => sum + (expense.amount || 0), 0);
                            monthlyTotals[monthKey] += dayTotal;
                        }
                    });
                    
                    const currentMonthKey = `${currentYear}-${currentMonth}`;
                    const currentMonthTotal = monthlyTotals[currentMonthKey] || 0;

                    totalElement.innerHTML = `
                            <span class="month-name">${monthNames[currentMonth]} ${currentYear}</span>
                            <span class="month-amount ${currentMonthTotal <= 0 ? 'zero-or-negative' : ''}" id="animatedAmount">$${previousTotal.toFixed(2)}</span>
                        `;

                    // Animate to current month total
                    const amountElement = document.getElementById('animatedAmount');
                    if (amountElement) {
                        animateCountUp(amountElement, previousTotal, currentMonthTotal);
                    }

                    previousTotal = currentMonthTotal;
                }
            }

            // Clear category chart selection
            const categoryBars = document.querySelectorAll('#categorySpendingChart .chart-bar');
            if (hasCategorySelection && categoryContainer) {
                categoryContainer.classList.remove('has-selection');
                categoryBars.forEach(bar => {
                    bar.classList.remove('selected');
                    // Reset icon color to default
                    const barIcon = bar.querySelector('.bar-amount-icon svg');
                    if (barIcon) {
                        barIcon.style.color = '';
                    }
                });

                // Show total spend for displayed categories with animation
                const totalElement = document.getElementById('selectedCategoryTotal');
                if (totalElement) {
                    // Calculate category totals using the already loaded expenses
                    const categoryTotals = {};

                    // Calculate category totals for the selected time range
                    const { startDate, endDate } = getDateRangeForTimeRange(currentTimeRange);
                    const startDateStr = startDate.toISOString().split('T')[0];
                    const endDateStr = endDate.toISOString().split('T')[0];

                    Object.keys(expenses).forEach(dateKey => {
                        if (dateKey >= startDateStr && dateKey <= endDateStr) {
                            const dayExpenses = expenses[dateKey];
                            dayExpenses.forEach(expense => {
                                const category = expense.category || 'other';
                                categoryTotals[category] = (categoryTotals[category] || 0) + (expense.amount || 0);
                            });
                        }
                    });

                    // Sum ALL categories for the time range, not just the displayed ones
                    const totalCategorySpend = Object.values(categoryTotals).reduce((sum, amount) => sum + amount, 0);

                    totalElement.innerHTML = `
                            <span class="month-name">Total Spend</span>
                            <span class="month-amount ${totalCategorySpend <= 0 ? 'zero-or-negative' : ''}" id="animatedCategoryAmount">$${previousCategoryAmount.toFixed(2)}</span>
                        `;

                    // Animate to total category spend
                    const amountElement = document.getElementById('animatedCategoryAmount');
                    if (amountElement) {
                        animateCountUp(amountElement, previousCategoryAmount, totalCategorySpend);
                    }

                    previousCategoryAmount = totalCategorySpend;
                }
            }
        }

        async function updateSelectedCategoryTotal() {
            // Show total spend for displayed categories by default
            const totalElement = document.getElementById('selectedCategoryTotal');
            if (totalElement) {
                // Calculate total for just the categories displayed in the chart (same logic as clearChartSelections)
                const expenses = await loadExpenses();
                const categoryTotals = {};

                // Calculate category totals for the selected time range
                const { startDate, endDate } = getDateRangeForTimeRange(currentTimeRange);
                const startDateStr = startDate.toISOString().split('T')[0];
                const endDateStr = endDate.toISOString().split('T')[0];

                Object.keys(expenses).forEach(dateKey => {
                    if (dateKey >= startDateStr && dateKey <= endDateStr) {
                        const dayExpenses = expenses[dateKey];
                        dayExpenses.forEach(expense => {
                            const category = expense.category || 'other';
                            categoryTotals[category] = (categoryTotals[category] || 0) + (expense.amount || 0);
                        });
                    }
                });

                // Sum ALL categories for the time range, not just the displayed ones
                const totalCategorySpend = Object.values(categoryTotals).reduce((sum, amount) => sum + amount, 0);

                totalElement.innerHTML = `
                        <span class="month-name">Total Spend</span>
                        <span class="month-amount ${totalCategorySpend <= 0 ? 'zero-or-negative' : ''}">$${totalCategorySpend.toFixed(2)}</span>
                    `;

                // Initialize previous amount for animations
                previousCategoryAmount = totalCategorySpend;
            }
        }

        async function updateSelectedCategoryTotalOld() {
            // Show total for first category by default
            const firstBar = document.querySelector('#categorySpendingChart .chart-bar');
            if (firstBar) {
                const category = firstBar.dataset.category;
                const expenses = await loadExpenses();
                const categoryTotals = {};

                // Recalculate for selected time range
                const { startDate, endDate } = getDateRangeForTimeRange(currentTimeRange);
                const startDateStr = startDate.toISOString().split('T')[0];
                const endDateStr = endDate.toISOString().split('T')[0];

                Object.keys(expenses).forEach(dateKey => {
                    if (dateKey >= startDateStr && dateKey <= endDateStr) {
                        const dayExpenses = expenses[dateKey];
                        dayExpenses.forEach(expense => {
                            const expenseCategory = expense.category || 'other';
                            categoryTotals[expenseCategory] = (categoryTotals[expenseCategory] || 0) + (expense.amount || 0);
                        });
                    }
                });

                const amount = categoryTotals[category] || 0;
                selectCategory(category, amount);
            }
        }

        function initializeMonthPicker() {
            initializeDateDropdowns();
        }

        function initializeDateDropdowns() {
            const yearDropdown = document.getElementById('yearDropdown');
            if (!yearDropdown) return;

            yearDropdown.innerHTML = '';

            // Generate years (2 years back to current year)
            const currentYear = new Date(2025, 6, 7).getFullYear(); // Hard-coded to July 7, 2025
            for (let year = currentYear - 2; year <= currentYear; year++) {
                const option = document.createElement('option');
                option.value = year;
                option.textContent = year;
                if (year === selectedMonthDate.getFullYear()) {
                    option.selected = true;
                }
                yearDropdown.appendChild(option);
            }

            // Set month dropdown
            const monthDropdown = document.getElementById('monthDropdown');
            if (monthDropdown) {
                monthDropdown.value = selectedMonthDate.getMonth();
            }

            // Add event listeners
            yearDropdown.addEventListener('change', async (e) => {
                selectedMonthDate.setFullYear(parseInt(e.target.value));
                await updatePeriodView();
            });

            monthDropdown.addEventListener('change', async (e) => {
                selectedMonthDate.setMonth(parseInt(e.target.value));
                await updatePeriodView();
            });
        }

        function selectMonth(date) {
            selectedMonthDate = new Date(date);

            // Update dropdowns
            const monthDropdown = document.getElementById('monthDropdown');
            const yearDropdown = document.getElementById('yearDropdown');
            if (monthDropdown) monthDropdown.value = date.getMonth();
            if (yearDropdown) yearDropdown.value = date.getFullYear();

            setDefaultDatePicker();
            setDefaultBalanceDate();
            updatePeriodView();
        }

        function scrollToSelectedMonth() {
            // Not needed for compressed design
        }

        function updateAccountSelector() {
            const balanceAccountSelect = document.getElementById('balanceAccount');

            if (balanceAccountSelect) {
                balanceAccountSelect.innerHTML = '';

                // Add account options for balance input
                savingsAccounts.forEach(account => {
                    const option = document.createElement('option');
                    option.value = account.id;
                    option.textContent = account.name;
                    balanceAccountSelect.appendChild(option);
                });
            }

            // Also update slide-out dropdown
            updateSlideOutAccountDropdown();

            updateTotalSavingsDisplay();
        }

        function updateSlideOutAccountDropdown() {
            const balanceAccountContent = document.getElementById('balanceAccountContent');
            const slideOutBalanceAccount = document.getElementById('slideOutBalanceAccount');

            if (balanceAccountContent && slideOutBalanceAccount) {
                // Clear existing options
                balanceAccountContent.innerHTML = '';
                slideOutBalanceAccount.innerHTML = '';

                // No default accounts - user must add accounts manually or use sample data

                // Add account options
                savingsAccounts.forEach((account, index) => {
                    // Add to custom dropdown
                    const item = document.createElement('div');
                    item.className = 'select-item';
                    if (index === 0) item.classList.add('selected');
                    item.setAttribute('data-value', account.id);
                    item.textContent = account.name;

                    // Add click handler
                    item.addEventListener('click', function () {
                        selectSlideOutOption('balanceAccount', account.id, account.name);
                    });

                    balanceAccountContent.appendChild(item);

                    // Add to hidden select
                    const option = document.createElement('option');
                    option.value = account.id;
                    option.textContent = account.name;
                    if (index === 0) option.selected = true;
                    slideOutBalanceAccount.appendChild(option);
                });

                // Update displayed value
                const balanceAccountValue = document.getElementById('balanceAccountValue');
                if (balanceAccountValue && savingsAccounts.length > 0) {
                    balanceAccountValue.textContent = savingsAccounts[0].name;
                }
            }
        }


        function updateTotalSavingsDisplay() {
            const balances = loadAccountBalances();
            const periodKey = getCurrentPeriodKey();
            let totalBalance = 0;
            let accountsWithBalances = 0;


            // Calculate total balance across all accounts for current period
            Object.keys(balances).forEach(accountId => {
                const accountBalances = balances[accountId] || {};
                let periodBalances;

                if (currentPeriodMode === 'today') {
                    // For today mode, look for exact date match
                    periodBalances = Object.keys(accountBalances)
                        .filter(date => date === periodKey)
                        .sort()
                        .reverse();
                } else {
                    // For month mode, look for dates starting with month key
                    periodBalances = Object.keys(accountBalances)
                        .filter(date => date.startsWith(periodKey))
                        .sort()
                        .reverse();
                }


                if (periodBalances.length > 0) {
                    const accountBalance = accountBalances[periodBalances[0]];
                    totalBalance += accountBalance;
                    accountsWithBalances++;
                }
            });


            // Update total balance display
            const totalBalanceElement = document.getElementById('totalAccountBalance');
            if (totalBalanceElement) {
                totalBalanceElement.textContent = formatCurrency(totalBalance);
            }

            const changeElement = document.getElementById('totalBalanceChange');
            if (changeElement) {
                const periodText = currentPeriodMode === 'today' ? 'today' : 'this month';
                changeElement.textContent = `Total across ${accountsWithBalances} account${accountsWithBalances !== 1 ? 's' : ''} ${periodText}`;
            }

            // Update balance history
            updateBalanceHistory();
        }

        function updateBalanceHistory() {
            const balances = loadAccountBalances();
            const periodKey = getCurrentPeriodKey();
            const periodBalances = [];
            // Get all balances for the selected period
            Object.keys(balances).forEach(accountId => {
                const accountBalances = balances[accountId] || {};
                Object.keys(accountBalances).forEach(date => {
                    let shouldInclude = false;
                    if (currentPeriodMode === 'today') {
                        // For today mode, include exact date match only
                        shouldInclude = date === periodKey;
                    } else {
                        // For month mode, include dates starting with month key
                        shouldInclude = date.startsWith(periodKey);
                    }
                    if (shouldInclude) {
                        periodBalances.push({
                            date: date,
                            accountId: accountId,
                            accountName: savingsAccounts.find(acc => acc.id === accountId)?.name || accountId,
                            balance: accountBalances[date]
                        });
                    }
                });
            });
            const historyContainer = document.getElementById('balanceHistory');
            if (!historyContainer) return;
            if (periodBalances.length === 0) {
                const periodText = currentPeriodMode === 'today' ? 'today' : 'this month';
                historyContainer.innerHTML = `<div style="text-align: center; color: #7f8c8d; padding: 20px;">No balance records ${periodText}</div>`;
            } else {
                if (currentPeriodMode === 'month') {
                    // ... existing month view code ...
                    const grouped = {};
                    periodBalances.forEach(item => {
                        if (!grouped[item.accountId]) grouped[item.accountId] = [];
                        grouped[item.accountId].push(item);
                    });
                    historyContainer.innerHTML = Object.keys(grouped).map(accountId => {
                        const accountName = grouped[accountId][0].accountName;
                        const balancesList = grouped[accountId]
                            .sort((a, b) => {
                                // Sort by date (desc), then by created (asc) for stability
                                const dateA = a.date.split('-').map(Number);
                                const dateB = b.date.split('-').map(Number);
                                const dateObjA = new Date(dateA[0], dateA[1] - 1, dateA[2]);
                                const dateObjB = new Date(dateB[0], dateB[1] - 1, dateB[2]);

                                if (dateObjA.getTime() !== dateObjB.getTime()) {
                                    return dateObjB - dateObjA; // latest date first
                                }

                                // If same date, sort by created timestamp for stability
                                const createdA = a.created || new Date(a.date).getTime();
                                const createdB = b.created || new Date(b.date).getTime();
                                return createdA - createdB;
                            })
                            .map((item, idx, arr) => {
                                const dateParts = item.date.split('-').map(Number);
                                const dateObj = new Date(dateParts[0], dateParts[1] - 1, dateParts[2]);
                                const formattedDate = dateObj.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });
                                // Calculate percent change vs previous entry in this month
                                let percentChange = null;
                                let arrow = '';
                                if (idx > 0) {
                                    const prev = arr[idx - 1];
                                    if (prev && prev.balance !== 0) {
                                        percentChange = ((item.balance - prev.balance) / prev.balance) * 100;
                                        if (percentChange > 0.01) {
                                            arrow = '<i data-lucide="arrow-up-right" class="balance-arrow positive"></i>';
                                        } else if (percentChange < -0.01) {
                                            arrow = '<i data-lucide="arrow-down-right" class="balance-arrow negative"></i>';
                                        } else {
                                            arrow = '<i data-lucide="arrow-right" class="balance-arrow neutral"></i>';
                                        }
                                    }
                                }
                                return `
                                        <div class="swipe-container" data-type="balance" data-account-id="${item.accountId}" data-date="${item.date}">
                                            <div class="swipe-content">
                                                <div class="modern-balance-history-item">
                                                    <div class="balance-history-date">${formattedDate}</div>
                                                    <div class="balance-history-right">
                                                        <div class="balance-history-amount">${formatCurrency(item.balance)}</div>
                                                        ${percentChange !== null ? `<div class="balance-history-percent ${percentChange > 0 ? 'positive' : percentChange < 0 ? 'negative' : 'neutral'}">${arrow}${percentChange > 0 ? '+' : ''}${percentChange.toFixed(2)}%</div>` : ''}
                                                    </div>
                                                    <button class="delete-balance-btn" onclick="handleBalanceDelete(this); return false;"><i data-lucide="x" class="w-4 h-4"></i></button>
                                                </div>
                                            </div>
                                            <div class="swipe-action" onclick="handleBalanceDelete(this); event.stopPropagation(); return false;"><i data-lucide="x" class="w-4 h-4"></i></div>
                                        </div>
                                    `;
                            }).join('');
                        return `<div style="margin-bottom:1.5rem;"><div style="font-weight:600;font-size:1rem;margin-bottom:0.5rem;">${accountName}</div>${balancesList}</div>`;
                    }).join('');
                } else {
                    // Today view: only show today's records
                    historyContainer.innerHTML = periodBalances.map(item => {
                        const dateParts = item.date.split('-').map(Number);
                        const dateObj = new Date(dateParts[0], dateParts[1] - 1, dateParts[2]);
                        const formattedDate = dateObj.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                        return `
                                <div class="swipe-container" data-type="balance" data-account-id="${item.accountId}" data-date="${item.date}">
                                    <div class="swipe-content">
                                        <div class="balance-item">
                                            <div class="balance-details">
                                                <div class="balance-date">${formattedDate}</div>
                                                <div class="balance-account">${item.accountName}</div>
                                            </div>
                                            <div class="balance-amount">${formatCurrency(item.balance)}</div>
                                            <button class="delete-balance-btn" onclick="handleBalanceDelete(this); return false;"><i data-lucide="x" class="w-4 h-4"></i></button>
                                        </div>
                                    </div>
                                    <div class="swipe-action" onclick="handleBalanceDelete(this); event.stopPropagation(); return false;"><i data-lucide="x" class="w-4 h-4"></i></div>
                                </div>
                            `;
                    }).join('');
                }
            }
        }

        function addBalance() {
            const amount = parseFloat(document.getElementById('balanceAmount').value);
            const targetDate = document.getElementById('balanceDate').value;
            const selectedAccount = document.getElementById('balanceAccount').value;

            if (!amount || amount < 0) {
                alert('Please enter a valid balance amount');
                return;
            }

            if (!targetDate) {
                alert('Please select a date');
                return;
            }

            if (!selectedAccount) {
                alert('Please select an account');
                return;
            }

            const balances = loadAccountBalances();

            if (!balances[selectedAccount]) {
                balances[selectedAccount] = {};
            }

            balances[selectedAccount][targetDate] = amount;
            saveAccountBalances(balances);

            // Update account type chart if on home page
            if (document.getElementById('accountTypeChart')) {
                generateAccountTypeChart();
            }

            // Clear form
            document.getElementById('balanceAmount').value = '';

            updateTotalSavingsDisplay();

            // Update chart if on reports screen
            if (currentScreen === 1) {
                updateChart();
            }
        }

        function deleteBalance(accountId, date) {
            const balances = loadAccountBalances();

            if (balances[accountId] && balances[accountId][date]) {
                // Find the swipe container that holds this balance
                const swipeContainer = document.querySelector(`.swipe-container[data-type="balance"][data-account-id="${accountId}"][data-date="${date}"]`);

                if (swipeContainer) {
                    // Save accordion state before deletion
                    const accordionId = `accordion-body-${accountId}`;
                    const accordionBody = document.getElementById(accordionId);
                    const wasExpanded = accordionBody ? accordionBody.classList.contains('expanded') : false;

                    // Add deleting animation
                    swipeContainer.classList.add('deleting');

                    // Wait for animation to complete before removing from storage
                    setTimeout(() => {
                        // Delete the balance entry
                        delete balances[accountId][date];
                        saveAccountBalances(balances);
                        updateTotalSavingsDisplay();

                        // Update screens based on current view
                        if (document.getElementById('saveBalanceHistory')) {
                            updateSaveScreen();

                            // Restore accordion state after update
                            setTimeout(() => {
                                const newAccordionBody = document.getElementById(accordionId);
                                if (newAccordionBody && wasExpanded && !newAccordionBody.classList.contains('expanded')) {
                                    toggleAccountAccordion(accountId);
                                }
                            }, 10);
                        } else {
                            updateBalanceHistory();
                        }

                        // Update chart if on reports screen
                        if (currentScreen === 2) {
                            updateChart();
                        }
                    }, 300); // Match the CSS animation duration
                } else {
                    // No swipe container found, just delete immediately
                    delete balances[accountId][date];
                    saveAccountBalances(balances);
                    updateTotalSavingsDisplay();

                    // Update screens based on current view
                    if (document.getElementById('saveBalanceHistory')) {
                        updateSaveScreen();
                    } else {
                        updateBalanceHistory();
                    }

                    // Update chart if on reports screen
                    if (currentScreen === 2) {
                        updateChart();
                    }
                }
            }
        }

        async function showAccountManagementModal() {
            await showAccountManagementSlideOut();
        }

        async function showAccountManagementSlideOut() {
            document.getElementById('accountManagementSlideOut').classList.add('active');
            await updateAccountManagementList();
        }

        function hideAccountManagementSlideOut() {
            document.getElementById('accountManagementSlideOut').classList.remove('active');
        }

        function hideAccountManagementModal() {
            hideAccountManagementSlideOut();
        }

        async function updateAccountList() {
            await updateAccountManagementList();
        }

        async function updateAccountManagementList() {
            const listContainer = document.getElementById('accountManagementList');
            if (!listContainer) return;

            // Load accounts with recent transactions from API
            await loadAccountsWithTransactions();

            // DEBUG: Log all account data for debugging balance issues
            console.log('=== ACCOUNT BALANCE DEBUG ===');
            console.log('Total accounts:', savingsAccounts.length);
            savingsAccounts.forEach((account, index) => {
                console.log(`Account ${index + 1}:`, {
                    id: account.id,
                    name: account.name,
                    type: account.type,
                    institutionName: account.institutionName,
                    currentBalance: account.currentBalance,
                    hasBalance: account.currentBalance !== undefined,
                    balanceType: typeof account.currentBalance,
                    plaidType: account.plaidType,
                    currency: account.currency
                });
            });
            console.log('==========================');

            listContainer.innerHTML = savingsAccounts.map(account => {
                const balanceDisplay = account.currentBalance !== undefined
                    ? `<div style="font-size: 0.9rem; color: #666; margin-top: 0.25rem;">Balance: ${formatCurrency(account.currentBalance)}</div>`
                    : '';

                return `
                        <div class="account-management-list-item" style="flex-direction: column; align-items: flex-start; padding: 1rem;">
                            <div style="display: flex; justify-content: space-between; align-items: center; width: 100%;">
                                <div>
                                    <div class="account-management-name" style="font-weight: 600;">${account.name}</div>
                                    ${account.institutionName ? `<div style="font-size: 0.8rem; color: #666;">${account.institutionName}</div>` : ''}
                                    ${balanceDisplay}
                                </div>
                                ${savingsAccounts.length > 1 ? `<button class="account-management-delete-btn" onclick="deleteAccountFromSlideOut('${account.id}')">Delete</button>` : ''}
                            </div>
                        </div>
                    `;
            }).join('');
        }

        function addNewAccount() {
            addNewAccountFromSlideOut();
        }

        async function addNewAccountFromSlideOut() {
            const name = document.getElementById('newAccountNameSlideOut').value.trim();

            if (!name) {
                alert('Please enter an account name');
                return;
            }

            const id = name.toLowerCase().replace(/\s+/g, '-');

            if (savingsAccounts.find(acc => acc.id === id)) {
                alert('Account with this name already exists');
                return;
            }

            savingsAccounts.push({
                id: id,
                name: name,
                type: 'custom'
            });

            saveSavingsAccounts(savingsAccounts);
            document.getElementById('newAccountNameSlideOut').value = '';
            await updateAccountManagementList();
            updateAccountSelector();
            updateSlideOutAccountDropdown();
        }

        function deleteAccount(accountId) {
            deleteAccountFromSlideOut(accountId);
        }

        async function deleteAccountFromSlideOut(accountId) {
            if (savingsAccounts.length <= 1) {
                alert('You must have at least one account');
                return;
            }

            if (confirm('Are you sure you want to delete this account? All balance history will be lost.')) {
                // Remove from accounts
                savingsAccounts = savingsAccounts.filter(acc => acc.id !== accountId);
                saveSavingsAccounts(savingsAccounts);

                // Remove all balances for this account
                const balances = loadAccountBalances();
                delete balances[accountId];
                saveAccountBalances(balances);

                await updateAccountManagementList();
                updateAccountSelector();
                updateSlideOutAccountDropdown();
            }
        }

        function setDefaultBalanceDate() {
            const dateInput = document.getElementById('balanceDate');
            if (dateInput) {
                const today = new Date();
                if (isCurrentMonth()) {
                    const year = today.getFullYear();
                    const month = String(today.getMonth() + 1).padStart(2, '0');
                    const day = String(today.getDate()).padStart(2, '0');
                    dateInput.value = `${year}-${month}-${day}`;
                } else {
                    const firstDay = new Date(selectedMonthDate.getFullYear(), selectedMonthDate.getMonth(), 1);
                    const year = firstDay.getFullYear();
                    const month = String(firstDay.getMonth() + 1).padStart(2, '0');
                    const day = String(firstDay.getDate()).padStart(2, '0');
                    dateInput.value = `${year}-${month}-${day}`;
                }
            }
        }

        function setDefaultDatePicker() {
            // For custom datepickers, set default date when in month mode
            if (currentPeriodMode === 'month') {
                const datepickerId = 'expenseCustomDatepicker';
                const state = datepickerStates[datepickerId];

                if (state) {
                    if (isCurrentMonth()) {
                        selectToday(datepickerId);
                    } else {
                        // Set to first day of selected month
                        const firstDay = new Date(selectedMonthDate.getFullYear(), selectedMonthDate.getMonth(), 1);
                        state.selectedDate = firstDay;
                        state.currentMonth = firstDay.getMonth();
                        state.currentYear = firstDay.getFullYear();
                        updateDatepickerValue(datepickerId);
                    }
                }
            }
        }

        // Period management functions
        function setPeriodMode(mode) {
            // Function kept for backward compatibility but simplified
            // since we no longer have day/range toggle

            // Update the budget title
            renderBudgetTitle();

            // Update transactions display
            updateTransactionsForTimeRange();

            // Initialize month/year dropdowns for backward compatibility
            updatePeriodDropdownValues();
            setupPeriodDropdownEventListeners();
            setDefaultDatePicker();
            setDefaultBalanceDate();

            updateBudgetDisplay();
            updateBalanceHistory();

            // Update chart
            if (typeof updateChart === 'function') {
                updateChart();
            }
        }

        function updatePeriodDropdownValues() {
            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
            const btnText = document.getElementById('monthYearSelectorText');
            if (btnText) {
                btnText.textContent = `${monthNames[selectedMonthDate.getMonth()]} ${selectedMonthDate.getFullYear()}`;
            }
            // Also update the card title if needed (legacy support)
            const budgetPeriodLabel = document.getElementById('budgetPeriodLabel');
            if (budgetPeriodLabel) {
                budgetPeriodLabel.textContent = `${monthNames[selectedMonthDate.getMonth()]} ${selectedMonthDate.getFullYear()}`;
            }
        }

        // Slide-out functions
        function showExpenseSlideOut() {
            const overlay = document.getElementById('expenseSlideOut');
            overlay.classList.add('active');
            // Update date picker visibility in slide-out
            const slideOutDateGroup = document.getElementById('slideOutDatePickerGroup');
            if (slideOutDateGroup) {
                slideOutDateGroup.style.display = currentPeriodMode === 'month' ? 'block' : 'none';
            }
            // Initialize and set default date for custom datepicker if in month mode
            if (currentPeriodMode === 'month') {
                const datepickerId = 'expenseCustomDatepicker';
                if (!datepickerStates[datepickerId]) {
                    initializeDatepicker(datepickerId);
                }
                const now = new Date(2025, 6, 7); // Hard-coded to July 7, 2025
                let defaultDate;
                if (
                    selectedMonthDate.getFullYear() === now.getFullYear() &&
                    selectedMonthDate.getMonth() === now.getMonth()
                ) {
                    defaultDate = now;
                } else {
                    defaultDate = new Date(selectedMonthDate.getFullYear(), selectedMonthDate.getMonth(), 1);
                }
                const state = datepickerStates[datepickerId];
                state.selectedDate = defaultDate;
                state.currentMonth = defaultDate.getMonth();
                state.currentYear = defaultDate.getFullYear();
                updateDatepickerValue(datepickerId);
                renderCalendar(datepickerId);
            }
        }

        function showBalanceSlideOut() {
            const overlay = document.getElementById('balanceSlideOut');
            overlay.classList.add('active');
            // Initialize datepicker if not already done
            const datepickerId = 'balanceCustomDatepicker';
            if (!datepickerStates[datepickerId]) {
                initializeDatepicker(datepickerId);
            }
            // Set default date to today
            const now = new Date(2025, 6, 7); // Hard-coded to July 7, 2025
            const state = datepickerStates[datepickerId];
            state.selectedDate = now;
            state.currentMonth = now.getMonth();
            state.currentYear = now.getFullYear();
            updateDatepickerValue(datepickerId);
            renderCalendar(datepickerId);

            // Update account dropdown
            updateSlideOutAccountDropdown();

            // Pre-fill with last balance for default account
            const defaultAccountId = getDefaultAccountId();
            if (defaultAccountId) {
                const lastBalance = getLastBalanceForAccount(defaultAccountId);
                const balanceAmountInput = document.getElementById('slideOutBalanceAmount');
                if (balanceAmountInput && lastBalance > 0) {
                    balanceAmountInput.value = lastBalance.toFixed(2);
                }
            }
        }

        function hideExpenseSlideOut() {
            const overlay = document.getElementById('expenseSlideOut');
            overlay.classList.remove('active');
        }

        function hideBalanceSlideOut() {
            const overlay = document.getElementById('balanceSlideOut');
            overlay.classList.remove('active');
        }

        // Custom Datepicker Functions
        let datepickerStates = {};

        function initializeDatepicker(datepickerId) {
            if (!datepickerStates[datepickerId]) {
                datepickerStates[datepickerId] = {
                    currentMonth: new Date().getMonth(),
                    currentYear: new Date().getFullYear(),
                    selectedDate: null,
                    isOpen: false
                };
            }

            // Set default to today
            selectToday(datepickerId);
            renderCalendar(datepickerId);
        }

        function toggleDatepicker(datepickerId) {
            const popup = document.getElementById(datepickerId + 'Popup');
            const trigger = document.querySelector(`#${datepickerId} .datepicker-trigger`);
            const state = datepickerStates[datepickerId];

            if (!state) {
                initializeDatepicker(datepickerId);
                return;
            }

            // Close all other datepickers
            Object.keys(datepickerStates).forEach(id => {
                if (id !== datepickerId) {
                    const otherPopup = document.getElementById(id + 'Popup');
                    const otherTrigger = document.querySelector(`#${id} .datepicker-trigger`);
                    if (otherPopup) {
                        otherPopup.style.display = 'none';
                        datepickerStates[id].isOpen = false;
                    }
                    if (otherTrigger) {
                        otherTrigger.setAttribute('aria-expanded', 'false');
                    }
                }
            });

            if (state.isOpen) {
                popup.style.display = 'none';
                state.isOpen = false;
                if (trigger) {
                    trigger.setAttribute('aria-expanded', 'false');
                }
            } else {
                renderCalendar(datepickerId);
                popup.style.display = 'block';
                state.isOpen = true;
                if (trigger) {
                    trigger.setAttribute('aria-expanded', 'true');
                }
            }
        }

        function renderCalendar(datepickerId) {
            const state = datepickerStates[datepickerId];
            if (!state) return;

            const monthYearElement = document.getElementById(datepickerId + 'MonthYear');
            const gridElement = document.getElementById(datepickerId + 'Grid');

            // Update month/year display
            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                'July', 'August', 'September', 'October', 'November', 'December'];
            monthYearElement.textContent = `${monthNames[state.currentMonth]} ${state.currentYear}`;

            // Clear existing grid
            gridElement.innerHTML = '';

            // Add day headers
            const dayHeaders = ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'];
            dayHeaders.forEach(day => {
                const dayHeader = document.createElement('div');
                dayHeader.className = 'datepicker-day-header';
                dayHeader.textContent = day;
                gridElement.appendChild(dayHeader);
            });

            // Get first day of month and number of days
            const firstDay = new Date(state.currentYear, state.currentMonth, 1);
            const lastDay = new Date(state.currentYear, state.currentMonth + 1, 0);
            const daysInMonth = lastDay.getDate();
            const startingDayOfWeek = firstDay.getDay();

            // Add empty cells for days before first day of month
            for (let i = 0; i < startingDayOfWeek; i++) {
                const emptyCell = document.createElement('div');
                emptyCell.className = 'datepicker-day datepicker-day-empty';
                gridElement.appendChild(emptyCell);
            }

            // Add days of month
            for (let day = 1; day <= daysInMonth; day++) {
                const dayElement = document.createElement('div');
                dayElement.className = 'datepicker-day';
                dayElement.textContent = day;

                // Highlight selected date
                if (
                    state.selectedDate &&
                    state.selectedDate.getDate() === day &&
                    state.selectedDate.getMonth() === state.currentMonth &&
                    state.selectedDate.getFullYear() === state.currentYear
                ) {
                    dayElement.classList.add('selected');
                }

                // Check if this day is today
                const today = new Date();
                if (
                    today.getDate() === day &&
                    today.getMonth() === state.currentMonth &&
                    today.getFullYear() === state.currentYear
                ) {
                    dayElement.classList.add('datepicker-day-today');
                }

                dayElement.addEventListener('click', () => selectDate(datepickerId, day));
                gridElement.appendChild(dayElement);
            }
        }

        function selectDate(datepickerId, day) {
            const state = datepickerStates[datepickerId];
            if (!state) return;

            state.selectedDate = new Date(state.currentYear, state.currentMonth, day);
            updateDatepickerValue(datepickerId);
            closeDatepicker(datepickerId);
        }

        function updateDatepickerValue(datepickerId) {
            const state = datepickerStates[datepickerId];
            if (!state || !state.selectedDate) return;

            const valueElement = document.getElementById(datepickerId + 'Value');

            // More robust hidden input identification
            let hiddenInput;
            if (datepickerId.includes('expense')) {
                hiddenInput = document.getElementById('slideOutExpenseDate');
            } else if (datepickerId.includes('balance')) {
                hiddenInput = document.getElementById('slideOutBalanceDate');
            }

            // Create a new date to avoid timezone issues
            const selectedDate = new Date(state.selectedDate);

            // Format date as readable string for display (using local timezone)
            const displayDate = selectedDate.toLocaleDateString('en-US', {
                weekday: 'short',
                year: 'numeric',
                month: 'short',
                day: 'numeric'
            });

            // Format date as YYYY-MM-DD for form submission (avoid timezone offset)
            const year = selectedDate.getFullYear();
            const month = String(selectedDate.getMonth() + 1).padStart(2, '0');
            const day = String(selectedDate.getDate()).padStart(2, '0');
            const formattedDate = `${year}-${month}-${day}`;

            if (valueElement) {
                valueElement.textContent = displayDate;
            }
            if (hiddenInput) {
                hiddenInput.value = formattedDate;
            }
        }

        function closeDatepicker(datepickerId) {
            const popup = document.getElementById(datepickerId + 'Popup');
            const trigger = document.querySelector(`#${datepickerId} .datepicker-trigger`);
            const state = datepickerStates[datepickerId];

            if (popup) {
                popup.style.display = 'none';
            }
            if (state) {
                state.isOpen = false;
            }
            if (trigger) {
                trigger.setAttribute('aria-expanded', 'false');
            }
        }

        function navigateMonth(datepickerId, direction) {
            const state = datepickerStates[datepickerId];
            if (!state) return;

            state.currentMonth += direction;

            if (state.currentMonth < 0) {
                state.currentMonth = 11;
                state.currentYear--;
            } else if (state.currentMonth > 11) {
                state.currentMonth = 0;
                state.currentYear++;
            }

            renderCalendar(datepickerId);
        }

        function selectToday(datepickerId) {
            const state = datepickerStates[datepickerId];
            if (!state) {
                initializeDatepicker(datepickerId);
                return;
            }

            const today = new Date();
            state.selectedDate = today;
            state.currentMonth = today.getMonth();
            state.currentYear = today.getFullYear();

            updateDatepickerValue(datepickerId);
            if (state.isOpen) {
                renderCalendar(datepickerId);
            }
        }

        function clearDate(datepickerId) {
            const state = datepickerStates[datepickerId];
            if (!state) return;

            state.selectedDate = null;

            const valueElement = document.getElementById(datepickerId + 'Value');

            // More robust hidden input identification
            let hiddenInput;
            if (datepickerId.includes('expense')) {
                hiddenInput = document.getElementById('slideOutExpenseDate');
            } else if (datepickerId.includes('balance')) {
                hiddenInput = document.getElementById('slideOutBalanceDate');
            }

            if (valueElement) {
                valueElement.textContent = 'Select date';
            }
            if (hiddenInput) {
                hiddenInput.value = '';
            }

            closeDatepicker(datepickerId);
        }

        // Close datepickers when clicking outside
        document.addEventListener('click', function (e) {
            if (!e.target.closest('.custom-datepicker')) {
                Object.keys(datepickerStates).forEach(datepickerId => {
                    closeDatepicker(datepickerId);
                });
            }
        });

        // Add keyboard support for datepickers
        document.addEventListener('keydown', function (e) {
            if (e.key === 'Escape') {
                // Close all open datepickers
                Object.keys(datepickerStates).forEach(datepickerId => {
                    closeDatepicker(datepickerId);
                });
            }
        });

        // Initialize datepickers when page loads
        document.addEventListener('DOMContentLoaded', function () {
            // Migrate old expense data if it exists
            const oldExpenses = localStorage.getItem('expenses');
            const newExpenses = localStorage.getItem('dailyExpenses');
            if (oldExpenses && !newExpenses) {
                localStorage.setItem('dailyExpenses', oldExpenses);
            }

            // Initialize datepickers
            initializeDatepicker('expenseCustomDatepicker');
            initializeDatepicker('balanceCustomDatepicker');

            // Initialize savings accounts
            initializeSavingsAccounts();

            // Initialize dropdown event listeners
            setupDropdownEventListeners();
            setupPeriodDropdownEventListeners();

            // Initialize click-outside-to-close functionality for slide-out menus
            initializeSlideOutClickOutside();

            // Initialize period mode
            setPeriodMode('month');

            // Set chart period to ALL by default to show all balance data
            currentChartPeriod = 'ALL';

            // Initialize slide-out account dropdown
            updateSlideOutAccountDropdown();

            // Force initialize Lucide icons with multiple attempts
            function initializeLucideIcons() {
                if (typeof lucide !== 'undefined') {
                    try {
                        lucide.createIcons();
                    } catch (error) {
                        console.error('Error initializing Lucide icons:', error);
                    }
                } else {
                    console.warn('Lucide not loaded yet, retrying...');
                }
            }

            // Try immediately
            initializeLucideIcons();

            // Try again after short delays
            setTimeout(initializeLucideIcons, 100);
            setTimeout(initializeLucideIcons, 500);
            setTimeout(initializeLucideIcons, 1000);

            // Update current date display
            updateCurrentDateDisplay();

            // Initial update of displays
            updatePeriodView();
            updateSaveScreen(); // Initialize save screen

            // Initialize the chart with empty data
            if (document.getElementById('spendingChart')) {
                // Set default period
                currentChartPeriod = 'YTD';
                document.querySelectorAll('.chart-period-btn-wealthsimple').forEach(btn => {
                    btn.classList.toggle('active', btn.id === 'periodYTD');
                });
            }

            // Default to month view (no today-view class needed)
            const screen = document.querySelector('.screen');
            if (screen) {
                // Month view is the default when today-view class is not present
                screen.classList.remove('today-view');
            }

        });

        function setupDropdownEventListeners() {
            // Setup expense category dropdown
            const expenseCategoryItems = document.querySelectorAll('#expenseCategoryContent .select-item');
            expenseCategoryItems.forEach(item => {
                item.addEventListener('click', function () {
                    const value = this.getAttribute('data-value');
                    const text = this.textContent;
                    selectSlideOutOption('expenseCategory', value, text);
                });
            });

            // Balance account dropdown will be set up when accounts are loaded
        }

        function setupPeriodDropdownEventListeners() {
            // Setup month selector
            const monthSelectItems = document.querySelectorAll('#monthSelectContent .period-select-item');
            monthSelectItems.forEach(item => {
                item.addEventListener('click', function () {
                    const monthIndex = parseInt(this.getAttribute('data-value'));
                    selectedMonthDate.setMonth(monthIndex);

                    // Update display
                    document.getElementById('monthSelectValue').textContent = this.textContent;

                    // Update selected state
                    document.querySelectorAll('#monthSelectContent .period-select-item').forEach(i => {
                        i.classList.remove('selected');
                    });
                    this.classList.add('selected');

                    // Close dropdown
                    document.getElementById('monthSelectContent').classList.remove('open');
                    document.getElementById('monthSelectTrigger').removeAttribute('aria-expanded');

                    updatePeriodView();
                });
            });

            // Setup year selector
            const yearSelectItems = document.querySelectorAll('#yearSelectContent .period-select-item');
            yearSelectItems.forEach(item => {
                item.addEventListener('click', function () {
                    const year = parseInt(this.getAttribute('data-value'));
                    selectedMonthDate.setFullYear(year);

                    // Update display
                    document.getElementById('yearSelectValue').textContent = this.textContent;

                    // Update selected state
                    document.querySelectorAll('#yearSelectContent .period-select-item').forEach(i => {
                        i.classList.remove('selected');
                    });
                    this.classList.add('selected');

                    // Close dropdown
                    document.getElementById('yearSelectContent').classList.remove('open');
                    document.getElementById('yearSelectTrigger').removeAttribute('aria-expanded');

                    updatePeriodView();
                });
            });
        }

        function updateCurrentDateDisplay() {
            const dateElement = document.getElementById('currentDate');
            if (dateElement) {
                const now = new Date(2025, 6, 7); // Hard-coded to July 7, 2025
                const options = {
                    weekday: 'long',
                    year: 'numeric',
                    month: 'long',
                    day: 'numeric'
                };
                dateElement.textContent = now.toLocaleDateString('en-US', options);
            }
        }

        async function addExpenseFromSlideOut() {
            const amount = parseFloat(document.getElementById('slideOutExpenseAmount').value);
            const category = document.getElementById('slideOutExpenseCategory').value;
            const description = document.getElementById('slideOutExpenseDescription').value;

            let targetDate;
            if (currentPeriodMode === 'month') {
                targetDate = document.getElementById('slideOutExpenseDate').value;
                if (!targetDate) {
                    alert('Please select a date');
                    return;
                }
            } else {
                targetDate = getCurrentDate();
            }

            if (!amount || amount <= 0) {
                alert('Please enter a valid amount');
                return;
            }

            if (!category) {
                alert('Please select a category');
                return;
            }

            const expenses = await loadExpenses();

            if (!expenses[targetDate]) {
                expenses[targetDate] = [];
            }

            const now = Date.now();
            const newExpense = {
                amount: amount,
                category: category,
                description: description || '',
                timestamp: now, // legacy
                created: now,
                updated: now
            };

            expenses[targetDate].push(newExpense);

            saveExpenses(expenses);

            // Clear form
            document.getElementById('slideOutExpenseAmount').value = '';
            document.getElementById('slideOutExpenseDescription').value = '';

            // Reset category to default using the dropdown function
            selectSlideOutOption('expenseCategory', 'groceries', 'Groceries');

            // Clear custom datepicker
            if (currentPeriodMode === 'month') {
                clearDate('expenseCustomDatepicker');
            }

            // Close slide-out
            hideExpenseSlideOut();

            // Update display
            await updatePeriodView();
            updateChart();
        }

        function addBalanceFromSlideOut() {
            const amount = parseFloat(document.getElementById('slideOutBalanceAmount').value);
            const targetDate = document.getElementById('slideOutBalanceDate').value;
            const selectedAccount = document.getElementById('slideOutBalanceAccount').value;

            if (!amount || amount < 0) {
                alert('Please enter a valid balance amount');
                return;
            }

            if (!targetDate) {
                alert('Please select a date');
                return;
            }

            if (!selectedAccount) {
                alert('Please select an account');
                return;
            }

            const balances = loadAccountBalances();

            if (!balances[selectedAccount]) {
                balances[selectedAccount] = {};
            }

            if (!balances[selectedAccount][targetDate]) {
                balances[selectedAccount][targetDate] = {
                    amount: amount,
                    created: Date.now(),
                    updated: Date.now()
                };
            } else {
                // If already exists, treat as update
                const old = balances[selectedAccount][targetDate];
                balances[selectedAccount][targetDate] = {
                    amount: amount,
                    created: old.created || Date.now(),
                    updated: Date.now()
                };
            }

            saveAccountBalances(balances);

            // Update account type chart if on home page
            if (document.getElementById('accountTypeChart')) {
                generateAccountTypeChart();
            }

            // Clear form
            document.getElementById('slideOutBalanceAmount').value = '';
            clearDate('balanceCustomDatepicker');

            // Close slide-out
            hideBalanceSlideOut();

            // Update display
            updateTotalSavingsDisplay();
            updateSaveScreen(); // Update save screen when balance is added
            updateChart();
        }

        function togglePeriodSelect(selectType) {
            const content = document.getElementById(selectType + 'SelectContent');
            const trigger = document.getElementById(selectType + 'SelectTrigger');
            const isOpen = content.classList.contains('open');

            // Close all other period dropdowns
            document.querySelectorAll('.period-select-content').forEach(dropdown => {
                dropdown.classList.remove('open');
            });
            document.querySelectorAll('.period-select-trigger').forEach(triggerEl => {
                triggerEl.removeAttribute('aria-expanded');
            });

            // Toggle current dropdown
            if (!isOpen) {
                content.classList.add('open');
                trigger.setAttribute('aria-expanded', 'true');
            }
        }

        function toggleSlideOutSelect(selectType) {
            const content = document.getElementById(selectType + 'Content');
            const trigger = document.getElementById(selectType + 'Trigger');
            const isOpen = content.classList.contains('open');

            // Close all other dropdowns
            document.querySelectorAll('.select-content').forEach(dropdown => {
                dropdown.classList.remove('open');
            });
            document.querySelectorAll('.select-trigger').forEach(triggerEl => {
                triggerEl.removeAttribute('aria-expanded');
            });

            // Toggle current dropdown
            if (!isOpen) {
                content.classList.add('open');
                trigger.setAttribute('aria-expanded', 'true');
            }
        }

        function selectSlideOutOption(selectType, value, text) {
            const trigger = document.getElementById(selectType + 'Trigger');
            const valueSpan = document.getElementById(selectType + 'Value');
            const content = document.getElementById(selectType + 'Content');
            const hiddenSelect = document.getElementById('slideOut' + selectType.charAt(0).toUpperCase() + selectType.slice(1));

            // Handle month/year slideout selections
            if (selectType === 'monthSelect') {
                tempSelectedMonth = parseInt(value);
                const monthInput = document.getElementById('monthInput');
                if (monthInput) {
                    monthInput.value = value;
                }
            } else if (selectType === 'monthYear') {
                tempSelectedYear = parseInt(value);
                const yearInput = document.getElementById('yearInput');
                if (yearInput) {
                    yearInput.value = value;
                }
            } else if (selectType === 'balanceAccount') {
                // Prepopulate balance amount with last balance for selected account
                const lastBalance = getLastBalanceForAccount(value);
                const balanceAmountInput = document.getElementById('slideOutBalanceAmount');
                if (balanceAmountInput && lastBalance > 0) {
                    balanceAmountInput.value = lastBalance.toFixed(2);
                }
            } else if (selectType === 'budgetProvince') {
                // Handle budget province selection
                const provinceValue = document.getElementById('budgetProvinceValue');
                if (provinceValue) {
                    provinceValue.textContent = text;
                }
            }

            // Update display
            if (valueSpan) {
                if (selectType === 'expenseCategory') {
                    // For category selection, use icon + text
                    valueSpan.innerHTML = getCategoryEmoji(value) + text.replace(/^[^\w\s]*\s*/, '');
                    // Initialize Lucide icons for the new content
                    if (window.safeInitLucideIcons) {
                        window.safeInitLucideIcons();
                    }
                } else {
                    valueSpan.textContent = text;
                }
            }

            // Update hidden select
            if (hiddenSelect) {
                hiddenSelect.value = value;
            }

            // Update selected state
            content.querySelectorAll('.select-item').forEach(item => {
                item.classList.remove('selected');
            });
            const selectedItem = content.querySelector(`[data-value="${value}"]`);
            if (selectedItem) {
                selectedItem.classList.add('selected');
            }

            // Close dropdown
            content.classList.remove('open');
            trigger.removeAttribute('aria-expanded');
        }

        // Close dropdowns when clicking outside
        document.addEventListener('click', function (e) {
            if (!e.target.closest('.select-container')) {
                document.querySelectorAll('.select-content').forEach(dropdown => {
                    dropdown.classList.remove('open');
                });
                document.querySelectorAll('.select-trigger').forEach(trigger => {
                    trigger.removeAttribute('aria-expanded');
                });
            }

            if (!e.target.closest('.period-select-container')) {
                document.querySelectorAll('.period-select-content').forEach(dropdown => {
                    dropdown.classList.remove('open');
                });
                document.querySelectorAll('.period-select-trigger').forEach(trigger => {
                    trigger.removeAttribute('aria-expanded');
                });
            }
        });


        /**
         * Loads savings accounts from localStorage or sets defaults if not present.
         */
        function initializeSavingsAccounts() {
            const stored = localStorage.getItem('savingsAccounts');
            if (stored) {
                try {
                    savingsAccounts = JSON.parse(stored);
                    // Validate loaded data is an array of objects with id and name
                    if (!Array.isArray(savingsAccounts) || !savingsAccounts.every(acc => acc && typeof acc.id === 'string' && typeof acc.name === 'string')) {
                        throw new Error('Invalid savingsAccounts data');
                    }
                } catch (e) {
                    // If parsing fails, initialize with empty array
                    savingsAccounts = [];
                }
            } else {
                // Initialize with empty array - no default accounts
                savingsAccounts = [];
            }
        }

        // Cache for API calls to prevent duplicate requests
        let accountsApiCache = {
            data: null,
            timestamp: 0,
            promise: null
        };
        const CACHE_DURATION = 30000; // 30 seconds cache to reduce API calls

        /**
         * Clears the accounts API cache to force fresh data on next request
         */
        function clearAccountsCache() {
            accountsApiCache.data = null;
            accountsApiCache.timestamp = 0;
            accountsApiCache.promise = null;
        }

        // Make the cache clearing function globally available
        window.clearAccountsCache = clearAccountsCache;

        /**
         * Shows the accounts loading skeleton placeholder
         */
        function showAccountsLoadingPlaceholder() {
            showGlobalSpinner();
        }

        /**
         * Hides the accounts loading skeleton placeholder
         */
        function hideAccountsLoadingPlaceholder() {
            hideGlobalSpinner();
        }

        /**
         * Global Loading Bar Functions - Modern sliding bar replacement for skeleton loading
         */
        let globalSpinnerState = {
            isShowing: false,
            showTimeout: null,
            hideTimeout: null
        };

        function showGlobalSpinner() {
            const loadingBar = document.getElementById('globalSpinner');
            if (!loadingBar) return;

            // Clear any existing timeouts
            if (globalSpinnerState.hideTimeout) {
                clearTimeout(globalSpinnerState.hideTimeout);
                globalSpinnerState.hideTimeout = null;
            }

            // Mark as showing and show immediately
            globalSpinnerState.isShowing = true;
            
            // Add show class for animation
            loadingBar.classList.add('show');
        }

        function hideGlobalSpinner() {
            const loadingBar = document.getElementById('globalSpinner');
            if (!loadingBar) return;

            // Clear any pending show timeouts
            if (globalSpinnerState.showTimeout) {
                clearTimeout(globalSpinnerState.showTimeout);
                globalSpinnerState.showTimeout = null;
            }

            // Mark as not showing
            globalSpinnerState.isShowing = false;

            // Hide with animation
            loadingBar.classList.remove('show');
        }

        /**
         * Legacy skeleton placeholder functions - now use global spinner
         */

        function showTransactionsLoadingPlaceholder() {
            showGlobalSpinner();
        }

        /**
         * Hides the transactions loading skeleton placeholder
         */
        function hideTransactionsLoadingPlaceholder() {
            hideGlobalSpinner();
        }

        // Make skeleton functions globally available
        window.showAccountsLoadingPlaceholder = showAccountsLoadingPlaceholder;
        window.hideAccountsLoadingPlaceholder = hideAccountsLoadingPlaceholder;
        window.showTransactionsLoadingPlaceholder = showTransactionsLoadingPlaceholder;
        window.hideTransactionsLoadingPlaceholder = hideTransactionsLoadingPlaceholder;

        /**
         * Maps Plaid account types and subtypes to our app's account categories
         * @param {string} type - Plaid account type (depository, credit, loan, investment)
         * @param {string} subtype - Plaid account subtype (checking, savings, credit card, etc.)
         * @returns {string} - Our app's account type
         */
        function mapPlaidAccountType(type, subtype) {
            // Plaid account type mapping
            const typeMapping = {
                // Depository accounts (cash & checking)
                'depository': {
                    'checking': 'cash',
                    'savings': 'cash', 
                    'hsa': 'cash',
                    'cd': 'cash',
                    'money market': 'cash',
                    'paypal': 'cash',
                    'prepaid': 'cash',
                    'cash management': 'cash',
                    // Default for depository
                    'default': 'cash'
                },
                
                // Investment accounts
                'investment': {
                    '401k': 'retirement',
                    '403B': 'retirement', 
                    '457b': 'retirement',
                    '401a': 'retirement',
                    'ira': 'retirement',
                    'roth': 'retirement',
                    'rollover': 'retirement',
                    'sep': 'retirement',
                    'simple': 'retirement',
                    'sarsep': 'retirement',
                    'pension': 'retirement',
                    'profit sharing': 'retirement',
                    'stock plan': 'retirement',
                    'thrift savings plan': 'retirement',
                    'keogh': 'retirement',
                    'mutual fund': 'investment',
                    'fixed annuity': 'investment',
                    'variable annuity': 'investment',
                    'cash isa': 'investment',
                    'stocks isa': 'investment',
                    'investment-isa': 'investment',
                    'brokerage': 'investment',
                    'hsbc': 'investment',
                    'tfsa': 'investment',
                    'crypto exchange': 'crypto',
                    // Default for investment
                    'default': 'investment'
                },
                
                // Credit accounts (liabilities)
                'credit': {
                    'credit card': 'credit_card',
                    'paypal': 'credit_card',
                    // Default for credit
                    'default': 'credit_card'
                },
                
                // Loan accounts (liabilities)  
                'loan': {
                    'auto': 'liability',
                    'business': 'liability',
                    'commercial': 'liability',
                    'construction': 'liability',
                    'consumer': 'liability',
                    'home equity': 'liability',
                    'loan': 'liability',
                    'mortgage': 'mortgage',
                    'overdraft': 'liability',
                    'line of credit': 'liability',
                    'student': 'student_loan',
                    // Default for loan
                    'default': 'liability'
                }
            };

            // Get the type mapping object
            const subtypeMapping = typeMapping[type];
            if (!subtypeMapping) {
                console.warn(`Unknown Plaid account type: ${type}`);
                return 'cash'; // Default fallback
            }

            // Get the mapped type for the subtype, or use the default for this type
            const mappedType = subtypeMapping[subtype] || subtypeMapping['default'];
            
            return mappedType;
        }

        /**
         * Fetches accounts with recent transactions from the API with caching
         */
        async function loadAccountsWithTransactions() {
            try {
                // Check if we have a recent cache
                const now = Date.now();
                if (accountsApiCache.data && (now - accountsApiCache.timestamp) < CACHE_DURATION) {
                    return accountsApiCache.data;
                }

                // Check if there's already a request in progress
                if (accountsApiCache.promise) {
                    return await accountsApiCache.promise;
                }

                // Create new request
                accountsApiCache.promise = _fetchAccountsFromApi();
                
                try {
                    const data = await accountsApiCache.promise;
                    // Cache the result
                    accountsApiCache.data = data;
                    accountsApiCache.timestamp = now;
                    return data;
                } catch (error) {
                    console.error('Failed to fetch accounts data:', error);
                    // Fall back to localStorage accounts when API fails
                    const localStorageAccounts = savingsAccounts || [];
                    return localStorageAccounts;
                } finally {
                    // Clear the promise whether successful or not
                    accountsApiCache.promise = null;
                }
            } catch (error) {
                console.error('Error loading accounts with transactions:', error);
                // Clear cache on error
                accountsApiCache.promise = null;
                // Final fallback to localStorage accounts
                const localStorageAccounts = savingsAccounts || [];
                return localStorageAccounts;
            }
        }

        /**
         * Internal function to fetch accounts from API
         */
        async function _fetchAccountsFromApi() {
            // Get Clerk session token
            const sessionToken = await window.plaidService.getClerkSessionToken();

            // Add timeout to prevent hanging requests
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 30000); // 30 second timeout

            try {
                const response = await fetch(`${window.plaidService.baseUrl}/api/accounts`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${sessionToken}`,
                    },
                    signal: controller.signal
                });

                clearTimeout(timeoutId);

                if (!response.ok) {
                    throw new Error(`Failed to load accounts: ${response.status}`);
                }

                const data = await response.json();

                // DEBUG: Log raw API response for balance debugging
                console.log('=== API RESPONSE DEBUG ===');
                console.log('Raw API response:', JSON.stringify(data, null, 2));
                if (data.accounts) {
                    data.accounts.forEach((account, index) => {
                        console.log(`API Account ${index + 1}:`, {
                            account_id: account.account_id,
                            name: account.name,
                            current_balance: account.current_balance,
                            balance: account.balance,
                            balances: account.balances,
                            type: account.type,
                            subtype: account.subtype,
                            institution_name: account.institution_name,
                            all_fields: Object.keys(account)
                        });
                    });
                }
                console.log('========================');

            if (data.accounts && Array.isArray(data.accounts)) {
                // Update the global savingsAccounts with the API data
                // Keep existing localStorage accounts and add API accounts
                const apiAccounts = data.accounts.map(account => ({
                    id: account.account_id,
                    name: account.name,
                    type: mapPlaidAccountType(account.type, account.subtype),
                    plaidType: account.type,
                    plaidSubtype: account.subtype,
                    institutionName: account.institution_name,
                    currentBalance: account.current_balance,
                    currency: account.currency
                    // Note: transactions will be loaded separately when viewing account details
                }));

                // Merge with existing localStorage accounts
                const existingAccounts = savingsAccounts.filter(acc => !acc.plaidType);
                savingsAccounts = [...existingAccounts, ...apiAccounts];

                // Update localStorage
                saveSavingsAccounts(savingsAccounts);

                // DEBUG: Log processed accounts with balances
                console.log('=== PROCESSED ACCOUNTS DEBUG ===');
                console.log('Total processed accounts:', savingsAccounts.length);
                savingsAccounts.forEach((account, index) => {
                    console.log(`Processed Account ${index + 1}:`, {
                        id: account.id,
                        name: account.name,
                        type: account.type,
                        currentBalance: account.currentBalance,
                        plaidType: account.plaidType,
                        plaidSubtype: account.plaidSubtype,
                        institutionName: account.institutionName
                    });
                });
                console.log('===================================');

                // Update account type chart if on home page
                if (document.getElementById('accountTypeChart')) {
                    generateAccountTypeChart();
                }

                return apiAccounts;
            }

            return [];
            } catch (error) {
                clearTimeout(timeoutId);
                if (error.name === 'AbortError') {
                    throw new Error('Request timeout: The server is taking too long to respond');
                }
                throw error;
            }
        }

        /**
         * Saves the current savingsAccounts array to localStorage.
         * @param {Array<{id: string, name: string}>} accounts
         */
        function saveSavingsAccounts(accounts) {
            if (!Array.isArray(accounts)) return;
            localStorage.setItem('savingsAccounts', JSON.stringify(accounts));
        }

        /**
         * Saves the expenses object to localStorage.
         * @param {Record<string, Array<{amount: number, category: string, description: string, timestamp: number}>>} expenses
         */
        function saveExpenses(expenses) {
            if (!expenses || typeof expenses !== 'object' || Array.isArray(expenses)) {
                console.error('Invalid expenses object:', expenses);
                return;
            }

            try {
                localStorage.setItem(EXPENSES_KEY, JSON.stringify(expenses));

                // Verify what was saved
                setTimeout(() => {
                    const savedData = localStorage.getItem(EXPENSES_KEY);

                    // Check if the specific expense was removed
                    try {
                        const parsedData = JSON.parse(savedData);
                    } catch (e) {
                        console.error('Could not parse saved data');
                    }
                }, 10);
            } catch (error) {
                console.error('Error saving expenses to localStorage:', error);
            }
        }

        // Remove old period-date-dropdowns from sticky selector
        // Remove all code related to old dropdowns and their event listeners
        // Add new month/year slide-out logic
        function showMonthYearSlideOut() {
            // Determine if this is for save screen based on current screen
            isSaveScreenSelection = (currentScreen === 2);

            // Set temp values based on which screen we're on
            if (isSaveScreenSelection) {
                tempSelectedMonth = selectedSaveMonthDate.getMonth();
                tempSelectedYear = selectedSaveMonthDate.getFullYear();
            } else {
                tempSelectedMonth = selectedMonthDate.getMonth();
                tempSelectedYear = selectedMonthDate.getFullYear();
            }

            populateMonthYearInputs();
            document.getElementById('monthYearSlideOut').classList.add('active');
        }
        function hideMonthYearSlideOut() {
            document.getElementById('monthYearSlideOut').classList.remove('active');
        }
        let tempSelectedMonth = selectedMonthDate.getMonth();
        let tempSelectedYear = selectedMonthDate.getFullYear();
        let isSaveScreenSelection = false; // Track if we're selecting for save screen
        function populateMonthYearInputs() {
            // Set current values in the input fields
            const monthInput = document.getElementById('monthInput');
            const yearInput = document.getElementById('yearInput');
            const monthYearValue = document.getElementById('monthYearValue');
            const monthYearContent = document.getElementById('monthYearContent');
            const monthSelectValue = document.getElementById('monthSelectValue');
            const monthSelectContent = document.getElementById('monthSelectContent');

            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June',
                'July', 'August', 'September', 'October', 'November', 'December'];

            // Update month display and selection
            if (monthSelectValue) {
                monthSelectValue.textContent = monthNames[tempSelectedMonth];
            }

            // Update month dropdown selection
            if (monthSelectContent) {
                monthSelectContent.querySelectorAll('.select-item').forEach((item, index) => {
                    item.classList.remove('selected');
                    if (index === tempSelectedMonth) {
                        item.classList.add('selected');
                    }
                    // Add click handler if not already added
                    if (!item.onclick) {
                        item.onclick = () => selectSlideOutOption('monthSelect', index.toString(), monthNames[index]);
                    }
                });
            }

            if (monthInput) {
                monthInput.value = tempSelectedMonth;
            }

            // Populate year dropdown with current year back 15 years
            if (monthYearContent) {
                const currentYear = new Date().getFullYear();
                monthYearContent.innerHTML = '';

                for (let year = currentYear; year >= currentYear - 15; year--) {
                    const yearItem = document.createElement('div');
                    yearItem.className = 'select-item';
                    yearItem.setAttribute('data-value', year.toString());
                    yearItem.textContent = year.toString();
                    yearItem.onclick = () => selectSlideOutOption('monthYear', year.toString(), year.toString());

                    // Mark current selected year
                    if (year === tempSelectedYear) {
                        yearItem.classList.add('selected');
                    }

                    monthYearContent.appendChild(yearItem);
                }
            }

            // Update year display
            if (monthYearValue) {
                monthYearValue.textContent = tempSelectedYear.toString();
            }

            // Update hidden select
            if (yearInput) {
                yearInput.value = tempSelectedYear;
            }
        }
        document.getElementById('applyMonthYearBtn').onclick = function () {
            // Use the temp variables directly
            if (typeof tempSelectedMonth === 'number' && typeof tempSelectedYear === 'number' && !isNaN(tempSelectedMonth) && !isNaN(tempSelectedYear)) {
                if (isSaveScreenSelection) {
                    selectedSaveMonthDate = new Date(tempSelectedYear, tempSelectedMonth, 1);
                    // Force a clean rebuild of the savings display with the new month
                    updateSaveScreen();
                } else {
                    selectedMonthDate = new Date(tempSelectedYear, tempSelectedMonth, 1);
                    updatePeriodDropdownValues();
                    updateBudgetDisplay();
                    updateExpensesList();
                    renderBudgetTitle();
                }
            }
            hideMonthYearSlideOut();
        };
        function getMonthYearString(date) {
            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
            if (!date || typeof date.getMonth !== 'function' || isNaN(date.getMonth()) || isNaN(date.getFullYear())) {
                return 'Select a month';
            }
            return `${monthNames[date.getMonth()]} ${date.getFullYear()}`;
        }
        // Update the button text in the card
        function updatePeriodDropdownValues() {
            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
            const btnText = document.getElementById('monthYearSelectorText');
            if (btnText) {
                btnText.textContent = `${monthNames[selectedMonthDate.getMonth()]} ${selectedMonthDate.getFullYear()}`;
            }
            // Also update the card title if needed (legacy support)
            const budgetPeriodLabel = document.getElementById('budgetPeriodLabel');
            if (budgetPeriodLabel) {
                budgetPeriodLabel.textContent = `${monthNames[selectedMonthDate.getMonth()]} ${selectedMonthDate.getFullYear()}`;
            }

            // Also update save screen selector if it exists
            updateSaveMonthYearSelector();
        }
        // Remove old period dropdowns from DOM
        document.addEventListener('DOMContentLoaded', function () {
            const oldDropdowns = document.getElementById('periodDropdowns');
            if (oldDropdowns) oldDropdowns.remove();
            updatePeriodDropdownValues();

            // Initialize scroll detection for quick actions
            initQuickActionsScroll();
        });

        // Scroll detection for hiding/showing quick actions
        function initQuickActionsScroll() {
            const screens = document.querySelectorAll('.screen');
            const cashflowScreen = screens[1]; // Screen 1 is cashflow (expenses)
            const accountsScreen = screens[2]; // Screen 2 is accounts

            // Set up scroll behavior for cashflow screen
            if (cashflowScreen) {
                const cashflowQuickActions = cashflowScreen.querySelector('.quick-actions');
                if (cashflowQuickActions) {
                    setupScreenScroll(cashflowScreen, cashflowQuickActions);
                }
            }

            // Set up scroll behavior for accounts screen
            if (accountsScreen) {
                const accountsQuickActions = accountsScreen.querySelector('.quick-actions');
                if (accountsQuickActions) {
                    setupScreenScroll(accountsScreen, accountsQuickActions);
                }
            }
        }

        function setupScreenScroll(screen, quickActions) {
            let lastScrollY = 0;
            let isScrolling = false;

            function handleScroll() {
                const currentScrollY = screen.scrollTop;
                const scrollDifference = currentScrollY - lastScrollY;

                // Calculate if quick actions are at their natural position (bottom of screen)
                const screenHeight = screen.clientHeight;
                const screenScrollHeight = screen.scrollHeight;
                const distanceFromBottom = screenScrollHeight - (currentScrollY + screenHeight);

                // Get the height of the quick actions to determine when they're at natural position
                const quickActionsHeight = quickActions.offsetHeight;
                const isAtNaturalPosition = distanceFromBottom <= quickActionsHeight + 20; // 20px buffer

                // If at natural position, ensure buttons are visible and stop reacting
                if (isAtNaturalPosition) {
                    quickActions.classList.remove('hidden');
                    isScrolling = false;
                    return;
                }

                // Only trigger if we've scrolled a significant amount (reduces sensitivity)
                if (Math.abs(scrollDifference) > 5) {
                    if (scrollDifference > 0 && currentScrollY > 50) {
                        // Scrolling down - hide quick actions
                        quickActions.classList.add('hidden');
                    } else if (scrollDifference < 0) {
                        // Scrolling up - show quick actions
                        quickActions.classList.remove('hidden');
                    }

                    lastScrollY = currentScrollY;
                }

                isScrolling = false;
            }

            screen.addEventListener('scroll', function () {
                if (!isScrolling) {
                    requestAnimationFrame(handleScroll);
                    isScrolling = true;
                }
            }, { passive: true });

        }

        /**
         * Renders the budget card title area depending on period mode.
         * In month mode: shows a large, centered, clickable month/year with chevron below.
         * In today mode: shows a static title (e.g., 'Today' or the date).
         */
        // Current selected time range
        let currentTimeRange = 'last30days';

        // Monthly chart tracking
        let selectedMonth = null; // No month selected by default
        let selectedYear = null; // No year selected by default
        let previousTotal = 0; // Track previous total for animation

        function renderBudgetTitle() {
            const subtitleContainer = document.getElementById('budgetTitleContainer');
            const contextMenuContainer = document.getElementById('timeRangeContextMenu');

            if (!subtitleContainer || !contextMenuContainer) return;

            // Clear both containers
            subtitleContainer.innerHTML = '';
            contextMenuContainer.innerHTML = '';

            // Add subtitle text (left side)
            const subtitleDiv = document.createElement('div');
            subtitleDiv.className = 'section-subtitle';
            subtitleDiv.id = 'timeRangeText';
            subtitleDiv.textContent = getTimeRangeLabel(currentTimeRange);
            subtitleContainer.appendChild(subtitleDiv);

            // Add context menu (right side)
            const dropdownContainer = document.createElement('div');
            dropdownContainer.style.position = 'relative';
            dropdownContainer.style.display = 'inline-block';

            const contextBtn = document.createElement('button');
            contextBtn.id = 'timeRangeSelector';
            contextBtn.className = 'dot-menu-btn';
            contextBtn.onclick = toggleTimeRangeDropdown;

            // Three dots icon (more-horizontal)
            const dotsIcon = document.createElement('i');
            dotsIcon.setAttribute('data-lucide', 'more-horizontal');
            dotsIcon.className = 'w-5 h-5';

            contextBtn.appendChild(dotsIcon);

            // Create dropdown menu
            const dropdown = document.createElement('div');
            dropdown.className = 'dropdown-menu dropdown-right';
            dropdown.id = 'timeRangeDropdown';
            dropdown.innerHTML = `
                    <div class="dropdown-header">Select time range</div>
                    <div class="dropdown-item ${currentTimeRange === 'last7days' ? 'active' : ''}" onclick="updateTimeRange('last7days')">Last 7 days</div>
                    <div class="dropdown-item ${currentTimeRange === 'last14days' ? 'active' : ''}" onclick="updateTimeRange('last14days')">Last 14 days</div>
                    <div class="dropdown-item ${currentTimeRange === 'last30days' ? 'active' : ''}" onclick="updateTimeRange('last30days')">Last 30 days</div>
                    <div class="dropdown-item ${currentTimeRange === 'last60days' ? 'active' : ''}" onclick="updateTimeRange('last60days')">Last 60 days</div>
                    <div class="dropdown-item ${currentTimeRange === 'thismonth' ? 'active' : ''}" onclick="updateTimeRange('thismonth')">This month</div>
                    <div class="dropdown-item ${currentTimeRange === 'lastmonth' ? 'active' : ''}" onclick="updateTimeRange('lastmonth')">Last month</div>
                    <div class="dropdown-item ${currentTimeRange === 'thisyear' ? 'active' : ''}" onclick="updateTimeRange('thisyear')">This year</div>
                    <div class="dropdown-item ${currentTimeRange === 'lastyear' ? 'active' : ''}" onclick="updateTimeRange('lastyear')">Last year</div>
                    <div class="dropdown-item ${currentTimeRange === 'alltime' ? 'active' : ''}" onclick="updateTimeRange('alltime')">All time</div>
                `;

            dropdownContainer.appendChild(contextBtn);
            dropdownContainer.appendChild(dropdown);

            // Create add expense button
            const addExpenseBtn = document.createElement('button');
            addExpenseBtn.className = 'dot-menu-btn';
            addExpenseBtn.onclick = showExpenseSlideOut;
            addExpenseBtn.setAttribute('aria-label', 'Add Expense');

            // Plus icon
            const plusIcon = document.createElement('i');
            plusIcon.setAttribute('data-lucide', 'plus');
            plusIcon.className = 'w-5 h-5';
            addExpenseBtn.appendChild(plusIcon);

            contextMenuContainer.appendChild(addExpenseBtn);
            contextMenuContainer.appendChild(dropdownContainer);

            // Ensure Lucide icons are rendered
            if (window.safeInitLucideIcons) {
                window.safeInitLucideIcons();
            }
        }
        function getMonthYearString(date) {
            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
            return `${monthNames[date.getMonth()]} ${date.getFullYear()}`;
        }

        function getTimeRangeLabel(timeRange) {
            const labels = {
                'last7days': 'Last 7 days',
                'last14days': 'Last 14 days',
                'last30days': 'Last 30 days',
                'last60days': 'Last 60 days',
                'thismonth': 'This month',
                'lastmonth': 'Last month',
                'thisyear': 'This year',
                'lastyear': 'Last year',
                'alltime': 'All time'
            };
            return labels[timeRange] || 'Last 30 days';
        }

        // Helper function to close all dropdowns
        function closeAllDropdowns() {
            const dropdowns = [
                'timeRangeDropdown',
                'cashflowDropdown',
                'accountsDropdown',
                'netWorthDropdown',
                'accountsNetWorthDropdown',
                'accountDetailTimeRangeDropdown'
            ];

            dropdowns.forEach(id => {
                const dropdown = document.getElementById(id);
                if (dropdown) {
                    dropdown.classList.remove('show');
                }
            });
        }

        function toggleTimeRangeDropdown() {
            const dropdown = document.getElementById('timeRangeDropdown');
            const btn = document.getElementById('timeRangeSelector');
            const isCurrentlyOpen = dropdown && dropdown.classList.contains('show');

            // Close all dropdowns first
            closeAllDropdowns();

            // If this dropdown wasn't open, open it
            if (dropdown && btn && !isCurrentlyOpen) {
                dropdown.classList.add('show');

                if (dropdown.classList.contains('show')) {
                    setTimeout(() => {
                        document.addEventListener('click', closeTimeRangeDropdownOutside);
                    }, 0);
                } else {
                    document.removeEventListener('click', closeTimeRangeDropdownOutside);
                }
            }
        }

        function closeTimeRangeDropdownOutside(event) {
            const dropdown = document.getElementById('timeRangeDropdown');
            const btn = document.getElementById('timeRangeSelector');

            if (dropdown && !dropdown.contains(event.target) && !btn.contains(event.target)) {
                dropdown.classList.remove('show');
                document.removeEventListener('click', closeTimeRangeDropdownOutside);
            }
        }

        function updateTimeRange(newRange) {
            // Close dropdown
            const dropdown = document.getElementById('timeRangeDropdown');
            if (dropdown) {
                dropdown.classList.remove('show');
                document.removeEventListener('click', closeTimeRangeDropdownOutside);
            }

            // Update active state
            const dropdownItems = dropdown.querySelectorAll('.dropdown-item');
            dropdownItems.forEach(item => item.classList.remove('active'));
            event.currentTarget.classList.add('active');

            // Update current time range
            currentTimeRange = newRange;

            // Update button text
            const timeRangeText = document.getElementById('timeRangeText');
            if (timeRangeText) {
                timeRangeText.textContent = getTimeRangeLabel(newRange);
            }

            // Show skeleton loading while updating transactions
            if (typeof showTransactionsLoadingPlaceholder === 'function') {
                showTransactionsLoadingPlaceholder();
            }

            // Update transactions display based on selected range with enough delay for skeleton to appear
            setTimeout(() => {
                updateTransactionsForTimeRange();
            }, 300);

            // Update chart if needed
            if (typeof updateChart === 'function') {
                updateChart();
            }

            // Update category chart if needed
            if (typeof updateCategoryChart === 'function') {
                updateCategoryChart();
            }

            // Update category chart with staggered bar animation (only if currently shown)
            if (currentChartIndex === 1) {
                // Category chart - staggered bar animation (data changes with time range)
                const categoryContainer = document.getElementById('categorySpendingChart');
                staggeredBarUpdate(categoryContainer, async () => {
                    await generateCategoryChart();
                    await updateSelectedCategoryTotal();
                });
            }
            // Monthly chart doesn't need animation since it's not affected by time range
        }

        function getDateRangeForTimeRange(timeRange) {
            const today = new Date();
            const endDate = new Date(today); // End date is today
            let startDate;

            switch (timeRange) {
                case 'last7days':
                    startDate = new Date(today);
                    startDate.setDate(today.getDate() - 6); // 7 days including today
                    break;
                case 'last14days':
                    startDate = new Date(today);
                    startDate.setDate(today.getDate() - 13);
                    break;
                case 'last30days':
                    startDate = new Date(today);
                    startDate.setDate(today.getDate() - 29);
                    break;
                case 'last60days':
                    startDate = new Date(today);
                    startDate.setDate(today.getDate() - 59);
                    break;
                case 'thismonth':
                    startDate = new Date(today.getFullYear(), today.getMonth(), 1);
                    break;
                case 'lastmonth':
                    const lastMonth = new Date(today.getFullYear(), today.getMonth() - 1, 1);
                    startDate = lastMonth;
                    endDate.setTime(new Date(today.getFullYear(), today.getMonth(), 0).getTime()); // Last day of last month
                    break;
                case 'thisyear':
                    startDate = new Date(today.getFullYear(), 0, 1);
                    break;
                case 'lastyear':
                    startDate = new Date(today.getFullYear() - 1, 0, 1);
                    endDate.setTime(new Date(today.getFullYear() - 1, 11, 31).getTime());
                    break;
                case 'alltime':
                    startDate = new Date(2020, 0, 1); // Reasonable start date
                    break;
                default:
                    // Default to last 30 days
                    startDate = new Date(today);
                    startDate.setDate(today.getDate() - 29);
            }

            return { startDate, endDate };
        }

        function updateTransactionsForTimeRange() {
            // Always filter by selected time range
            const { startDate, endDate } = getDateRangeForTimeRange(currentTimeRange);
            updateExpensesListWithRange(startDate, endDate);
        }

        async function updateExpensesListWithRange(startDate, endDate) {
            const expenses = await loadExpenses();
            const listContainer = document.getElementById('expensesList');
            const titleElement = document.getElementById('expensesListTitle');

            if (!listContainer) return;

            let periodExpenses = [];

            // Convert dates to YYYY-MM-DD format for comparison (using local time to avoid timezone issues)
            const startDateStr = startDate.getFullYear() + '-' + 
                String(startDate.getMonth() + 1).padStart(2, '0') + '-' + 
                String(startDate.getDate()).padStart(2, '0');
            const endDateStr = endDate.getFullYear() + '-' + 
                String(endDate.getMonth() + 1).padStart(2, '0') + '-' + 
                String(endDate.getDate()).padStart(2, '0');

            // Filter expenses by date range
            Object.keys(expenses).forEach(date => {
                if (date >= startDateStr && date <= endDateStr) {
                    const dayExpenses = expenses[date] || [];
                    dayExpenses.forEach(expense => {
                        periodExpenses.push({
                            ...expense,
                            date: date
                        });
                    });
                }
            });

            // Sort: by date (desc), then by created (asc), then by timestamp for stability
            periodExpenses.sort((a, b) => {
                if (a.date !== b.date) {
                    return new Date(b.date) - new Date(a.date); // latest date first
                }
                // If same date, sort by created descending (newest first)
                const createdA = a.created || a.timestamp;
                const createdB = b.created || b.timestamp;
                if (createdA !== createdB) {
                    return createdB - createdA; // Reversed order
                }
                // If created timestamps are the same, use timestamp for stable ordering
                return b.timestamp - a.timestamp; // Reversed order
            });

            if (titleElement) titleElement.textContent = "Transactions";

            if (periodExpenses.length === 0) {
                const rangeText = getTimeRangeLabel(currentTimeRange).toLowerCase();
                listContainer.innerHTML = `<div style="text-align: center; color: #7f8c8d; padding: 20px;">No transactions recorded for ${rangeText}</div>`;
            } else {
                // Group expenses by date
                const expensesByDate = {};
                periodExpenses.forEach(expense => {
                    if (!expensesByDate[expense.date]) {
                        expensesByDate[expense.date] = [];
                    }
                    expensesByDate[expense.date].push(expense);
                });

                // Generate HTML with date grouping (using similar structure to updateExpensesList)
                let html = '';
                Object.keys(expensesByDate).sort((a, b) => new Date(b) - new Date(a)).forEach(date => {
                    const expenses = expensesByDate[date];
                    const dateParts = date.split('-').map(Number);
                    const dateObj = new Date(dateParts[0], dateParts[1] - 1, dateParts[2]);
                    const formattedDate = dateObj.toLocaleDateString('en-US', {
                        month: 'long',
                        day: 'numeric',
                        year: 'numeric'
                    });

                    const dayTotal = expenses.reduce((sum, expense) => sum + expense.amount, 0);

                    html += `
                            <div class="date-group">
                                <div class="date-header">
                                    <span class="date-title">${formattedDate}</span>
                                    <span class="date-total">$${dayTotal.toFixed(2)}</span>
                                </div>
                                <div class="date-transactions">
                        `;

                    expenses.forEach(expense => {
                        html += `
                                <div class="swipe-container" data-type="expense" data-date="${expense.date}" data-timestamp="${expense.timestamp}">
                                    <div class="swipe-content">
                                        <div class="expense-item">
                                            <div class="expense-icon">${getCategoryEmoji(expense.category)}</div>
                                            <div class="expense-details">
                                                <div class="expense-description">${expense.description ? expense.description : `${expense.category} expense`}</div>
                                            </div>
                                            <div class="expense-amount">$${parseFloat(expense.amount).toFixed(2)}</div>
                                        </div>
                                    </div>
                                    <div class="swipe-action" onclick="handleExpenseDelete(this); event.stopPropagation(); return false;"><i data-lucide="x" class="w-5 h-5"></i></div>
                                </div>
                            `;
                    });

                    html += `
                                </div>
                            </div>
                        `;
                });

                listContainer.innerHTML = html;

                // Re-initialize Lucide icons and swipe functionality
                if (window.initializeTransactionIcons) {
                    window.initializeTransactionIcons();
                }
                initializeSwipeToDelete();
            }

            // Hide skeleton loading after updating transactions
            if (typeof hideTransactionsLoadingPlaceholder === 'function') {
                hideTransactionsLoadingPlaceholder();
            }
        }
        // Patch updatePeriodDropdownValues to update the title
        const _oldUpdatePeriodDropdownValues = updatePeriodDropdownValues;
        updatePeriodDropdownValues = function () {
            if (_oldUpdatePeriodDropdownValues) _oldUpdatePeriodDropdownValues();
            renderBudgetTitle();
        };
        // Patch setPeriodMode to update the title
        const _oldSetPeriodMode = setPeriodMode;
        setPeriodMode = function (mode) {
            _oldSetPeriodMode(mode);
            renderBudgetTitle();
        };
        // Initial render on DOMContentLoaded
        document.addEventListener('DOMContentLoaded', async function () {
            renderBudgetTitle();
            renderSaveTitle();
            // App starts clean - no default data loading
            
            // Initialize budget overview card
            updateBudgetOverview('monthly');

            // Check if carousel container exists
            const carouselCheck = document.querySelector('.chart-carousel-container');

            // Check what screen we're on

            // Make sure we're on the cashflow screen (screen 0)
            if (currentScreen !== 0) {
                goToScreen(0);
            } else {
                // We're already on screen 0, but need to load home screen data
                updateHomeScreen().catch(error => {
                    console.error('Error loading home screen data on startup:', error);
                });
            }

            // Also check if the dots exist
            const dotsCheck = document.querySelector('.chart-dots');
            if (dotsCheck) {
            }

            // Initialize charts and swipe functionality
            if (typeof switchToChart === 'function') {
                switchToChart(0); // Show first chart by default
            }

            // Test dot clicks directly
            setTimeout(() => {
                const dots = document.querySelectorAll('#budgetDisplay .chart-dots .dot');
                dots.forEach((dot, index) => {
                    dot.addEventListener('click', function () {
                        switchToChart(index);
                    });
                });
            }, 100);

            // Chart swipe will be initialized when navigating to Screen 3 (Dashboard)

            // Initialize category chart
            if (typeof updateCategoryChart === 'function') {
                updateCategoryChart();
            }

            // Accounts will be loaded when needed by specific screens
        });

        // Swipe to Delete Functionality
        function initializeSwipeToDelete() {
            let startX = 0;
            let currentX = 0;
            let isDragging = false;
            let currentSwipeContainer = null;
            let isSwipeAction = false; // Flag to track if swipe is active


            function handleTouchStart(e) {
                const touch = e.touches ? e.touches[0] : e;
                startX = touch.clientX;
                currentX = startX;

                // Don't start a swipe if we clicked on the delete button
                if (e.target.closest('.swipe-action')) {
                    return;
                }

                const swipeContainer = e.target.closest('.swipe-container');
                if (swipeContainer) {
                    isDragging = true;
                    isSwipeAction = false; // Reset swipe action flag
                    currentSwipeContainer = swipeContainer;

                    // Remove transition during drag
                    const swipeContent = swipeContainer.querySelector('.swipe-content');
                    if (swipeContent) {
                        swipeContent.style.transition = 'none';
                    }
                }
            }

            function handleTouchMove(e) {
                if (!isDragging || !currentSwipeContainer) return;

                const touch = e.touches ? e.touches[0] : e;
                currentX = touch.clientX;

                const deltaX = currentX - startX;

                // Only allow left swipe (negative deltaX)
                if (deltaX < 0) {
                    isSwipeAction = true; // Mark as a swipe action
                    const translateX = Math.max(deltaX, -80);
                    const swipeContent = currentSwipeContainer.querySelector('.swipe-content');
                    if (swipeContent) {
                        swipeContent.style.transform = `translateX(${translateX}px)`;

                        // Prevent page scrolling when swiping horizontally
                        if (Math.abs(deltaX) > 10 && e.cancelable) {
                            e.preventDefault();
                        }
                    }
                }
            }

            function handleTouchEnd(e) {
                if (!isDragging || !currentSwipeContainer) return;

                isDragging = false;
                const deltaX = currentX - startX;
                const swipeContent = currentSwipeContainer.querySelector('.swipe-content');

                if (swipeContent) {
                    swipeContent.style.transition = 'transform 0.2s ease';

                    // If swiped more than 30px to the left, show delete action
                    if (deltaX < -30) {
                        currentSwipeContainer.classList.add('swiped');
                        swipeContent.style.transform = 'translateX(-80px)';
                    } else {
                        // Reset to original position
                        currentSwipeContainer.classList.remove('swiped');
                        swipeContent.style.transform = 'translateX(0)';
                    }
                }

                currentSwipeContainer = null;
            }

            // Helper function to reset any swiped items when tapping elsewhere
            function handleDocumentClick(e) {
                // Don't reset if clicking on swipe action (delete button)
                if (e.target.closest('.swipe-action')) {
                    return;
                }

                // Reset all swiped items when clicking outside
                if (!e.target.closest('.swipe-container')) {
                    document.querySelectorAll('.swipe-container.swiped').forEach(container => {
                        container.classList.remove('swiped');
                        const content = container.querySelector('.swipe-content');
                        if (content) content.style.transform = 'translateX(0)';
                    });
                }
            }

            // Add custom click handler for swipe containers to handle edit functionality
            function handleContainerClick(e) {
                // If we're in a swipe action, don't trigger edit
                if (isSwipeAction) {
                    isSwipeAction = false;
                    return;
                }

                // Don't trigger edit if we're clicking on the delete button
                if (e.target.closest('.swipe-action')) {
                    return;
                }

                const container = e.target.closest('.swipe-container');
                if (container) {
                    const type = container.dataset.type;

                    // Handle expense edit
                    if (type === 'expense') {
                        const date = container.dataset.date;
                        const timestamp = container.dataset.timestamp;
                        if (date && timestamp) {
                            // Only call editExpense if this was a tap, not a swipe
                            editExpense(date, timestamp);
                        }
                    }
                    // Handle balance edit (if needed)
                    // else if (type === 'balance') { ... }
                }
            }

            // Add event listeners to the document
            document.addEventListener('touchstart', handleTouchStart, { passive: false });
            document.addEventListener('touchmove', handleTouchMove, { passive: false });
            document.addEventListener('touchend', handleTouchEnd, { passive: true });
            document.addEventListener('click', handleDocumentClick);
            document.addEventListener('click', handleContainerClick);

            // Also handle mouse events for desktop testing
            document.addEventListener('mousedown', handleTouchStart);
            document.addEventListener('mousemove', (e) => {
                if (isDragging) handleTouchMove(e);
            });
            document.addEventListener('mouseup', handleTouchEnd);
        }

        // Initialize swipe functionality when DOM is loaded
        document.addEventListener('DOMContentLoaded', function () {
            initializeSwipeToDelete();
        });

        /**
         * Update the visibility of balance-related UI elements
         */
        function updateBalanceUIVisibility(showBalance) {
            const balanceBtn = document.getElementById('balanceActionBtn');
            const fabBalanceOption = document.getElementById('fabBalanceOption');
            const balanceActionCard = document.getElementById('balanceActionCard');

            if (balanceBtn) {
                balanceBtn.style.display = showBalance ? 'flex' : 'none';
            }

            if (fabBalanceOption) {
                fabBalanceOption.style.display = showBalance ? 'flex' : 'none';
            }

            if (balanceActionCard) {
                balanceActionCard.style.display = showBalance ? 'block' : 'none';
            }
        }

        /**
         * Loads comprehensive test data for both balances and expenses from January to today.
         * This function creates realistic financial data for testing the chart and reports.
         */
        async function loadTestData() {
            
            try {
                // Get Clerk session token
                const sessionToken = await window.plaidService.getClerkSessionToken();
                
                // Call the seed sample data API endpoint
                const response = await fetch(`${window.plaidService.baseUrl}/api/seed/sample-data`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${sessionToken}`,
                    }
                });

                if (!response.ok) {
                    throw new Error(`Failed to seed sample data: ${response.status}`);
                }

                const result = await response.json();
                
                // DEBUG: Log sample data seeding result
                console.log('=== SAMPLE DATA SEEDING RESULT ===');
                console.log('Sample data API response:', result);
                console.log('Response status:', response.status);
                console.log('==================================');

                // Clear any existing accounts cache to force refresh
                if (typeof clearAccountsCache === 'function') {
                    clearAccountsCache();
                }

                // Update the UI (accounts will be loaded when management screen is accessed)
                if (typeof updateAccountManagementList === 'function') {
                    await updateAccountManagementList();
                }
                
                // Update home screen charts
                if (typeof updateHomeScreen === 'function') {
                    await updateHomeScreen();
                }
                
                // Force refresh the spending UI components
                await updatePeriodView();
                await generateMonthlyChart();
                
                // If we're on the cashflow screen, refresh it
                if (currentScreen === 1) {
                    await updateBudgetDisplay();
                    updateTransactionsForTimeRange();
                }

                console.log(`Sample data loaded successfully! Added ${result.accounts} accounts and ${result.transactions} transactions.`);
                
            } catch (error) {
                console.error('Error loading sample data:', error);
                // Error will be handled by the calling function
            }
        }

        /**
         * Test function to manually refresh spending UI (for debugging)
         */
        async function refreshSpendingUI() {
            try {
                await updatePeriodView();
                await generateMonthlyChart();
            } catch (error) {
                console.error('Error refreshing spending UI:', error);
            }
        }
        
        // Make it available globally for console testing
        window.refreshSpendingUI = refreshSpendingUI;

        /**
         * Show placeholder for home net worth chart when no data is available
         */
        function showHomeNetWorthPlaceholder() {
            const canvas = document.getElementById('homeNetWorthCanvas');
            if (!canvas) return;
            
            // Hide the canvas and show basic placeholder text
            canvas.style.display = 'none';
            
            // Find or create placeholder element
            let placeholder = document.getElementById('homeNetWorthPlaceholder');
            if (!placeholder) {
                placeholder = document.createElement('div');
                placeholder.id = 'homeNetWorthPlaceholder';
                placeholder.style.cssText = `
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    text-align: center;
                    color: #7f8c8d;
                    padding: 40px 20px;
                    height: 200px;
                `;
                placeholder.textContent = 'No account balance data available. Click "Load Sample Data" in settings to populate with test data.';
                canvas.parentNode.insertBefore(placeholder, canvas);
            }
            placeholder.style.display = 'flex';
        }

        /**
         * Show placeholder for accounts net worth chart when no data is available
         */
        function showAccountsNetWorthPlaceholder() {
            const canvas = document.getElementById('accountsNetWorthCanvas');
            if (!canvas) return;
            
            // Hide the canvas and show basic placeholder text
            canvas.style.display = 'none';
            
            // Find or create placeholder element
            let placeholder = document.getElementById('accountsNetWorthPlaceholder');
            if (!placeholder) {
                placeholder = document.createElement('div');
                placeholder.id = 'accountsNetWorthPlaceholder';
                placeholder.style.cssText = `
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    text-align: center;
                    color: #7f8c8d;
                    padding: 40px 20px;
                    height: 200px;
                `;
                placeholder.textContent = 'No account balance data available. Click "Load Sample Data" in settings to populate with test data.';
                canvas.parentNode.insertBefore(placeholder, canvas);
            }
            placeholder.style.display = 'flex';
        }

        /**
         * Show placeholder for home cashflow chart when no spending data is available
         */
        function showHomeCashflowPlaceholder() {
            const canvas = document.getElementById('homeCashflowCanvas');
            if (!canvas) return;
            
            // Hide the canvas and show basic placeholder text
            canvas.style.display = 'none';
            
            // Find or create placeholder element
            let placeholder = document.getElementById('homeCashflowPlaceholder');
            if (!placeholder) {
                placeholder = document.createElement('div');
                placeholder.id = 'homeCashflowPlaceholder';
                placeholder.style.cssText = `
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    text-align: center;
                    color: #7f8c8d;
                    padding: 40px 20px;
                    height: 200px;
                `;
                placeholder.textContent = 'No spending data';
                canvas.parentNode.insertBefore(placeholder, canvas);
            }
            placeholder.style.display = 'flex';
        }

        /**
         * Hide chart placeholders and show actual charts
         */
        function hideChartPlaceholders() {
            // Hide net worth placeholder
            const netWorthPlaceholder = document.getElementById('homeNetWorthPlaceholder');
            if (netWorthPlaceholder) {
                netWorthPlaceholder.style.display = 'none';
            }
            
            // Hide cashflow placeholder
            const cashflowPlaceholder = document.getElementById('homeCashflowPlaceholder');
            if (cashflowPlaceholder) {
                cashflowPlaceholder.style.display = 'none';
            }
            
            // Show chart canvases
            const netWorthCanvas = document.getElementById('homeNetWorthCanvas');
            if (netWorthCanvas) {
                netWorthCanvas.style.display = 'block';
            }
            
            const cashflowCanvas = document.getElementById('homeCashflowCanvas');
            if (cashflowCanvas) {
                cashflowCanvas.style.display = 'block';
            }
        }

        /**
         * Formats a number as a currency string with proper commas and 2 decimal places.
         * @param {number} amount - The amount to format.
         * @returns {string} Formatted currency string (e.g., "$1,234.56").
         */
        function formatCurrency(amount) {
            if (typeof amount !== 'number' || isNaN(amount)) {
                return '$0.00';
            }

            const isNegative = amount < 0;
            const absoluteAmount = Math.abs(amount);
            const formatted = '$' + absoluteAmount.toLocaleString('en-US', {
                minimumFractionDigits: 2,
                maximumFractionDigits: 2
            });

            return isNegative ? `(${formatted})` : formatted;
        }

        /**
         * Formats a number as a currency string without decimal places for whole amounts.
         * @param {number} amount - The amount to format.
         * @returns {string} Formatted currency string (e.g., "$1,234").
         */
        function formatCurrencyWhole(amount) {
            if (typeof amount !== 'number' || isNaN(amount)) {
                return '$0';
            }
            return '$' + amount.toLocaleString('en-US', {
                minimumFractionDigits: 0,
                maximumFractionDigits: 0
            });
        }

        function getCategoryEmoji(category) {
            const iconMap = {
                'groceries': '<i data-lucide="shopping-cart" class="w-4 h-4"></i>',
                'transportation': '<i data-lucide="car" class="w-4 h-4"></i>',
                'dining': '<i data-lucide="utensils" class="w-4 h-4"></i>',
                'entertainment': '<i data-lucide="film" class="w-4 h-4"></i>',
                'personal': '<i data-lucide="user" class="w-4 h-4"></i>',
                'clothing': '<i data-lucide="shirt" class="w-4 h-4"></i>',
                'health': '<i data-lucide="heart-pulse" class="w-4 h-4"></i>',
                'subscriptions': '<i data-lucide="tv" class="w-4 h-4"></i>',
                'mortgage': '<i data-lucide="home" class="w-4 h-4"></i>',
                'loan': '<i data-lucide="dollar-sign" class="w-4 h-4"></i>',
                'garbage': '<i data-lucide="trash-2" class="w-4 h-4"></i>',
                'home improvement': '<i data-lucide="hammer" class="w-4 h-4"></i>',
                'insurance': '<i data-lucide="umbrella" class="w-4 h-4"></i>',
                'pets': '<i data-lucide="dog" class="w-4 h-4"></i>',
                'phone': '<i data-lucide="smartphone" class="w-4 h-4"></i>',
                'internet': '<i data-lucide="globe" class="w-4 h-4"></i>',
                'utilities': '<i data-lucide="zap" class="w-4 h-4"></i>',
                'other': '<i data-lucide="more-horizontal" class="w-4 h-4"></i>'
            };

            return iconMap[category.toLowerCase()] || '<i data-lucide="more-horizontal" class="w-4 h-4"></i>';
        }

        function updateSaveChangeIndicators(targetAmount, progressAmount, progressPercentage) {
            const saveTargetChange = document.getElementById('saveTargetChange');
            const saveProgressChange = document.getElementById('saveProgressChange');

            // Update target indicator (always show monthly target)
            if (saveTargetChange) {
                const targetArrow = saveTargetChange.querySelector('.change-arrow');
                const targetText = saveTargetChange.querySelector('.change-amount');
                if (targetArrow) targetArrow.textContent = '';
                if (targetText) targetText.textContent = 'Monthly';
            }

            // Update progress indicator based on target progress
            if (saveProgressChange) {
                const progressArrow = saveProgressChange.querySelector('.change-arrow');
                const progressText = saveProgressChange.querySelector('.change-amount');
                const progressCard = document.querySelector('.save-progress-card .change-indicator');

                if (progressPercentage >= 100) {
                    if (progressArrow) progressArrow.textContent = ''; // checkmark
                    if (progressText) progressText.textContent = 'Target Met';
                    if (progressCard) progressCard.classList.remove('behind-target');
                } else if (progressPercentage >= 75) {
                    if (progressArrow) progressArrow.textContent = '';
                    if (progressText) progressText.textContent = 'On Track';
                    if (progressCard) progressCard.classList.remove('behind-target');
                } else if (progressPercentage >= 50) {
                    if (progressArrow) progressArrow.textContent = '';
                    if (progressText) progressText.textContent = 'Slow Progress';
                    if (progressCard) progressCard.classList.remove('behind-target');
                } else {
                    if (progressArrow) progressArrow.textContent = '';
                    if (progressText) progressText.textContent = 'Behind Target';
                    if (progressCard) progressCard.classList.add('behind-target');
                }
            }
        }

        async function updateHomeScreen() {
            console.log(' Updating home screen data...');
            
            // Force complete refresh of home screen components
            try {
                // Clear any existing timers or intervals that might interfere
                
                // Force fresh data load and update all components
                await updateHomeTransactions();
                await updateHomeCashflow();
                await updateHomeNetWorth();
                initializeHomeRangePickers();
                
                // Force canvas refresh for charts
                const cashflowCanvas = document.getElementById('homeCashflowCanvas');
                const netWorthCanvas = document.getElementById('homeNetWorthCanvas');
                
                if (cashflowCanvas) {
                    // Force canvas to redraw by triggering a resize event
                    const event = new Event('resize');
                    window.dispatchEvent(event);
                }
                
                // Force re-render of Lucide icons in case new content was added
                if (window.lucide && window.lucide.createIcons) {
                    window.lucide.createIcons();
                }
                
                console.log(' Home screen update complete');
            } catch (error) {
                console.error(' Error updating home screen:', error);
                throw error;
            }
        }

        async function updateHomeTransactions() {
            console.log(' Loading fresh transaction data for home screen...');
            const expenses = await loadExpenses();
            console.log(' Loaded expenses:', Object.keys(expenses).length, 'dates');
            let allTransactions = [];

            // Get ALL transactions from all dates (not just current month)
            Object.keys(expenses).forEach(date => {
                const dayExpenses = expenses[date] || [];
                dayExpenses.forEach(expense => {
                    allTransactions.push({
                        ...expense,
                        date: date
                    });
                });
            });

            // Sort: by date (desc), then by created (desc), then by timestamp for stability (most recent first)
            allTransactions.sort((a, b) => {
                if (a.date !== b.date) {
                    return new Date(b.date) - new Date(a.date); // latest date first
                }
                // If same date, sort by created descending (newest first)
                const createdA = a.created || a.timestamp;
                const createdB = b.created || b.timestamp;
                if (createdA !== createdB) {
                    return createdB - createdA; // Newest created first
                }
                // If created timestamps are the same, use timestamp for stable ordering
                return b.timestamp - a.timestamp;
            });

            // Take most recent 5 transactions from ALL transactions
            const recentTransactions = allTransactions.slice(0, 5);
            console.log(' Found', allTransactions.length, 'total transactions, showing', recentTransactions.length, 'most recent');
            
            // Debug: log the selected transactions
            if (recentTransactions.length > 0) {
                console.log(' Most recent transactions:', recentTransactions.map(t => ({ 
                    date: t.date, 
                    description: t.description, 
                    amount: t.amount 
                })));
            }

            const listContainer = document.getElementById('homeTransactionsList');
            if (!listContainer) {
                console.error(' homeTransactionsList container not found!');
                return;
            }

            if (recentTransactions.length === 0) {
                console.log(' No recent transactions to display');
                listContainer.innerHTML = '<div style="text-align: center; color: #7f8c8d; padding: 20px;">No recent transactions</div>';
                return;
            }
            
            console.log(' Rendering', recentTransactions.length, 'recent transactions to home screen');

            listContainer.innerHTML = recentTransactions.map(transaction => {
                // Parse date manually to avoid timezone issues (same as cashflow page)
                const dateParts = transaction.date.split('-').map(Number);
                const dateObj = new Date(dateParts[0], dateParts[1] - 1, dateParts[2]);
                const displayDate = dateObj.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });

                // Format amounts same as cashflow page - just the amount with dark color
                return `
                        <div class="home-transaction-item">
                            <div class="transaction-info">
                                <div class="transaction-description">${getCategoryEmoji(transaction.category)} ${transaction.description ? transaction.description : `${transaction.category.charAt(0).toUpperCase() + transaction.category.slice(1)} expense`}</div>
                                <div class="transaction-date">${displayDate}</div>
                            </div>
                            <div class="transaction-amount">
                                $${parseFloat(transaction.amount).toFixed(2)}
                            </div>
                        </div>
                    `;
            }).join('');

            // Initialize Lucide icons for the new transaction icons
            if (window.initializeTransactionIcons) {
                window.initializeTransactionIcons();
            }
        }

        async function updateHomeCashflow() {
            // Initialize with week view by default (this wk vs last wk)
            await updateHomeCashflowWithRange('week');
        }

        function calculateCumulativeSpending(expenses, monthKey, isCurrentMonth) {
            const monthExpenses = [];
            const today = new Date();
            const currentDay = today.getDate();

            // Gather all expenses for the month
            Object.keys(expenses).forEach(date => {
                if (date.startsWith(monthKey)) {
                    const dayExpenses = expenses[date] || [];
                    const totalForDay = dayExpenses.reduce((sum, expense) => sum + expense.amount, 0);
                    if (totalForDay > 0) {
                        const dayOfMonth = parseInt(date.split('-')[2]);
                        monthExpenses.push({ day: dayOfMonth, amount: totalForDay });
                    }
                }
            });

            // Sort by day
            monthExpenses.sort((a, b) => a.day - b.day);

            // Calculate cumulative amounts
            const cumulativeData = [];
            let cumulative = 0;

            monthExpenses.forEach(expense => {
                cumulative += expense.amount;
                cumulativeData.push({ day: expense.day, cumulative });
            });

            // For current month, only show up to current day
            if (isCurrentMonth) {
                return cumulativeData.filter(d => d.day <= currentDay);
            }

            return cumulativeData;
        }

        // Universal function for animating line charts from left to right (line only)
        function animateLinePath(ctx, points, options = {}) {
            const {
                duration = 800,
                strokeStyle = '#8b5cf6',
                lineWidth = 2.5,
                onComplete = null,
                startDelay = 0
            } = options;

            if (points.length < 2) {
                if (onComplete) onComplete();
                return;
            }

            let startTime = null;
            const totalLength = points.length - 1;

            function animate(timestamp) {
                if (!startTime) startTime = timestamp + startDelay;
                const elapsed = timestamp - startTime;
                const progress = Math.min(elapsed / duration, 1);

                // Use easing function for smoother animation
                const easedProgress = 1 - Math.pow(1 - progress, 3); // cubic easing out

                const pointsToShow = Math.floor(easedProgress * totalLength) + 1;

                // Draw line up to current progress
                ctx.strokeStyle = strokeStyle;
                ctx.lineWidth = lineWidth;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.beginPath();

                for (let i = 0; i < Math.min(pointsToShow, points.length); i++) {
                    if (i === 0) {
                        ctx.moveTo(points[i].x, points[i].y);
                    } else {
                        ctx.lineTo(points[i].x, points[i].y);
                    }
                }

                // If we're between points, interpolate
                if (pointsToShow < points.length && easedProgress < 1) {
                    const lastIndex = Math.floor(easedProgress * totalLength);
                    const nextIndex = Math.min(lastIndex + 1, points.length - 1);
                    const segmentProgress = (easedProgress * totalLength) - lastIndex;

                    if (lastIndex < points.length - 1) {
                        const x = points[lastIndex].x + (points[nextIndex].x - points[lastIndex].x) * segmentProgress;
                        const y = points[lastIndex].y + (points[nextIndex].y - points[lastIndex].y) * segmentProgress;
                        ctx.lineTo(x, y);
                    }
                }

                ctx.stroke();

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else if (onComplete) {
                    onComplete();
                }
            }

            requestAnimationFrame(animate);
        }

        // Function for animating smooth curves using bezier curves
        function animateSmoothCurvePath(ctx, points, options = {}) {
            const {
                duration = 800,
                strokeStyle = '#8b5cf6',
                lineWidth = 2.5,
                onComplete = null,
                startDelay = 0,
                smoothness = 0.3 // Control point distance factor
            } = options;

            if (points.length < 2) {
                if (onComplete) onComplete();
                return;
            }

            // Calculate control points for smooth bezier curves using Catmull-Rom spline approach
            function getControlPoints(p0, p1, p2, p3, smoothness) {
                // Calculate tangent vectors for smooth curves
                const t1x = (p2.x - p0.x) * smoothness;
                const t1y = (p2.y - p0.y) * smoothness;
                const t2x = (p3.x - p1.x) * smoothness;
                const t2y = (p3.y - p1.y) * smoothness;
                
                // Control points positioned along tangent lines
                const cp1x = p1.x + t1x / 3;
                const cp1y = p1.y + t1y / 3;
                const cp2x = p2.x - t2x / 3;
                const cp2y = p2.y - t2y / 3;
                
                return { cp1: { x: cp1x, y: cp1y }, cp2: { x: cp2x, y: cp2y } };
            }

            let startTime = null;
            const totalLength = points.length - 1;

            function animate(timestamp) {
                if (!startTime) startTime = timestamp + startDelay;
                const elapsed = timestamp - startTime;
                const progress = Math.min(elapsed / duration, 1);

                // Use easing function for smoother animation
                const easedProgress = 1 - Math.pow(1 - progress, 3); // cubic easing out

                const segmentsToShow = easedProgress * totalLength;
                const fullSegments = Math.floor(segmentsToShow);
                const partialSegment = segmentsToShow - fullSegments;

                // Draw curve up to current progress
                ctx.strokeStyle = strokeStyle;
                ctx.lineWidth = lineWidth;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.beginPath();
                ctx.moveTo(points[0].x, points[0].y);

                // Draw complete segments
                for (let i = 0; i < fullSegments && i < points.length - 1; i++) {
                    const p0 = i > 0 ? points[i - 1] : points[i];
                    const p1 = points[i];
                    const p2 = points[i + 1];
                    const p3 = i < points.length - 2 ? points[i + 2] : p2;

                    const { cp1, cp2 } = getControlPoints(p0, p1, p2, p3, smoothness);
                    
                    ctx.bezierCurveTo(cp1.x, cp1.y, cp2.x, cp2.y, p2.x, p2.y);
                }

                // Draw partial segment if needed
                if (partialSegment > 0 && fullSegments < points.length - 1) {
                    const i = fullSegments;
                    const p0 = i > 0 ? points[i - 1] : points[i];
                    const p1 = points[i];
                    const p2 = points[i + 1];
                    const p3 = i < points.length - 2 ? points[i + 2] : p2;

                    const { cp1, cp2 } = getControlPoints(p0, p1, p2, p3, smoothness);
                    
                    // Calculate intermediate point on bezier curve
                    const t = partialSegment;
                    const x = Math.pow(1-t, 3) * p1.x + 3 * Math.pow(1-t, 2) * t * cp1.x + 3 * (1-t) * Math.pow(t, 2) * cp2.x + Math.pow(t, 3) * p2.x;
                    const y = Math.pow(1-t, 3) * p1.y + 3 * Math.pow(1-t, 2) * t * cp1.y + 3 * (1-t) * Math.pow(t, 2) * cp2.y + Math.pow(t, 3) * p2.y;
                    
                    ctx.bezierCurveTo(cp1.x, cp1.y, 
                                    cp1.x + (cp2.x - cp1.x) * t, cp1.y + (cp2.y - cp1.y) * t, 
                                    x, y);
                }

                ctx.stroke();

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else if (onComplete) {
                    onComplete();
                }
            }

            requestAnimationFrame(animate);
        }

        function drawHomeCashflowChart(currentMonthData, lastMonthData, yAxisMax) {
            const canvas = document.getElementById('homeCashflowCanvas');
            if (!canvas) return;

            // Set canvas size to match container
            const container = canvas.parentElement;
            const rect = container.getBoundingClientRect();
            const containerHeight = Math.max(rect.height, 250); // Minimum 250px height

            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = containerHeight * window.devicePixelRatio;
            canvas.style.width = rect.width + 'px';
            canvas.style.height = containerHeight + 'px';

            const ctx = canvas.getContext('2d');
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

            const width = rect.width;
            const height = containerHeight;

            // Clear canvas
            ctx.clearRect(0, 0, width, height);

            // Chart dimensions - minimal margins for edge-to-edge appearance
            const margin = { top: 25, right: 5, bottom: 10, left: 5 };
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            // Helper functions
            const xScale = (day) => margin.left + (day / 31) * chartWidth;
            const yScale = (amount) => margin.top + chartHeight - (amount / yAxisMax) * chartHeight;

            // Draw reference line at current month's latest value
            const currentValue = currentMonthData.length > 0 ? currentMonthData[currentMonthData.length - 1].cumulative : 0;
            const currentY = yScale(currentValue);

            ctx.strokeStyle = '#9ca3af';
            ctx.lineWidth = 1;
            ctx.setLineDash([4, 4]); // Dashed line
            ctx.beginPath();
            ctx.moveTo(margin.left, currentY);
            ctx.lineTo(margin.left + chartWidth, currentY);
            ctx.stroke();

            // Current amount label
            ctx.fillStyle = '#6b7280';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText(`$${(currentValue / 1000).toFixed(1)}k`, 10, currentY - 8);

            // Reset line dash for chart lines
            ctx.setLineDash([]);

            // Draw last month data (gray, thinner)
            if (lastMonthData.length > 0) {
                ctx.strokeStyle = '#d1d5db';
                ctx.lineWidth = 1.5;
                ctx.beginPath();

                lastMonthData.forEach((point, index) => {
                    const x = xScale(point.day);
                    const y = yScale(point.cumulative);

                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });

                ctx.stroke();
            }

            // Draw current month data (purple color, thicker) with animation
            if (currentMonthData.length > 0) {
                const gradient = ctx.createLinearGradient(0, 0, 0, height);
                gradient.addColorStop(0, '#8b5cf6');
                gradient.addColorStop(1, '#7c3aed');

                // Pre-fill the area
                ctx.globalAlpha = 0.1;
                ctx.fillStyle = gradient;
                ctx.beginPath();
                currentMonthData.forEach((point, index) => {
                    const x = xScale(point.day);
                    const y = yScale(point.cumulative);
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.lineTo(xScale(currentMonthData[currentMonthData.length - 1].day), yScale(0));
                ctx.lineTo(xScale(currentMonthData[0].day), yScale(0));
                ctx.closePath();
                ctx.fill();
                ctx.globalAlpha = 1;

                // Convert data to points for animation
                const points = currentMonthData.map(point => ({
                    x: xScale(point.day),
                    y: yScale(point.cumulative)
                }));

                // Animate only the line from left to right
                animateLinePath(ctx, points, {
                    strokeStyle: gradient,
                    lineWidth: 2.5,
                    duration: 1000
                });
            }
        }

        // Spinner functions for net worth charts
        function showNetWorthSpinner() {
            const container = document.getElementById('homeNetWorthChart');
            if (container) {
                container.classList.add('loading');
            }
        }

        function hideNetWorthSpinner() {
            const container = document.getElementById('homeNetWorthChart');
            if (container) {
                container.classList.remove('loading');
            }
        }

        function showAccountsNetWorthSpinner() {
            const container = document.getElementById('accountsNetWorthChart');
            if (container) {
                container.classList.add('loading');
            }
        }

        function hideAccountsNetWorthSpinner() {
            const container = document.getElementById('accountsNetWorthChart');
            if (container) {
                container.classList.remove('loading');
            }
        }

        async function updateHomeNetWorthWithChart(range) {
            console.log('=== HOME NET WORTH DEBUG ===');
            console.log('Range:', range);
            console.log('Savings accounts:', savingsAccounts);
            
            // Show loading spinner
            showNetWorthSpinner();
            
            try {
                const balances = await loadAccountBalances();
                const today = getCurrentDate();

                // Calculate current net worth (assets - liabilities)
                let totalAssets = 0;
                let totalLiabilities = 0;

                // Use global savingsAccounts (already loaded from API)
                const accountsData = savingsAccounts || [];
                console.log('Accounts data:', accountsData);

            // Include balance history data (for manually entered accounts)
            Object.keys(balances).forEach(accountName => {
                const accountBalances = balances[accountName];
                const currentBalance = getTotalBalanceForDate(accountBalances, today);

                // Check if this account is a liability
                const accountInfo = accountsData.find(acc => acc.id === accountName);
                const isLiability = accountInfo && accountInfo.type === 'liability';

                if (isLiability) {
                    totalLiabilities += currentBalance;
                } else {
                    totalAssets += currentBalance;
                }
            });

                // Include API account balances (only use real data, no fallbacks)
                let hasRealBalanceData = false;
                accountsData.forEach(account => {
                    let balance = 0;
                    let hasBalance = false;
                    
                    console.log('Processing account:', account.name, 'currentBalance:', account.currentBalance);
                    
                    // Use currentBalance from processed account data
                    if (account.currentBalance !== null && account.currentBalance !== undefined && typeof account.currentBalance === 'number') {
                        balance = account.currentBalance;
                        hasBalance = true;
                        hasRealBalanceData = true;
                        console.log('Found balance for', account.name, ':', balance);
                    } else {
                        console.log('No balance found for', account.name);
                    }
                    
                    // Only process accounts with actual balance data
                    if (hasBalance) {
                        // Check if this account is a liability
                        const isLiability = account.type === 'liability' || 
                                           account.type === 'credit' || 
                                           account.subtype === 'credit_card' || 
                                           account.type === 'mortgage' || 
                                           account.type === 'student_loan';

                        if (isLiability) {
                            totalLiabilities += Math.abs(balance); // Ensure liabilities are positive for calculation
                        } else {
                            totalAssets += balance;
                        }
                    }
                });

                const totalNetWorth = totalAssets - totalLiabilities;

                // Check if we have any real account data or balances
                if (!hasRealBalanceData || (totalNetWorth === 0 && accountsData.length === 0)) {
                    showHomeNetWorthPlaceholder();
                    return;
                }

                // Hide placeholders and show chart
                hideChartPlaceholders();

                // Use the actual net worth (no demo values)
                const displayNetWorth = totalNetWorth;
                console.log('Calculated net worth:', displayNetWorth);
                console.log('Total assets:', totalAssets);
                console.log('Total liabilities:', totalLiabilities);

                // Generate net worth history for chart
                const netWorthHistory = await generateNetWorthHistory(displayNetWorth, range);
                console.log('Net worth history:', netWorthHistory);

                // Draw the net worth chart
                console.log(' About to call drawHomeNetWorthChart with data:', netWorthHistory);
                console.log(' Function exists:', typeof drawHomeNetWorthChart);
                try {
                    drawHomeNetWorthChart(netWorthHistory);
                    console.log(' drawHomeNetWorthChart call completed');
                } catch (error) {
                    console.error(' Error in drawHomeNetWorthChart:', error);
                }

                // Update the title and change indicator
                updateHomeNetWorthDisplay(displayNetWorth, range);
                console.log('================================');
            } catch (error) {
                console.error('Error updating home net worth chart:', error);
                showHomeNetWorthPlaceholder();
            } finally {
                hideNetWorthSpinner();
            }
        }

        async function generateNetWorthHistory(currentValue, range) {
            // Try snapshot-based history first (most efficient)
            try {
                console.log(' Attempting snapshot-based net worth history');
                const snapshotHistory = await generateSnapshotBasedNetWorth(currentValue, range);
                
                // If we got more than one data point, use snapshot-based history
                if (snapshotHistory.length > 1) {
                    console.log(' Using snapshot-based net worth history with', snapshotHistory.length, 'points');
                    return snapshotHistory;
                }
            } catch (error) {
                console.log(' Snapshot-based history failed, trying transaction-based');
                
                // Fallback to transaction-based history
                try {
                    console.log(' Attempting transaction-based net worth history');
                    const transactionHistory = await generateTransactionBasedNetWorth(currentValue, range);
                    
                    // If we got more than one data point, use transaction-based history
                    if (transactionHistory.length > 1) {
                        console.log(' Using transaction-based net worth history with', transactionHistory.length, 'points');
                        return transactionHistory;
                    }
                } catch (error) {
                    console.log(' Transaction-based history failed, falling back to balance-based');
                }
            }
            
            // Fallback to balance-based history
            console.log(' Using balance-based net worth history');
            const balances = await loadAccountBalances();
            const accountsData = savingsAccounts || [];

            // Get all available dates with balance data
            const availableDates = getAllAvailableDates(balances).sort();

            if (availableDates.length === 0) {
                // Return minimal data if no historical data exists
                return [{ date: new Date().toISOString().split('T')[0], value: currentValue }];
            }

            // Determine sampling frequency based on range
            let sampleEveryNDays = 1;
            let maxDaysBack = 30;

            switch (range) {
                case '1m':
                    maxDaysBack = 30;
                    sampleEveryNDays = 1; // Daily if available
                    break;
                case '3m':
                    maxDaysBack = 90;
                    sampleEveryNDays = 3; // Every 3 days
                    break;
                case '6m':
                    maxDaysBack = 180;
                    sampleEveryNDays = 7; // Weekly
                    break;
                case 'ytd':
                    const now = new Date();
                    const startOfYear = new Date(now.getFullYear(), 0, 1);
                    maxDaysBack = Math.floor((now - startOfYear) / (1000 * 60 * 60 * 24));
                    sampleEveryNDays = maxDaysBack > 180 ? 14 : 7; // Bi-weekly or weekly
                    break;
                case '1y':
                    maxDaysBack = 365;
                    sampleEveryNDays = 14; // Bi-weekly
                    break;
                case 'all':
                default:
                    maxDaysBack = 1095; // 3 years
                    sampleEveryNDays = 30; // Monthly
                    break;
            }

            // Calculate cutoff date using local time to avoid timezone issues
            const today = new Date();
            const cutoffDate = new Date();
            cutoffDate.setDate(today.getDate() - maxDaysBack);
            const cutoffDateStr = cutoffDate.getFullYear() + '-' + 
                String(cutoffDate.getMonth() + 1).padStart(2, '0') + '-' + 
                String(cutoffDate.getDate()).padStart(2, '0');

            // Filter dates within range
            const relevantDates = availableDates.filter(date => date >= cutoffDateStr);

            if (relevantDates.length === 0) {
                // Return minimal data if no data in range
                return [{ date: new Date().toISOString().split('T')[0], value: currentValue }];
            }

            // Sample dates based on frequency
            const sampledDates = [];
            let lastSampledIndex = -sampleEveryNDays; // Start so first date gets included

            for (let i = 0; i < relevantDates.length; i++) {
                if (i - lastSampledIndex >= sampleEveryNDays || i === relevantDates.length - 1) {
                    sampledDates.push(relevantDates[i]);
                    lastSampledIndex = i;
                }
            }

            // Calculate real net worth (assets - liabilities) for each sampled date
            const history = [];

            sampledDates.forEach(date => {
                let assetsTotal = 0;
                let liabilitiesTotal = 0;

                // Sum up all accounts for this date
                Object.keys(balances).forEach(accountId => {
                    const accountBalances = balances[accountId] || {};
                    const accountInfo = accountsData.find(acc => acc.id === accountId);
                    const isLiability = accountInfo && accountInfo.type === 'liability';

                    // Get balance for this date, or closest previous date
                    let balance = 0;
                    if (accountBalances[date]) {
                        const balanceData = accountBalances[date];
                        balance = balanceData && typeof balanceData === 'object' ? balanceData.amount : balanceData;
                    } else {
                        // Find closest previous date with balance
                        const accountDates = Object.keys(accountBalances).filter(d => d <= date).sort();
                        if (accountDates.length > 0) {
                            const closestDate = accountDates[accountDates.length - 1];
                            const balanceData = accountBalances[closestDate];
                            balance = balanceData && typeof balanceData === 'object' ? balanceData.amount : balanceData;
                        }
                    }

                    if (isLiability) {
                        liabilitiesTotal += balance || 0;
                    } else {
                        assetsTotal += balance || 0;
                    }
                });

                const netWorth = assetsTotal - liabilitiesTotal;

                history.push({
                    date: date,
                    value: Math.max(0, netWorth)
                });
            });

            return history;
        }

        /**
         * Generate net worth history based on stored snapshots
         */
        async function generateSnapshotBasedNetWorth(currentNetWorth, range) {
            console.log(' Generating snapshot-based net worth for range:', range);
            
            // Determine how many days to fetch based on range
            let totalDays = 30;
            
            switch (range) {
                case '1m':
                    totalDays = 30;
                    break;
                case '3m':
                    totalDays = 90;
                    break;
                case '6m':
                    totalDays = 180;
                    break;
                case 'ytd':
                    const now = new Date();
                    const startOfYear = new Date(now.getFullYear(), 0, 1);
                    totalDays = Math.floor((now - startOfYear) / (1000 * 60 * 60 * 24));
                    break;
                case '1y':
                    totalDays = 365;
                    break;
                case 'all':
                default:
                    totalDays = 365;
                    break;
            }
            
            try {
                // Calculate start date
                const endDate = new Date();
                const startDate = new Date();
                startDate.setDate(endDate.getDate() - totalDays);
                
                console.log(' Fetching snapshots from', startDate.toISOString().split('T')[0], 'for', totalDays, 'days');
                
                // Fetch snapshots from API
                const sessionToken = await window.plaidService.getClerkSessionToken();
                console.log(' Session token check:', sessionToken ? 'Found' : 'Missing');
                if (!sessionToken) {
                    console.log(' No session token, falling back to current value only');
                    return [{ date: endDate.toISOString().split('T')[0], value: currentNetWorth }];
                }
                
                const response = await fetch(`${window.plaidService.baseUrl}/api/snapshots/net-worth?start_date=${startDate.toISOString().split('T')[0]}&days=${totalDays}`, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${sessionToken}`,
                        'Content-Type': 'application/json'
                    }
                });
                
                if (!response.ok) {
                    console.log(' Failed to fetch snapshots, status:', response.status);
                    return [{ date: endDate.toISOString().split('T')[0], value: currentNetWorth }];
                }
                
                const data = await response.json();
                const snapshots = data.snapshots || [];
                console.log(' Fetched', snapshots.length, 'snapshots');
                
                if (snapshots.length === 0) {
                    console.log(' No snapshots found, falling back to current value only');
                    return [{ date: endDate.toISOString().split('T')[0], value: currentNetWorth }];
                }
                
                // Return snapshots in the expected format
                const history = snapshots.map(snapshot => ({
                    date: snapshot.date,
                    value: snapshot.value
                }));
                
                console.log(' Snapshot range:', Math.min(...history.map(h => h.value)), 'to', Math.max(...history.map(h => h.value)));
                
                return history;
                
            } catch (error) {
                console.error(' Error generating snapshot-based net worth:', error);
                // Fallback to current value only
                return [{ date: new Date().toISOString().split('T')[0], value: currentNetWorth }];
            }
        }

        /**
         * Generate net worth history based on transaction data
         */
        async function generateTransactionBasedNetWorth(currentNetWorth, range) {
            console.log(' Generating transaction-based net worth for range:', range);
            
            // Determine sampling parameters based on range
            let totalDays = 30;
            let sampleEveryNDays = 1;
            
            switch (range) {
                case '1m':
                    totalDays = 30;
                    sampleEveryNDays = 1; // Daily
                    break;
                case '3m':
                    totalDays = 90;
                    sampleEveryNDays = 3; // Every 3 days
                    break;
                case '6m':
                    totalDays = 180;
                    sampleEveryNDays = 7; // Weekly
                    break;
                case 'ytd':
                    const now = new Date();
                    const startOfYear = new Date(now.getFullYear(), 0, 1);
                    totalDays = Math.floor((now - startOfYear) / (1000 * 60 * 60 * 24));
                    sampleEveryNDays = totalDays > 180 ? 14 : 7; // Bi-weekly or weekly
                    break;
                case '1y':
                    totalDays = 365;
                    sampleEveryNDays = 14; // Bi-weekly
                    break;
                case 'all':
                default:
                    totalDays = 365;
                    sampleEveryNDays = 30; // Monthly
                    break;
            }
            
            try {
                // Fetch transaction data for the date range
                const endDate = new Date();
                const startDate = new Date();
                startDate.setDate(endDate.getDate() - totalDays);
                
                console.log(' Fetching transactions from', startDate.toISOString().split('T')[0], 'to', endDate.toISOString().split('T')[0]);
                
                // Use the plaid service to fetch transactions
                const sessionToken = await window.plaidService.getClerkSessionToken();
                if (!sessionToken) {
                    console.log(' No session token, falling back to current value only');
                    return [{ date: endDate.toISOString().split('T')[0], value: currentNetWorth }];
                }
                
                const response = await fetch(`${window.plaidService.baseUrl}/api/transactions/range?start_date=${startDate.toISOString().split('T')[0]}&days=${totalDays}&category_summary=false`, {
                    method: 'GET',
                    headers: {
                        'Authorization': `Bearer ${sessionToken}`,
                        'Content-Type': 'application/json'
                    }
                });
                
                if (!response.ok) {
                    console.log(' Failed to fetch transactions, falling back to current value only');
                    return [{ date: endDate.toISOString().split('T')[0], value: currentNetWorth }];
                }
                
                const data = await response.json();
                const transactions = data.transactions || [];
                console.log(' Fetched', transactions.length, 'transactions');
                
                if (transactions.length > 0) {
                    console.log(' Transaction date range:', 
                        Math.min(...transactions.map(t => new Date(t.date))).toISOString().split('T')[0], 
                        'to',
                        Math.max(...transactions.map(t => new Date(t.date))).toISOString().split('T')[0]
                    );
                    console.log(' Sample transactions:', transactions.slice(0, 3).map(t => ({
                        date: t.date,
                        amount: t.amount,
                        name: t.name
                    })));
                }
                
                if (transactions.length === 0) {
                    console.log(' No transactions found, falling back to current value only');
                    return [{ date: endDate.toISOString().split('T')[0], value: currentNetWorth }];
                }
                
                // Generate historical net worth points
                const history = [];
                let runningNetWorth = currentNetWorth;
                
                // Create sample points going backwards in time
                for (let dayOffset = 0; dayOffset <= totalDays; dayOffset += sampleEveryNDays) {
                    const currentDate = new Date(endDate);
                    currentDate.setDate(endDate.getDate() - dayOffset);
                    const dateStr = currentDate.toISOString().split('T')[0];
                    
                    if (dayOffset === 0) {
                        // Current date - use current net worth
                        history.unshift({ date: dateStr, value: currentNetWorth });
                    } else {
                        // Calculate net worth for this historical date
                        // Find transactions between this date and the next sample point
                        const nextDate = new Date(currentDate);
                        nextDate.setDate(currentDate.getDate() + sampleEveryNDays);
                        
                        const periodTransactions = transactions.filter(txn => {
                            const txnDate = new Date(txn.date);
                            return txnDate >= currentDate && txnDate < nextDate;
                        });
                        
                        // Apply transaction impacts to calculate historical balance
                        // Since we're working backwards, we need to reverse transaction effects
                        let periodImpact = 0;
                        periodTransactions.forEach(txn => {
                            // Working backwards: remove the effect of transactions that happened after this date
                            // Positive amounts are expenses (money out), negative are income (money in)
                            // To go back in time: add back expenses, subtract income
                            periodImpact += txn.amount; 
                        });
                        
                        runningNetWorth -= periodImpact; // Subtract the period impact to go backwards
                        history.unshift({ date: dateStr, value: Math.max(0, runningNetWorth) });
                    }
                }
                
                console.log(' Generated', history.length, 'net worth data points');
                console.log(' Net worth range:', Math.min(...history.map(h => h.value)), 'to', Math.max(...history.map(h => h.value)));
                
                return history;
                
            } catch (error) {
                console.error(' Error generating transaction-based net worth:', error);
                // Fallback to current value only
                return [{ date: new Date().toISOString().split('T')[0], value: currentNetWorth }];
            }
        }



        let homeNetWorthChart = null;
        
        function drawHomeNetWorthChart(data) {
            console.log(' Drawing home net worth chart with Chart.js, data:', data);
            const ctx = document.getElementById('homeNetWorthCanvas').getContext('2d');
            if (!ctx) {
                console.log(' Home net worth canvas not found');
                return;
            }

            // Destroy existing chart if it exists
            if (homeNetWorthChart) {
                homeNetWorthChart.destroy();
            }

            if (!data.length) return;

            // Prepare data for Chart.js
            const labels = data.map(d => d.date);
            const netWorthData = data.map(d => d.value);
            
            // Calculate fixed scale bounds to prevent auto-scaling
            const minValue = Math.min(...netWorthData);
            const maxValue = Math.max(...netWorthData);
            const range = maxValue - minValue;
            const padding = range * 0.1; // 10% padding
            const yMin = minValue - padding;
            const yMax = maxValue + padding;

            // Create separate datasets for positive and negative sections
            const positiveData = netWorthData.map(value => value >= 0 ? value : null);
            const negativeData = netWorthData.map(value => value < 0 ? value : null);

            homeNetWorthChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Net Worth (Positive)',
                        data: positiveData,
                        borderColor: '#5fa42e', // Green for positive
                        backgroundColor: 'transparent',
                        tension: 0.6,
                        fill: false,
                        pointRadius: 0,
                        borderWidth: 3,
                        pointHitRadius: 20,
                        pointBackgroundColor: 'transparent',
                        pointBorderColor: 'transparent',
                        pointBorderWidth: 0,
                        spanGaps: false,
                        segment: {
                            borderColor: (ctx) => ctx.p0.parsed.y >= 0 ? '#5fa42e' : 'transparent'
                        }
                    }, {
                        label: 'Net Worth (Negative)',
                        data: negativeData,
                        borderColor: '#9ca3af', // Gray for negative
                        backgroundColor: 'transparent',
                        tension: 0.6,
                        fill: false,
                        pointRadius: 0,
                        borderWidth: 3,
                        pointHitRadius: 20,
                        pointBackgroundColor: 'transparent',
                        pointBorderColor: 'transparent',
                        pointBorderWidth: 0,
                        spanGaps: false,
                        segment: {
                            borderColor: (ctx) => ctx.p0.parsed.y < 0 ? '#9ca3af' : 'transparent'
                        }
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: {
                        padding: 0
                    },
                    animation: {
                        duration: 1000,
                        easing: 'easeInOutQuart',
                        onProgress: function(animation) {
                            // Store animation progress for gradient plugin
                            this.gradientProgress = animation.currentStep / animation.numSteps;
                        },
                        onComplete: function() {
                            this.gradientProgress = 1;
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: { enabled: false }
                    },
                    scales: {
                        x: {
                            grid: { display: false },
                            ticks: { display: false },
                            border: { display: false }
                        },
                        y: {
                            grid: { display: false },
                            border: { display: false },
                            ticks: { display: false },
                            min: yMin,
                            max: yMax
                        }
                    },
                    interaction: { intersect: false, mode: 'nearest' },
                    hover: { intersect: false, mode: 'nearest', enabled: false },
                    elements: {
                        point: {
                            hitRadius: 30,
                            hoverRadius: 0,
                            radius: 0,
                            hoverBackgroundColor: 'transparent',
                            hoverBorderColor: 'transparent',
                            hoverBorderWidth: 0
                        },
                        line: { tension: 0.6 }
                    }
                },
                plugins: [{
                    id: 'absoluteGradient',
                    beforeDraw: function(chart, args, options) {
                        const ctx = chart.ctx;
                        const chartArea = chart.chartArea;
                        const yAxis = chart.scales.y;
                        const xAxis = chart.scales.x;
                        
                        if (!chart.data.datasets[0].data.length) return;
                        
                        // Skip gradient animation if chart is being interacted with
                        let animationProgress = 1;
                        if (!chart.isInteracting) {
                            animationProgress = chart.gradientProgress !== undefined ? chart.gradientProgress : 1;
                        }
                        
                        // Calculate visible width based on animation progress
                        const chartWidth = chartArea.right - chartArea.left;
                        const visibleWidth = chartWidth * animationProgress;
                        
                        // Simple gradient fill from bottom to top (temporary fix)
                        const gradient = ctx.createLinearGradient(0, chartArea.bottom, 0, chartArea.top);
                        gradient.addColorStop(0, 'rgba(95, 164, 46, 0)'); // Transparent at bottom
                        gradient.addColorStop(0.2, 'rgba(95, 164, 46, 0.02)');
                        gradient.addColorStop(0.4, 'rgba(95, 164, 46, 0.05)');
                        gradient.addColorStop(1, 'rgba(95, 164, 46, 0.25)'); // Opaque at top
                        
                        // Get data points and chart bottom position
                        const dataPoints = chart.data.datasets[0].data;
                        const chartBottom = chartArea.bottom;
                        
                        // Set up clipping region for animated width
                        ctx.save();
                        ctx.rect(chartArea.left, chartArea.top, visibleWidth, chartArea.bottom - chartArea.top);
                        ctx.clip();
                        
                        // Draw filled area from data line to chart bottom (visual bottom)
                        ctx.fillStyle = gradient;
                        ctx.beginPath();
                        
                        // Start at left edge of chart area, at bottom
                        ctx.moveTo(xAxis.getPixelForValue(0), chartBottom);
                        
                        // Draw line following the data points
                        dataPoints.forEach((point, index) => {
                            if (point !== null) {
                                const x = xAxis.getPixelForValue(index);
                                const y = yAxis.getPixelForValue(point);
                                ctx.lineTo(x, y);
                            }
                        });
                        
                        // Complete the fill back to chart bottom at right edge
                        ctx.lineTo(xAxis.getPixelForValue(dataPoints.length - 1), chartBottom);
                        ctx.closePath();
                        ctx.fill();
                        
                        ctx.restore();
                    }
                }, {
                    id: 'horizontalLine',
                    afterDraw: function(chart) {
                        const ctx = chart.ctx;
                        const yAxis = chart.scales.y;
                        
                        if (!chart.data.datasets[0].data.length) return;
                        
                        // Hide horizontal line during drag interaction
                        if (chart.isInteracting) return;
                        
                        // Check if there's an active crosshair interaction
                        let currentValue, currentIndex, displayDate = '';
                        if (chart.activeIndex !== undefined && chart.activeIndex >= 0) {
                            currentIndex = chart.activeIndex;
                            currentValue = chart.data.datasets[0].data[currentIndex];
                            // Format date from label to friendly format
                            const dateLabel = chart.data.labels[currentIndex];
                            const date = new Date(dateLabel);
                            const friendlyDate = date.toLocaleDateString('en-US', { 
                                month: 'short', 
                                day: 'numeric' 
                            });
                            displayDate = ` (${friendlyDate})`;
                        } else {
                            // Default to latest value
                            currentIndex = chart.data.datasets[0].data.length - 1;
                            currentValue = chart.data.datasets[0].data[currentIndex];
                        }
                        
                        const yPosition = yAxis.getPixelForValue(currentValue);
                        
                        // Draw dashed horizontal line edge-to-edge
                        ctx.save();
                        ctx.strokeStyle = '#9ca3af';
                        ctx.lineWidth = 1;
                        ctx.setLineDash([4, 4]);
                        ctx.globalAlpha = 0.8;
                        
                        ctx.beginPath();
                        ctx.moveTo(chart.chartArea.left, yPosition);
                        ctx.lineTo(chart.chartArea.right, yPosition);
                        ctx.stroke();
                        
                        // Draw amount label above the line with date
                        ctx.setLineDash([]);
                        ctx.fillStyle = '#6b7280';
                        ctx.font = '12px system-ui, -apple-system, sans-serif';
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'bottom';
                        
                        const formattedValue = `$${(currentValue / 1000).toFixed(1)}k${displayDate}`;
                        ctx.fillText(formattedValue, chart.chartArea.left + 8, yPosition - 8);
                        
                        ctx.restore();
                    }
                }]
            });

            // Add interactive crosshair system (will be implemented in unified system)
            setupNetWorthChartInteraction(homeNetWorthChart, 'homeNetWorthOverlay', 'homeNetWorthCrosshair');
            
            console.log(' Home net worth Chart.js chart created successfully');
        }

        function updateHomeNetWorthDisplay(totalNetWorth, range) {
            // Calculate change percentage based on range (mock data for now)
            let changePercent = 0;
            let rangeLabel = '';

            switch (range) {
                case '1m':
                    changePercent = 5.2;
                    rangeLabel = '1 month';
                    break;
                case '3m':
                    changePercent = 12.8;
                    rangeLabel = '3 months';
                    break;
                case '6m':
                    changePercent = 18.5;
                    rangeLabel = '6 months';
                    break;
                case 'ytd':
                    changePercent = 15.3;
                    rangeLabel = 'year to date';
                    break;
                case '1y':
                    changePercent = 22.1;
                    rangeLabel = '1 year';
                    break;
                case 'all':
                    changePercent = 0.3;
                    rangeLabel = 'all time';
                    break;
            }

            const netWorthTitle = document.getElementById('netWorthTitle');
            const netWorthChange = document.getElementById('netWorthChange');

            if (netWorthTitle) {
                netWorthTitle.textContent = `${formatCurrency(totalNetWorth)} Net Worth`;
            }

            if (netWorthChange) {
                const isPositive = changePercent > 0;
                const arrow = isPositive ? 'arrow-up' : 'arrow-down';
                const color = isPositive ? '#5fa42e' : '#ef4444';
                const changeAmount = (totalNetWorth * changePercent / 100).toFixed(2);
                netWorthChange.innerHTML = `
                        <i data-lucide="${arrow}" class="w-4 h-4 inline" style="color: ${color}"></i>
                        <span style="color: ${color}">$${Math.abs(changeAmount)} (${Math.abs(changePercent).toFixed(1)}%)</span>
                    `;

                // Reinitialize lucide icons
                if (window.safeInitLucideIcons) {
                    window.safeInitLucideIcons();
                }
            }
        }

        async function updateHomeNetWorth() {
            await updateHomeNetWorthWithChart('all'); // Default to all time view to match active button
        }

        function scrollToTransactions() {
            // Scroll to transactions section on cashflow page
            setTimeout(() => {
                const transactionsCard = document.querySelector('#expensesListTitle');
                if (transactionsCard) {
                    transactionsCard.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            }, 300);
        }

        function handleNetWorthCardClick(event) {
            // Prevent navigation if clicking on dropdown menu or menu button
            const dropdown = document.getElementById('netWorthDropdown');
            const menuBtn = document.getElementById('netWorthMenuBtn');

            if (dropdown && (dropdown.contains(event.target) || menuBtn.contains(event.target))) {
                event.stopPropagation();
                return;
            }

            // Otherwise navigate to screen 2
            goToScreen(2);
        }

        // Home screen range picker functionality  
        function initializeHomeRangePickers() {
            // Cashflow dropdown is initialized with onclick handlers in HTML
            // Net Worth now uses dropdown menu instead of bottom picker
        }

        async function updateHomeCashflowWithRange(range) {
            console.log(' Updating home cashflow chart with range:', range);
            const expenses = await loadExpenses();
            console.log(' Loaded expenses for cashflow:', Object.keys(expenses).length, 'dates');
            const today = new Date();
            const currentYear = today.getFullYear();
            const currentMonth = today.getMonth();

            let currentPeriodData = [];
            let lastPeriodData = [];

            switch (range) {
                case 'week':
                    // This week vs last week
                    // Get current week's dates (Monday to Sunday)
                    const thisWeek = [];
                    const lastWeek = [];

                    // Calculate days to Monday (0 = Sunday, 1 = Monday, etc.)
                    const dayOfWeek = today.getDay();
                    const daysFromMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1;

                    // Get this week's dates
                    for (let i = 0; i < 7; i++) {
                        const date = new Date(today);
                        date.setDate(today.getDate() - daysFromMonday + i);
                        thisWeek.push(date.toISOString().split('T')[0]);
                    }

                    // Get last week's dates
                    for (let i = 0; i < 7; i++) {
                        const date = new Date(today);
                        date.setDate(today.getDate() - daysFromMonday - 7 + i);
                        lastWeek.push(date.toISOString().split('T')[0]);
                    }

                    // Calculate cumulative spending for this week and last week
                    let thisWeekCumulative = 0;
                    let lastWeekCumulative = 0;

                    for (let i = 0; i < 7; i++) {
                        const thisDate = thisWeek[i];
                        if (expenses[thisDate]) {
                            const dailyTotal = expenses[thisDate].reduce((sum, exp) => sum + exp.amount, 0);
                            thisWeekCumulative += dailyTotal;
                            currentPeriodData.push({ day: i + 1, cumulative: thisWeekCumulative });
                        } else {
                            currentPeriodData.push({ day: i + 1, cumulative: thisWeekCumulative });
                        }

                        const lastDate = lastWeek[i];
                        if (expenses[lastDate]) {
                            const dailyTotal = expenses[lastDate].reduce((sum, exp) => sum + exp.amount, 0);
                            lastWeekCumulative += dailyTotal;
                            lastPeriodData.push({ day: i + 1, cumulative: lastWeekCumulative });
                        } else {
                            lastPeriodData.push({ day: i + 1, cumulative: lastWeekCumulative });
                        }
                    }
                    break;

                case '1m':
                case 'month':
                    // Current month vs last month
                    const currentMonthKey = `${currentYear}-${String(currentMonth + 1).padStart(2, '0')}`;
                    const lastMonth = currentMonth === 0 ? 11 : currentMonth - 1;
                    const lastMonthYear = currentMonth === 0 ? currentYear - 1 : currentYear;
                    const lastMonthKey = `${lastMonthYear}-${String(lastMonth + 1).padStart(2, '0')}`;

                    currentPeriodData = calculateCumulativeSpending(expenses, currentMonthKey, true);
                    lastPeriodData = calculateCumulativeSpending(expenses, lastMonthKey, false);
                    break;

                case 'year':
                    // This month vs. same month last year
                    const thisMonthKey = `${currentYear}-${String(currentMonth + 1).padStart(2, '0')}`;
                    const sameMonthLastYearKey = `${currentYear - 1}-${String(currentMonth + 1).padStart(2, '0')}`;

                    currentPeriodData = calculateCumulativeSpending(expenses, thisMonthKey, true);
                    lastPeriodData = calculateCumulativeSpending(expenses, sameMonthLastYearKey, false);
                    break;

                case 'average':
                    // This month vs average month over past year
                    const monthKey = `${currentYear}-${String(currentMonth + 1).padStart(2, '0')}`;
                    currentPeriodData = calculateCumulativeSpending(expenses, monthKey, true);

                    // Calculate average spending for each day of the month over past year
                    const dailyAverages = {};
                    let daysCounted = {};

                    // Loop through past 12 months
                    for (let i = 1; i <= 12; i++) {
                        const m = (currentMonth - i + 12) % 12;
                        const y = currentYear - Math.floor((currentMonth - i + 12) / 12);
                        const mk = `${y}-${String(m + 1).padStart(2, '0')}`;

                        // For each day in this month, add to average
                        Object.keys(expenses).forEach(date => {
                            if (date.startsWith(mk)) {
                                const day = parseInt(date.split('-')[2]);
                                const dailyTotal = expenses[date].reduce((sum, exp) => sum + exp.amount, 0);

                                if (!dailyAverages[day]) dailyAverages[day] = 0;
                                if (!daysCounted[day]) daysCounted[day] = 0;

                                dailyAverages[day] += dailyTotal;
                                daysCounted[day]++;
                            }
                        });
                    }

                    // Calculate cumulative average spending
                    let cumulativeAvg = 0;
                    for (let day = 1; day <= 31; day++) {
                        if (daysCounted[day] && daysCounted[day] > 0) {
                            const avgForDay = dailyAverages[day] / daysCounted[day];
                            cumulativeAvg += avgForDay;
                            lastPeriodData.push({ day: day, cumulative: cumulativeAvg });
                        } else if (day <= today.getDate()) {
                            // For days with no data, keep the cumulative total the same
                            lastPeriodData.push({ day: day, cumulative: cumulativeAvg });
                        }
                    }
                    break;

                case 'ytd':
                    // This year vs last year (YTD)
                    let thisYearCumulative = 0;
                    let lastYearCumulative = 0;
                    let dayCount = 0;

                    // Calculate days from Jan 1 to today
                    const startOfYear = new Date(currentYear, 0, 1);
                    const msPerDay = 1000 * 60 * 60 * 24;
                    const daysInYear = Math.floor((today - startOfYear) / msPerDay) + 1;

                    // Loop through each day of the year so far
                    for (let i = 0; i < daysInYear; i++) {
                        const thisYearDate = new Date(currentYear, 0, 1 + i);
                        const lastYearDate = new Date(currentYear - 1, 0, 1 + i);

                        const thisYearKey = `${thisYearDate.getFullYear()}-${String(thisYearDate.getMonth() + 1).padStart(2, '0')}-${String(thisYearDate.getDate()).padStart(2, '0')}`;
                        const lastYearKey = `${lastYearDate.getFullYear()}-${String(lastYearDate.getMonth() + 1).padStart(2, '0')}-${String(lastYearDate.getDate()).padStart(2, '0')}`;

                        // Add this year's expenses
                        if (expenses[thisYearKey]) {
                            const dailyTotal = expenses[thisYearKey].reduce((sum, exp) => sum + exp.amount, 0);
                            thisYearCumulative += dailyTotal;
                        }
                        currentPeriodData.push({ day: i + 1, cumulative: thisYearCumulative });

                        // Add last year's expenses
                        if (expenses[lastYearKey]) {
                            const dailyTotal = expenses[lastYearKey].reduce((sum, exp) => sum + exp.amount, 0);
                            lastYearCumulative += dailyTotal;
                        }
                        lastPeriodData.push({ day: i + 1, cumulative: lastYearCumulative });
                    }
                    break;

                default:
                    // Default to this month vs. last month
                    return await updateHomeCashflowWithRange('month');
                    break;
            }

            // Find the maximum value for y-axis scaling
            const maxCurrent = currentPeriodData.length ? Math.max(...currentPeriodData.map(d => d.cumulative)) : 0;
            const maxLast = lastPeriodData.length ? Math.max(...lastPeriodData.map(d => d.cumulative)) : 0;
            const maxValue = Math.max(maxCurrent, maxLast);

            // Check if we have any spending data
            if (maxValue === 0 && currentPeriodData.length === 0 && lastPeriodData.length === 0) {
                showHomeCashflowPlaceholder();
                return;
            }

            // Hide placeholders and show chart
            hideChartPlaceholders();

            // Round to nearest $100
            const yAxisMax = Math.ceil(maxValue / 100) * 100;

            // Update legend labels based on range
            updateCashflowLegend(range);

            // Draw the chart with updated data
            drawHomeCashflowChartWithRange(currentPeriodData, lastPeriodData, yAxisMax, range);
        }

        function updateCashflowLegend(range) {
            const legend = document.getElementById('cashflowLegend');
            if (!legend) return;

            let currentLabel, previousLabel;

            switch (range) {
                case 'week':
                    currentLabel = 'This week';
                    previousLabel = 'Last week';
                    break;
                case '1m':
                case 'month':
                    currentLabel = 'This month';
                    previousLabel = 'Last month';
                    break;
                case 'year':
                    currentLabel = 'This month';
                    previousLabel = 'Same month last year';
                    break;
                case 'average':
                    currentLabel = 'This month';
                    previousLabel = 'Monthly average';
                    break;
                case 'ytd':
                    currentLabel = 'This year';
                    previousLabel = 'Last year (YTD)';
                    break;
                default:
                    currentLabel = 'This month';
                    previousLabel = 'Last month';
                    break;
            }

            const legendLabels = legend.querySelectorAll('.legend-label');
            if (legendLabels.length >= 2) {
                legendLabels[0].textContent = currentLabel;
                legendLabels[1].textContent = previousLabel;
            }
        }

        function toggleCashflowDropdown() {
            const dropdown = document.getElementById('cashflowDropdown');
            const menuBtn = document.getElementById('cashflowMenuBtn');
            const isCurrentlyOpen = dropdown && dropdown.classList.contains('show');

            // Close all dropdowns first
            closeAllDropdowns();

            // If this dropdown wasn't open, open it
            if (dropdown && menuBtn && !isCurrentlyOpen) {
                dropdown.classList.add('show');

                if (dropdown.classList.contains('show')) {
                    // Don't position with inline styles - use CSS instead
                    // This ensures the dropdown scrolls with the section

                    // Close dropdown when clicking outside
                    document.addEventListener('click', closeCashflowDropdownOutside);
                } else {
                    document.removeEventListener('click', closeCashflowDropdownOutside);
                }
            }
        }

        function closeCashflowDropdownOutside(event) {
            const dropdown = document.getElementById('cashflowDropdown');
            const menuBtn = document.getElementById('cashflowMenuBtn');

            if (dropdown && !dropdown.contains(event.target) && !menuBtn.contains(event.target)) {
                dropdown.classList.remove('show');
                document.removeEventListener('click', closeCashflowDropdownOutside);
            }
        }

        async function updateCashflowRange(rangeType) {
            // Close dropdown
            const dropdown = document.getElementById('cashflowDropdown');
            if (dropdown) {
                dropdown.classList.remove('show');
                document.removeEventListener('click', closeCashflowDropdownOutside);
            }

            // Update active state
            const dropdownItems = document.querySelectorAll('.dropdown-item');
            dropdownItems.forEach(item => item.classList.remove('active'));
            event.currentTarget.classList.add('active');

            // Update subtitle
            const subtitle = document.getElementById('cashflowSubtitle');
            if (subtitle) {
                subtitle.textContent = event.currentTarget.textContent;
            }

            // Pass the range type directly - no need to map to different values
            // since we've updated updateHomeCashflowWithRange to handle these directly
            const chartRange = rangeType;

            // Log for debugging

            // Update the chart with the mapped range
            await updateHomeCashflowWithRange(chartRange);
        }

        function toggleAccountsDropdown() {
            const dropdown = document.getElementById('accountsDropdown');
            const menuBtn = document.getElementById('accountsMenuBtn');
            const isCurrentlyOpen = dropdown && dropdown.classList.contains('show');

            // Close all dropdowns first
            closeAllDropdowns();

            // If this dropdown wasn't open, open it
            if (dropdown && menuBtn && !isCurrentlyOpen) {
                dropdown.classList.add('show');

                if (dropdown.classList.contains('show')) {
                    setTimeout(() => {
                        document.addEventListener('click', closeAccountsDropdownOutside);
                    }, 0);
                } else {
                    document.removeEventListener('click', closeAccountsDropdownOutside);
                }
            }
        }

        function closeAccountsDropdownOutside(event) {
            const dropdown = document.getElementById('accountsDropdown');
            const menuBtn = document.getElementById('accountsMenuBtn');

            if (dropdown && menuBtn &&
                !dropdown.contains(event.target) &&
                !menuBtn.contains(event.target)) {
                dropdown.classList.remove('show');
                document.removeEventListener('click', closeAccountsDropdownOutside);
            }
        }

        function toggleNetWorthDropdown() {
            const dropdown = document.getElementById('netWorthDropdown');
            const menuBtn = document.getElementById('netWorthMenuBtn');
            const isCurrentlyOpen = dropdown && dropdown.classList.contains('show');

            // Close all dropdowns first
            closeAllDropdowns();

            // If this dropdown wasn't open, open it
            if (dropdown && menuBtn && !isCurrentlyOpen) {
                dropdown.classList.add('show');

                if (dropdown.classList.contains('show')) {
                    setTimeout(() => {
                        document.addEventListener('click', closeNetWorthDropdownOutside);
                    }, 0);
                }
            }
        }

        function closeNetWorthDropdownOutside(event) {
            const dropdown = document.getElementById('netWorthDropdown');
            const menuBtn = document.getElementById('netWorthMenuBtn');

            if (dropdown && !dropdown.contains(event.target) && !menuBtn.contains(event.target)) {
                dropdown.classList.remove('show');
                document.removeEventListener('click', closeNetWorthDropdownOutside);
            }
        }

        async function updateNetWorthRange(rangeType) {
            // Close dropdown
            const dropdown = document.getElementById('netWorthDropdown');
            if (dropdown) {
                dropdown.classList.remove('show');
                document.removeEventListener('click', closeNetWorthDropdownOutside);
            }

            // Update active state in dropdown
            const dropdownItems = document.querySelectorAll('#netWorthDropdown .dropdown-item');
            dropdownItems.forEach(item => item.classList.remove('active'));
            event.currentTarget.classList.add('active');

            // Update subtitle
            const subtitle = document.getElementById('netWorthSubtitle');
            if (subtitle) {
                subtitle.textContent = event.currentTarget.textContent;
            }

            // Update the net worth chart with new range
            await updateHomeNetWorthWithChart(rangeType);
        }

        // Accounts Net Worth functions (showing net worth same as home page)
        async function updateAccountsNetWorthWithChart(range) {
            console.log('=== ACCOUNTS NET WORTH DEBUG ===');
            console.log('Range:', range);
            console.log('Savings accounts:', savingsAccounts);
            
            // Check if canvas exists
            const canvas = document.getElementById('accountsNetWorthCanvas');
            console.log(' Canvas element found:', !!canvas);
            if (canvas) {
                console.log(' Canvas dimensions:', { width: canvas.width, height: canvas.height, clientWidth: canvas.clientWidth, clientHeight: canvas.clientHeight });
            }
            
            // Show loading spinner
            showAccountsNetWorthSpinner();
            
            try {
                // Calculate net worth (assets - liabilities) from API data
                let totalAssets = 0;
                let totalLiabilities = 0;

                // Use global savingsAccounts variable (loaded from API)
            
            if (!savingsAccounts || savingsAccounts.length === 0) {
                const displayNetWorth = 0;
                const netWorthHistory = await generateSnapshotBasedNetWorth(displayNetWorth, range);
                drawAccountsNetWorthChart(netWorthHistory);
                updateAccountsNetWorthDisplay(displayNetWorth, range);
                return;
            }

            // Process all accounts from API data
            savingsAccounts.forEach((account, index) => {

                // Use currentBalance from processed account data
                let balance = 0;
                let hasRealBalance = false;
                
                console.log('Processing account for assets:', account.name, 'currentBalance:', account.currentBalance);
                
                // Check currentBalance field from processed account data
                if (account.currentBalance !== null && account.currentBalance !== undefined && typeof account.currentBalance === 'number') {
                    balance = account.currentBalance;
                    hasRealBalance = true;
                    console.log('Found balance for', account.name, ':', balance);
                } else {
                    console.log('No balance found for', account.name);
                }
                
                // Skip accounts without real balance data
                if (!hasRealBalance) {
                    console.log('Skipping account due to no balance:', account.name);
                    return;
                }

                // Determine if this is a liability based on type/subtype
                const isLiability = account.type === 'liability' || 
                                   account.type === 'credit' || 
                                   account.subtype === 'credit_card' || 
                                   account.type === 'mortgage' || 
                                   account.type === 'student_loan';


                // Separate assets and liabilities
                if (!isLiability) {
                    totalAssets += balance;
                } else {
                    totalLiabilities += Math.abs(balance); // Ensure liabilities are positive
                }
            });

                // Calculate net worth (assets - liabilities)
                const displayNetWorth = totalAssets - totalLiabilities;
                console.log('Calculated net worth:', displayNetWorth);
                console.log('Total assets:', totalAssets);
                console.log('Total liabilities:', totalLiabilities);

                // Check if we have any real balance data
                if (displayNetWorth === 0 && totalAssets === 0) {
                    console.log('No net worth data found, showing placeholder');
                    // Show placeholder when no balance data is available
                    showAccountsNetWorthPlaceholder();
                    return;
                }

                // Generate net worth history for chart (same as home page)
                const netWorthHistory = await generateSnapshotBasedNetWorth(displayNetWorth, range);
                console.log('Net worth history:', netWorthHistory);

                // Draw the net worth chart
                console.log(' About to call drawAccountsNetWorthChart with data:', netWorthHistory);
                console.log(' Function exists:', typeof drawAccountsNetWorthChart);
                try {
                    drawAccountsNetWorthChart(netWorthHistory);
                    console.log(' drawAccountsNetWorthChart call completed');
                } catch (error) {
                    console.error(' Error in drawAccountsNetWorthChart:', error);
                }

                // Update the title and change indicator
                updateAccountsNetWorthDisplay(displayNetWorth, range);
                console.log('=====================================');
            } catch (error) {
                console.error('Error updating accounts net worth chart:', error);
            } finally {
                hideAccountsNetWorthSpinner();
            }
        }

        let accountsNetWorthChart = null;
        
        function drawAccountsNetWorthChart(data) {
            console.log(' Drawing accounts net worth chart with Chart.js, data:', data);
            const ctx = document.getElementById('accountsNetWorthCanvas').getContext('2d');
            if (!ctx) {
                console.log(' Accounts net worth canvas not found');
                return;
            }

            // Destroy existing chart if it exists
            if (accountsNetWorthChart) {
                accountsNetWorthChart.destroy();
            }

            if (!data.length) return;

            // Prepare data for Chart.js
            const labels = data.map(d => d.date);
            const netWorthData = data.map(d => d.value);
            
            // Calculate fixed scale bounds to prevent auto-scaling
            const minValue = Math.min(...netWorthData);
            const maxValue = Math.max(...netWorthData);
            const range = maxValue - minValue;
            const padding = range * 0.1; // 10% padding
            const yMin = minValue - padding;
            const yMax = maxValue + padding;

            accountsNetWorthChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Net Worth',
                        data: netWorthData,
                        borderColor: '#5fa42e', // Green theme
                        backgroundColor: 'transparent',
                        tension: 0.6,
                        fill: false,
                        pointRadius: 0,
                        borderWidth: 3,
                        pointHitRadius: 20,
                        pointBackgroundColor: 'transparent',
                        pointBorderColor: 'transparent',
                        pointBorderWidth: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: {
                        padding: 0
                    },
                    animation: {
                        duration: 1000,
                        easing: 'easeInOutQuart',
                        onProgress: function(animation) {
                            // Store animation progress for gradient plugin
                            this.gradientProgress = animation.currentStep / animation.numSteps;
                        },
                        onComplete: function() {
                            this.gradientProgress = 1;
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: { enabled: false }
                    },
                    scales: {
                        x: {
                            grid: { display: false },
                            ticks: { display: false },
                            border: { display: false }
                        },
                        y: {
                            grid: { display: false },
                            border: { display: false },
                            ticks: { display: false },
                            min: yMin,
                            max: yMax
                        }
                    },
                    interaction: { intersect: false, mode: 'nearest' },
                    hover: { intersect: false, mode: 'nearest', enabled: false },
                    elements: {
                        point: {
                            hitRadius: 30,
                            hoverRadius: 0,
                            radius: 0,
                            hoverBackgroundColor: 'transparent',
                            hoverBorderColor: 'transparent',
                            hoverBorderWidth: 0
                        },
                        line: { tension: 0.6 }
                    }
                },
                plugins: [{
                    id: 'absoluteGradient',
                    beforeDraw: function(chart, args, options) {
                        const ctx = chart.ctx;
                        const chartArea = chart.chartArea;
                        const yAxis = chart.scales.y;
                        const xAxis = chart.scales.x;
                        
                        if (!chart.data.datasets[0].data.length) return;
                        
                        // Skip gradient animation if chart is being interacted with
                        let animationProgress = 1;
                        if (!chart.isInteracting) {
                            animationProgress = chart.gradientProgress !== undefined ? chart.gradientProgress : 1;
                        }
                        
                        // Calculate visible width based on animation progress
                        const chartWidth = chartArea.right - chartArea.left;
                        const visibleWidth = chartWidth * animationProgress;
                        
                        // Calculate zero line position
                        const zeroLineY = yAxis.getPixelForValue(0);
                        
                        // Get both datasets for complete data
                        const positiveDataset = chart.data.datasets[0];
                        const negativeDataset = chart.data.datasets[1];
                        
                        // Safely combine data from both datasets
                        const allData = [];
                        for (let i = 0; i < positiveDataset.data.length; i++) {
                            if (positiveDataset.data[i] !== null) {
                                allData[i] = positiveDataset.data[i];
                            } else if (negativeDataset && negativeDataset.data && negativeDataset.data[i] !== null) {
                                allData[i] = negativeDataset.data[i];
                            } else {
                                allData[i] = 0; // fallback to zero
                            }
                        }
                        
                        // Set up clipping for progressive reveal
                        ctx.save();
                        ctx.beginPath();
                        ctx.rect(chartArea.left, chartArea.top, visibleWidth, chartArea.bottom - chartArea.top);
                        ctx.clip();
                        
                        // Create and draw positive area fill (above zero line)
                        const positiveGradient = ctx.createLinearGradient(0, zeroLineY, 0, chartArea.top);
                        positiveGradient.addColorStop(0, 'rgba(95, 164, 46, 0.02)'); // Slight opacity at zero line
                        positiveGradient.addColorStop(0.3, 'rgba(95, 164, 46, 0.08)');
                        positiveGradient.addColorStop(0.6, 'rgba(95, 164, 46, 0.18)');
                        positiveGradient.addColorStop(1, 'rgba(95, 164, 46, 0.25)'); // Opaque at top
                        
                        ctx.fillStyle = positiveGradient;
                        ctx.beginPath();
                        
                        // Start at left edge at zero line
                        ctx.moveTo(chartArea.left, zeroLineY);
                        
                        // Follow the actual data line (positive sections will show above zero, negative below)
                        allData.forEach((value, index) => {
                            const x = xAxis.getPixelForValue(index);
                            const y = yAxis.getPixelForValue(Math.max(value, 0)); // Use zero as minimum for positive fill
                            ctx.lineTo(x, y);
                        });
                        
                        // Complete the fill back to zero line at right edge
                        ctx.lineTo(chartArea.right, zeroLineY);
                        ctx.closePath();
                        ctx.fill();
                        
                        // Create and draw negative area fill (below zero line)
                        const negativeGradient = ctx.createLinearGradient(0, zeroLineY, 0, chartArea.bottom);
                        negativeGradient.addColorStop(0, 'rgba(156, 163, 175, 0.02)'); // Slight opacity at zero line
                        negativeGradient.addColorStop(0.3, 'rgba(156, 163, 175, 0.08)');
                        negativeGradient.addColorStop(0.6, 'rgba(156, 163, 175, 0.18)');
                        negativeGradient.addColorStop(1, 'rgba(156, 163, 175, 0.25)'); // Opaque at bottom
                        
                        ctx.fillStyle = negativeGradient;
                        ctx.beginPath();
                        
                        // Start at left edge at zero line
                        ctx.moveTo(chartArea.left, zeroLineY);
                        
                        // Follow the actual data line (negative sections will show below zero, positive above)
                        allData.forEach((value, index) => {
                            const x = xAxis.getPixelForValue(index);
                            const y = yAxis.getPixelForValue(Math.min(value, 0)); // Use zero as maximum for negative fill
                            ctx.lineTo(x, y);
                        });
                        
                        // Complete the fill back to zero line at right edge
                        ctx.lineTo(chartArea.right, zeroLineY);
                        ctx.closePath();
                        ctx.fill();
                        
                        ctx.restore();
                    }
                }, {
                    id: 'horizontalLine',
                    afterDraw: function(chart) {
                        const ctx = chart.ctx;
                        const yAxis = chart.scales.y;
                        
                        if (!chart.data.datasets[0].data.length) return;
                        
                        // Hide horizontal line during drag interaction
                        if (chart.isInteracting) return;
                        
                        // Check if there's an active crosshair interaction
                        let currentValue, currentIndex, displayDate = '';
                        if (chart.activeIndex !== undefined && chart.activeIndex >= 0) {
                            currentIndex = chart.activeIndex;
                            currentValue = chart.data.datasets[0].data[currentIndex];
                            // Format date from label to friendly format
                            const dateLabel = chart.data.labels[currentIndex];
                            const date = new Date(dateLabel);
                            const friendlyDate = date.toLocaleDateString('en-US', { 
                                month: 'short', 
                                day: 'numeric' 
                            });
                            displayDate = ` (${friendlyDate})`;
                        } else {
                            // Default to latest value
                            currentIndex = chart.data.datasets[0].data.length - 1;
                            currentValue = chart.data.datasets[0].data[currentIndex];
                        }
                        
                        const yPosition = yAxis.getPixelForValue(currentValue);
                        
                        // Draw dashed horizontal line edge-to-edge
                        ctx.save();
                        ctx.strokeStyle = '#9ca3af';
                        ctx.lineWidth = 1;
                        ctx.setLineDash([4, 4]);
                        ctx.globalAlpha = 0.8;
                        
                        ctx.beginPath();
                        ctx.moveTo(chart.chartArea.left, yPosition);
                        ctx.lineTo(chart.chartArea.right, yPosition);
                        ctx.stroke();
                        
                        // Draw amount label above the line with date
                        ctx.setLineDash([]);
                        ctx.fillStyle = '#6b7280';
                        ctx.font = '12px system-ui, -apple-system, sans-serif';
                        ctx.textAlign = 'left';
                        ctx.textBaseline = 'bottom';
                        
                        const formattedValue = `$${(currentValue / 1000).toFixed(1)}k${displayDate}`;
                        ctx.fillText(formattedValue, chart.chartArea.left + 8, yPosition - 8);
                        
                        ctx.restore();
                    }
                }]
            });

            // Add interactive crosshair system (will be implemented in unified system)
            setupNetWorthChartInteraction(accountsNetWorthChart, 'accountsNetWorthOverlay', 'accountsNetWorthCrosshair');
            
            console.log(' Accounts net worth Chart.js chart created successfully');
        }

        /**
         * Sets up unified crosshair interaction system for Chart.js charts
         */
        function setupNetWorthChartInteraction(chart, overlayId, crosshairId) {
            if (!chart || !chart.canvas) return;

            const chartCanvas = chart.canvas;
            const chartOverlay = document.getElementById(overlayId);
            const chartCrosshair = document.getElementById(crosshairId);
            
            if (!chartOverlay || !chartCrosshair) {
                console.log(' Chart overlay or crosshair not found for', overlayId);
                return;
            }

            let interactionEnabled = false;
            let lastActiveIndex = null;

            // Helper function to get nearest data index
            function getNearestIndex(x) {
                if (!chart.data || !chart.data.labels) return 0;
                const points = chart.getElementsAtEventForMode({ x: x, y: 0 }, 'nearest', { intersect: false }, true);
                if (points.length > 0) {
                    return points[0].index;
                }
                
                // Fallback calculation
                const xScale = chart.scales.x;
                const chartArea = chart.chartArea;
                const relativeX = (x - chartArea.left) / (chartArea.right - chartArea.left);
                const dataCount = chart.data.labels.length;
                return Math.max(0, Math.min(dataCount - 1, Math.round(relativeX * (dataCount - 1))));
            }

            // Enable interaction and show crosshair
            function enableChartInteraction(x) {
                interactionEnabled = true;
                const index = getNearestIndex(x);
                showChartInteraction(index);
                lastActiveIndex = index;
            }

            // Disable interaction and hide crosshair
            function disableChartInteraction() {
                interactionEnabled = false;
                hideChartInteraction();
                lastActiveIndex = null;
            }

            // Show crosshair and highlight active point
            function showChartInteraction(activeIndex) {
                if (!chart.data || !chart.data.datasets) return;

                // Store active index for horizontal line plugin
                chart.activeIndex = activeIndex;
                
                // Mark chart as actively being interacted with to prevent gradient animation
                chart.isInteracting = true;

                // Show active point with hollow green circle
                chart.data.datasets.forEach((dataset, datasetIndex) => {
                    // Reset all point properties
                    dataset.pointRadius = new Array(dataset.data.length).fill(0);
                    dataset.pointBackgroundColor = new Array(dataset.data.length).fill('transparent');
                    dataset.pointBorderColor = new Array(dataset.data.length).fill('transparent');
                    dataset.pointBorderWidth = new Array(dataset.data.length).fill(0);

                    // Show only the active point with hollow green circle
                    if (activeIndex >= 0 && activeIndex < dataset.data.length) {
                        dataset.pointRadius[activeIndex] = 8;
                        dataset.pointBackgroundColor[activeIndex] = '#fff';
                        dataset.pointBorderColor[activeIndex] = '#5fa42e'; // Green
                        dataset.pointBorderWidth[activeIndex] = 3;
                    }
                });

                // Position crosshair but hide the vertical line during interaction
                const xScale = chart.scales.x;
                const pixelX = xScale.getPixelForValue(activeIndex);
                chartCrosshair.style.left = `${pixelX}px`;
                chartCrosshair.style.opacity = '0'; // Hide vertical line during dragging
                chartOverlay.classList.add('visible');

                // Handle header elements during drag (for net worth charts)
                if (overlayId === 'homeNetWorthOverlay') {
                    const titleElement = document.getElementById('netWorthTitle');
                    const changeElement = document.getElementById('netWorthChange');
                    const subtitleElement = document.getElementById('netWorthSubtitle');
                    
                    if (titleElement && chart.data && chart.data.datasets[0] && chart.data.labels) {
                        // Store original title and subtitle if not already stored
                        if (!chart.originalTitle) {
                            chart.originalTitle = titleElement.textContent;
                        }
                        if (!chart.originalSubtitle && subtitleElement) {
                            chart.originalSubtitle = subtitleElement.textContent;
                        }
                        
                        // Get the current value and date
                        const currentValue = chart.data.datasets[0].data[activeIndex] || chart.data.datasets[1].data[activeIndex];
                        const dateLabel = chart.data.labels[activeIndex];
                        const date = new Date(dateLabel);
                        const friendlyDate = date.toLocaleDateString('en-US', { 
                            month: 'short', 
                            day: 'numeric',
                            year: date.getFullYear() !== new Date().getFullYear() ? 'numeric' : undefined
                        });
                        
                        // Update title with current dragged value
                        titleElement.textContent = `${formatCurrency(currentValue)} net worth`;
                        
                        // Replace change element content with date (keep it visible but change content)
                        if (changeElement) {
                            // Store original content if not already stored
                            if (!chart.originalChangeContent) {
                                chart.originalChangeContent = changeElement.innerHTML;
                            }
                            changeElement.innerHTML = `<span style="color: #6b7280;">${friendlyDate}</span>`;
                        }
                    }
                } else if (overlayId === 'accountsNetWorthOverlay') {
                    const titleElement = document.getElementById('accountsNetWorthTitle');
                    const changeElement = document.getElementById('accountsNetWorthChange');
                    const subtitleElement = document.getElementById('accountsNetWorthSubtitle');
                    
                    if (titleElement && chart.data && chart.data.datasets[0] && chart.data.labels) {
                        // Store original title and subtitle if not already stored
                        if (!chart.originalTitle) {
                            chart.originalTitle = titleElement.textContent;
                        }
                        if (!chart.originalSubtitle && subtitleElement) {
                            chart.originalSubtitle = subtitleElement.textContent;
                        }
                        
                        // Get the current value and date
                        const currentValue = chart.data.datasets[0].data[activeIndex] || chart.data.datasets[1].data[activeIndex];
                        const dateLabel = chart.data.labels[activeIndex];
                        const date = new Date(dateLabel);
                        const friendlyDate = date.toLocaleDateString('en-US', { 
                            month: 'short', 
                            day: 'numeric',
                            year: date.getFullYear() !== new Date().getFullYear() ? 'numeric' : undefined
                        });
                        
                        // Update title with current dragged value
                        titleElement.textContent = `${formatCurrency(currentValue)} net worth`;
                        
                        // Replace change element content with date (keep it visible but change content)
                        if (changeElement) {
                            // Store original content if not already stored
                            if (!chart.originalChangeContent) {
                                chart.originalChangeContent = changeElement.innerHTML;
                            }
                            changeElement.innerHTML = `<span style="color: #6b7280;">${friendlyDate}</span>`;
                        }
                    }
                }

                chart.update('none');
            }

            // Hide crosshair
            function hideChartInteraction() {
                if (!chart.data || !chart.data.datasets) return;

                // Clear active index for horizontal line plugin
                chart.activeIndex = undefined;
                
                // Clear interaction flag to allow gradient animations again
                chart.isInteracting = false;

                // Hide all points
                chart.data.datasets.forEach(dataset => {
                    dataset.pointRadius = new Array(dataset.data.length).fill(0);
                    dataset.pointBackgroundColor = new Array(dataset.data.length).fill('transparent');
                    dataset.pointBorderColor = new Array(dataset.data.length).fill('transparent');
                    dataset.pointBorderWidth = new Array(dataset.data.length).fill(0);
                });

                // Hide crosshair with delay
                setTimeout(() => {
                    chartOverlay.classList.remove('visible');
                }, 200);
                
                // Restore header elements (for net worth charts)
                if (overlayId === 'homeNetWorthOverlay') {
                    const titleElement = document.getElementById('netWorthTitle');
                    const changeElement = document.getElementById('netWorthChange');
                    const subtitleElement = document.getElementById('netWorthSubtitle');
                    
                    // Restore original title
                    if (titleElement && chart.originalTitle) {
                        titleElement.textContent = chart.originalTitle;
                    }
                    
                    // Restore original change content
                    if (changeElement && chart.originalChangeContent) {
                        changeElement.innerHTML = chart.originalChangeContent;
                    }
                    
                    // Restore original subtitle
                    if (subtitleElement && chart.originalSubtitle) {
                        subtitleElement.textContent = chart.originalSubtitle;
                    }
                    
                    // Ensure elements are visible
                    if (changeElement) changeElement.style.visibility = '';
                    if (subtitleElement) subtitleElement.style.display = '';
                } else if (overlayId === 'accountsNetWorthOverlay') {
                    const titleElement = document.getElementById('accountsNetWorthTitle');
                    const changeElement = document.getElementById('accountsNetWorthChange');
                    const subtitleElement = document.getElementById('accountsNetWorthSubtitle');
                    
                    // Restore original title
                    if (titleElement && chart.originalTitle) {
                        titleElement.textContent = chart.originalTitle;
                    }
                    
                    // Restore original change content
                    if (changeElement && chart.originalChangeContent) {
                        changeElement.innerHTML = chart.originalChangeContent;
                    }
                    
                    // Restore original subtitle
                    if (subtitleElement && chart.originalSubtitle) {
                        subtitleElement.textContent = chart.originalSubtitle;
                    }
                    
                    // Ensure elements are visible
                    if (changeElement) changeElement.style.visibility = '';
                    if (subtitleElement) subtitleElement.style.display = '';
                }
                
                chart.update('none');
            }

            // Mouse events - immediate interaction
            chartCanvas.addEventListener('mousedown', function (e) {
                const x = e.clientX - chartCanvas.getBoundingClientRect().left;
                enableChartInteraction(x);
            });

            chartCanvas.addEventListener('mousemove', function (e) {
                if (!interactionEnabled) return;
                const x = e.clientX - chartCanvas.getBoundingClientRect().left;
                const index = getNearestIndex(x);
                if (index !== lastActiveIndex) {
                    showChartInteraction(index);
                    lastActiveIndex = index;
                }
            });

            chartCanvas.addEventListener('mouseup', function () {
                if (interactionEnabled) disableChartInteraction();
            });

            chartCanvas.addEventListener('mouseleave', function () {
                if (interactionEnabled) disableChartInteraction();
            });

            // Touch events - immediate interaction with direction detection
            let initialTouchX = 0;
            let initialTouchY = 0;
            let touchDirection = null;

            chartCanvas.addEventListener('touchstart', function (e) {
                if (!e.touches || e.touches.length === 0) return;

                initialTouchX = e.touches[0].clientX;
                initialTouchY = e.touches[0].clientY;
                touchDirection = null;

                const x = e.touches[0].clientX - chartCanvas.getBoundingClientRect().left;
                enableChartInteraction(x);
            });

            chartCanvas.addEventListener('touchmove', function (e) {
                if (!e.touches || e.touches.length === 0) return;

                // Always prevent default to stop zoom-out and browser navigation
                e.preventDefault();

                // Direction detection for scroll vs chart interaction
                if (touchDirection === null) {
                    const deltaX = Math.abs(e.touches[0].clientX - initialTouchX);
                    const deltaY = Math.abs(e.touches[0].clientY - initialTouchY);

                    if (deltaY > deltaX && deltaY > 10) {
                        touchDirection = 'vertical';
                        return;
                    } else if (deltaX > 10) {
                        touchDirection = 'horizontal';
                    }
                }

                // Only interact if horizontal movement
                if (touchDirection === 'horizontal' && interactionEnabled) {
                    const rect = chartCanvas.getBoundingClientRect();
                    const x = e.touches[0].clientX - rect.left;
                    
                    // Constrain to chart bounds to prevent edge effects
                    const constrainedX = Math.max(0, Math.min(rect.width, x));
                    const index = getNearestIndex(constrainedX);
                    
                    if (index !== lastActiveIndex) {
                        showChartInteraction(index);
                        lastActiveIndex = index;
                    }
                }
            }, { passive: false });

            chartCanvas.addEventListener('touchend', function () {
                if (interactionEnabled) disableChartInteraction();
            });

            chartCanvas.addEventListener('touchcancel', function () {
                if (interactionEnabled) disableChartInteraction();
            });
        }

        function updateAccountsNetWorthDisplay(netWorth, range) {
            // Calculate change percentage based on range (mock data for now)
            let changePercent = 0;
            let rangeLabel = '';

            switch (range) {
                case '1m':
                    changePercent = 1.2;
                    rangeLabel = '1 month';
                    break;
                case '3m':
                    changePercent = 3.8;
                    rangeLabel = '3 months';
                    break;
                case '6m':
                    changePercent = 7.2;
                    rangeLabel = '6 months';
                    break;
                case 'ytd':
                    changePercent = 5.1;
                    rangeLabel = 'Year to date';
                    break;
                case '1y':
                    changePercent = 12.4;
                    rangeLabel = '1 year';
                    break;
                case 'all':
                default:
                    changePercent = 24.6;
                    rangeLabel = 'All time';
                    break;
            }

            const assetsTitle = document.getElementById('accountsNetWorthTitle');
            const assetsChange = document.getElementById('accountsNetWorthChange');

            if (assetsTitle) {
                assetsTitle.textContent = `${formatCurrency(netWorth)} net worth`;
            }

            if (assetsChange) {
                const isPositive = changePercent > 0;
                const arrow = isPositive ? 'arrow-up' : 'arrow-down';
                const color = isPositive ? '#5fa42e' : '#ef4444';
                const changeAmount = (netWorth * changePercent / 100).toFixed(2);
                assetsChange.innerHTML = `
                        <i data-lucide="${arrow}" class="w-4 h-4 inline" style="color: ${color}"></i>
                        <span style="color: ${color}">$${Math.abs(changeAmount)} (${Math.abs(changePercent).toFixed(1)}%)</span>
                    `;

                // Re-initialize Lucide icons
                if (window.safeInitLucideIcons) {
                    window.safeInitLucideIcons();
                }
            }
        }

        async function updateAccountsNetWorth() {
            console.log(' updateAccountsNetWorth() called');
            try {
                await updateAccountsNetWorthWithChart('all'); // Default to all time view to match active button
                console.log(' updateAccountsNetWorth() completed');
            } catch (error) {
                console.error(' updateAccountsNetWorth() failed:', error);
            }
        }

        function handleAccountsNetWorthCardClick(event) {
            // Prevent navigation if clicking on dropdown menu or menu button
            const dropdown = document.getElementById('accountsNetWorthDropdown');
            const menuBtn = document.getElementById('accountsNetWorthMenuBtn');

            if (dropdown && (dropdown.contains(event.target) || menuBtn.contains(event.target))) {
                event.stopPropagation();
                return;
            }

            // Navigate to reports or detailed view
        }

        function toggleAccountsNetWorthDropdown() {
            const dropdown = document.getElementById('accountsNetWorthDropdown');
            const menuBtn = document.getElementById('accountsNetWorthMenuBtn');
            const isCurrentlyOpen = dropdown && dropdown.classList.contains('show');

            // Close all dropdowns first
            closeAllDropdowns();

            // If this dropdown wasn't open, open it
            if (dropdown && menuBtn && !isCurrentlyOpen) {
                dropdown.classList.add('show');

                if (dropdown.classList.contains('show')) {
                    setTimeout(() => {
                        document.addEventListener('click', closeAccountsNetWorthDropdownOutside);
                    }, 0);
                }
            }
        }

        function closeAccountsNetWorthDropdownOutside(event) {
            const dropdown = document.getElementById('accountsNetWorthDropdown');
            const menuBtn = document.getElementById('accountsNetWorthMenuBtn');

            if (dropdown && !dropdown.contains(event.target) && !menuBtn.contains(event.target)) {
                dropdown.classList.remove('show');
                document.removeEventListener('click', closeAccountsNetWorthDropdownOutside);
            }
        }

        async function updateAccountsNetWorthRange(rangeType, event) {
            // Close dropdown
            const dropdown = document.getElementById('accountsNetWorthDropdown');
            if (dropdown) {
                dropdown.classList.remove('show');
                document.removeEventListener('click', closeAccountsNetWorthDropdownOutside);
            }

            // Update active state in dropdown
            const dropdownItems = document.querySelectorAll('#accountsNetWorthDropdown .dropdown-item');
            dropdownItems.forEach(item => item.classList.remove('active'));
            if (event && event.currentTarget) {
                event.currentTarget.classList.add('active');
            }

            // Update subtitle
            const subtitle = document.getElementById('accountsNetWorthSubtitle');
            if (subtitle && event && event.currentTarget) {
                subtitle.textContent = event.currentTarget.textContent;
            }

            // Update the assets chart with new range
            await updateAccountsNetWorthWithChart(rangeType);
        }

        function calculateCumulativeSpendingForMonths(expenses, monthCount, offsetMonths) {
            const today = new Date();
            let cumulativeData = [];
            let cumulative = 0;

            // Generate data for each day across all months in the period
            for (let monthOffset = offsetMonths + monthCount - 1; monthOffset >= offsetMonths; monthOffset--) {
                const targetDate = new Date(today);
                targetDate.setMonth(today.getMonth() - monthOffset);
                const monthKey = `${targetDate.getFullYear()}-${String(targetDate.getMonth() + 1).padStart(2, '0')}`;

                // Get expenses for this month
                Object.keys(expenses).forEach(date => {
                    if (date.startsWith(monthKey)) {
                        const dayExpenses = expenses[date] || [];
                        const totalForDay = dayExpenses.reduce((sum, expense) => sum + expense.amount, 0);
                        if (totalForDay > 0) {
                            cumulative += totalForDay;
                            const dayOfPeriod = Math.floor((new Date(date) - new Date(targetDate.getFullYear(), targetDate.getMonth(), 1)) / (1000 * 60 * 60 * 24)) + 1;
                            cumulativeData.push({ day: dayOfPeriod + (monthCount - monthOffset - 1) * 31, cumulative });
                        }
                    }
                });
            }

            return cumulativeData.sort((a, b) => a.day - b.day);
        }

        function drawHomeCashflowChartWithRange(currentPeriodData, lastPeriodData, yAxisMax, range) {
            const canvas = document.getElementById('homeCashflowCanvas');
            if (!canvas) return;

            // Set canvas size to match container
            const container = canvas.parentElement;
            const rect = container.getBoundingClientRect();
            const containerHeight = Math.max(rect.height, 250); // Minimum 250px height

            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = containerHeight * window.devicePixelRatio;
            canvas.style.width = rect.width + 'px';
            canvas.style.height = containerHeight + 'px';

            const ctx = canvas.getContext('2d');
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

            const width = rect.width;
            const height = containerHeight;

            // Clear canvas
            ctx.clearRect(0, 0, width, height);

            // Chart dimensions - minimal margins for edge-to-edge appearance
            const margin = { top: 25, right: 0, bottom: 10, left: 0 };
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            // Calculate max days based on range
            let maxDays;
            switch (range) {
                case 'week': maxDays = 7; break;
                case 'month':
                case '1m': maxDays = 31; break;
                case 'year': maxDays = 31; break; // Month comparison
                case 'average': maxDays = 31; break; // Month comparison
                case 'ytd':
                    // Calculate days elapsed in the year so far
                    const now = new Date();
                    const startOfYear = new Date(now.getFullYear(), 0, 1);
                    const msPerDay = 1000 * 60 * 60 * 24;
                    maxDays = Math.floor((now - startOfYear) / msPerDay) + 1;
                    break;
                default: maxDays = 31; break;
            }

            // Helper functions
            const xScale = (day) => margin.left + (day / maxDays) * chartWidth;
            const yScale = (amount) => margin.top + chartHeight - (amount / yAxisMax) * chartHeight;

            // Draw reference line at current period's latest value
            const currentValue = currentPeriodData.length > 0 ? currentPeriodData[currentPeriodData.length - 1].cumulative : 0;
            const currentY = yScale(currentValue);

            ctx.strokeStyle = '#9ca3af';
            ctx.lineWidth = 1;
            ctx.setLineDash([4, 4]); // Dashed line
            ctx.beginPath();
            ctx.moveTo(margin.left, currentY);
            ctx.lineTo(margin.left + chartWidth, currentY);
            ctx.stroke();

            // Current amount label
            ctx.fillStyle = '#6b7280';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText(`$${(currentValue / 1000).toFixed(1)}k`, 10, currentY - 8);

            // Reset line dash for chart lines
            ctx.setLineDash([]);

            // Draw last period data (gray, thinner) with smooth curves
            if (lastPeriodData.length > 0) {
                ctx.strokeStyle = '#d1d5db';
                ctx.lineWidth = 1.5;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.beginPath();

                if (lastPeriodData.length > 1) {
                    ctx.moveTo(xScale(lastPeriodData[0].day), yScale(lastPeriodData[0].cumulative));

                    for (let i = 1; i < lastPeriodData.length; i++) {
                        const prevX = xScale(lastPeriodData[i - 1].day);
                        const prevY = yScale(lastPeriodData[i - 1].cumulative);
                        const currX = xScale(lastPeriodData[i].day);
                        const currY = yScale(lastPeriodData[i].cumulative);

                        if (i === 1) {
                            const cpx = prevX + (currX - prevX) * 0.3;
                            ctx.quadraticCurveTo(cpx, prevY, currX, currY);
                        } else {
                            const cpx1 = prevX + (currX - prevX) * 0.15;
                            const cpx2 = currX - (currX - prevX) * 0.15;
                            ctx.bezierCurveTo(cpx1, prevY, cpx2, currY, currX, currY);
                        }
                    }
                }

                ctx.stroke();
            }

            // Draw current period data (purple color, thicker) with animation
            if (currentPeriodData.length > 0) {
                const gradient = ctx.createLinearGradient(0, 0, 0, height);
                gradient.addColorStop(0, '#8b5cf6');
                gradient.addColorStop(1, '#7c3aed');

                // Pre-fill the area
                ctx.globalAlpha = 0.1;
                ctx.fillStyle = gradient;
                ctx.beginPath();
                currentPeriodData.forEach((point, index) => {
                    const x = xScale(point.day);
                    const y = yScale(point.cumulative);
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.lineTo(xScale(currentPeriodData[currentPeriodData.length - 1].day), yScale(0));
                ctx.lineTo(xScale(currentPeriodData[0].day), yScale(0));
                ctx.closePath();
                ctx.fill();
                ctx.globalAlpha = 1;

                // Convert data to points for animation (simplified to linear for now)
                const points = currentPeriodData.map(point => ({
                    x: xScale(point.day),
                    y: yScale(point.cumulative)
                }));

                // Animate only the line from left to right
                animateLinePath(ctx, points, {
                    strokeStyle: gradient,
                    lineWidth: 2.5,
                    duration: 1000
                });
            }
        }


        // Update save target display
        function updateSaveTargetDisplay() {
            const today = new Date();
            const daysInMonth = new Date(today.getFullYear(), today.getMonth() + 1, 0).getDate();
            const dayOfMonth = today.getDate();

            let targetAmount = 0;
            let progressAmount = 0;
            let progressPercentage = 0;
            let lastBalanceDate = '';
            let periodLabel = '';
            let description = '';

            if (currentSavePeriodMode === 'today') {
                // Daily saving target (monthly target divided by days in month)
                targetAmount = getMonthlySavingsTarget() / daysInMonth;
                periodLabel = 'Daily Saving Target';
                description = 'daily saving target';

                const progressLabel = document.getElementById('saveProgressLabel');
                if (progressLabel) {
                    progressLabel.textContent = 'Progress Today';
                }
            } else {
                // Monthly saving target - use the value from settings
                targetAmount = getMonthlySavingsTarget();
                periodLabel = `${selectedSaveMonthDate.toLocaleDateString('en-US', { month: 'long', year: 'numeric' })} Saving Target`;
                description = 'monthly saving target';

                const progressLabel = document.getElementById('saveProgressLabel');
                if (progressLabel) {
                    progressLabel.textContent = 'Saved this month';
                }
            }

            // Calculate progress based on balance differences
            const { currentTotal, previousTotal, lastDate } = getSaveBalanceComparison();
            // Calculate the amount saved - ensure it's never negative for display purposes
            // For monthly view, this should show the amount saved since the previous month
            progressAmount = currentTotal - previousTotal;


            // Store the last balance date for reference
            lastBalanceDate = lastDate;

            // Calculate progress percentage against the target
            progressPercentage = targetAmount > 0 ? (progressAmount / targetAmount) * 100 : 0;

            // Update display elements
            const saveTargetDescription = document.getElementById('saveTargetDescription');
            const saveTargetAmount = document.getElementById('saveTargetAmount');
            const saveProgressAmount = document.getElementById('saveProgressAmount');

            // Update the month/year selector text
            updateSaveMonthYearSelector();
            if (saveTargetDescription) {
                saveTargetDescription.textContent = description;
            }
            if (saveTargetAmount) {
                saveTargetAmount.textContent = formatCurrency(targetAmount);
            }
            if (saveProgressAmount) {
                const sign = progressAmount >= 0 ? '+' : '';
                // Format without percentage and without "since [month name]"
                saveProgressAmount.textContent = `${sign}${formatCurrency(progressAmount)}`;
            }

            // Update save change indicators
            updateSaveChangeIndicators(targetAmount, progressAmount, progressPercentage);

            // Update progress label to show appropriate context
            const progressLabel = document.getElementById('saveProgressLabel');
            if (progressLabel) {
                if (currentSavePeriodMode === 'today') {
                    const lastDateObj = new Date(lastBalanceDate);
                    const lastDateFormatted = lastDateObj.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });
                    progressLabel.textContent = `Today vs ${lastDateFormatted}`;
                } else {
                    // For monthly mode, show "Saved this month"
                    progressLabel.textContent = `Saved this month`;

                    // Also update the comparison text to show which month we're comparing with
                    const previousMonth = new Date(selectedSaveMonthDate);
                    previousMonth.setMonth(previousMonth.getMonth() - 1);
                    const previousMonthName = previousMonth.toLocaleDateString('en-US', { month: 'long' });

                    const saveComparisonLabel = document.getElementById('saveComparisonLabel');
                    if (saveComparisonLabel) {
                        saveComparisonLabel.textContent = `since ${previousMonthName}`;
                    }
                }
            }
        }

        // Get balance comparison for progress calculation
        function getBalanceComparison() {
            const balances = loadAccountBalances();
            const today = getCurrentDate();

            // Get current total balance (sum of all accounts)
            const currentTotal = getTotalBalanceForDate(balances, today);

            if (currentSavePeriodMode === 'today') {
                // For daily: compare to yesterday or last available balance
                const yesterday = getPreviousDate(today);
                let previousTotal = getTotalBalanceForDate(balances, yesterday);
                let lastDate = yesterday;

                // If no balance for yesterday, find the closest available balance
                if (previousTotal === 0) {
                    const availableDates = getAllAvailableDates(balances);
                    const lastAvailableDate = availableDates.find(date => date < yesterday);
                    if (lastAvailableDate) {
                        previousTotal = getTotalBalanceForDate(balances, lastAvailableDate);
                        lastDate = lastAvailableDate;
                    }
                }

                return { currentTotal, previousTotal, lastDate };
            } else {
                // For monthly: compare to same day last month or last available balance
                const sameDayLastMonth = getSameDayLastMonth(today);
                let previousTotal = getTotalBalanceForDate(balances, sameDayLastMonth);
                let lastDate = sameDayLastMonth;

                // If no balance for same day last month, find the closest available balance
                if (previousTotal === 0) {
                    const availableDates = getAllAvailableDates(balances);
                    const lastAvailableDate = availableDates.find(date => date < sameDayLastMonth);
                    if (lastAvailableDate) {
                        previousTotal = getTotalBalanceForDate(balances, lastAvailableDate);
                        lastDate = lastAvailableDate;
                    }
                }

                return { currentTotal, previousTotal, lastDate };
            }
        }

        // Get balance comparison for save screen (uses selected month)
        function getSaveBalanceComparison() {
            const balances = loadAccountBalances();

            if (currentSavePeriodMode === 'today') {
                // For daily mode, use the same logic as regular comparison
                return getBalanceComparison();
            } else {
                // For monthly mode, calculate the total amount saved during the selected month
                const selectedMonthKey = getSelectedSaveMonthKey();
                let currentTotal = 0;
                let lastDate = '';

                // Calculate total balance at the end of the selected month
                let totalEndOfMonth = 0;
                let totalStartOfMonth = 0;

                // Process each account
                Object.keys(balances).forEach(accountId => {
                    const accountBalances = balances[accountId] || {};

                    // Get all balances for the selected month
                    const monthBalances = Object.keys(accountBalances)
                        .filter(date => date.startsWith(selectedMonthKey))
                        .sort();

                    // Get the last balance for the current month
                    if (monthBalances.length > 0) {
                        const latestDate = monthBalances[monthBalances.length - 1];
                        const latestBalance = accountBalances[latestDate];

                        // Handle both old format (direct number) and new format (object with amount)
                        const amount = latestBalance && typeof latestBalance === 'object' ?
                            latestBalance.amount : latestBalance;

                        if (typeof amount === 'number' && !isNaN(amount)) {
                            totalEndOfMonth += amount;
                        }

                        if (!lastDate || latestDate > lastDate) {
                            lastDate = latestDate;
                        }
                    }

                    // Get the first balance of the month or last balance of previous month
                    // First try to find the earliest balance of the current month
                    if (monthBalances.length > 0) {
                        const earliestDate = monthBalances[0];
                        const earliestBalance = accountBalances[earliestDate];

                        const amount = earliestBalance && typeof earliestBalance === 'object' ?
                            earliestBalance.amount : earliestBalance;

                        if (typeof amount === 'number' && !isNaN(amount)) {
                            totalStartOfMonth += amount;
                        }
                    } else {
                        // If no balances for current month, try to find the latest balance from previous month
                        const previousMonth = new Date(selectedSaveMonthDate);
                        previousMonth.setMonth(previousMonth.getMonth() - 1);
                        const previousMonthKey = `${previousMonth.getFullYear()}-${String(previousMonth.getMonth() + 1).padStart(2, '0')}`;

                        const previousMonthBalances = Object.keys(accountBalances)
                            .filter(date => date.startsWith(previousMonthKey))
                            .sort()
                            .reverse();

                        if (previousMonthBalances.length > 0) {
                            const latestPrevBalance = accountBalances[previousMonthBalances[0]];
                            const amount = latestPrevBalance && typeof latestPrevBalance === 'object' ?
                                latestPrevBalance.amount : latestPrevBalance;

                            if (typeof amount === 'number' && !isNaN(amount)) {
                                totalStartOfMonth += amount;
                            }
                        }
                    }
                });

                // Calculate the amount saved during the current month
                currentTotal = totalEndOfMonth;

                // Get the previous month's total for comparison
                const previousMonth = new Date(selectedSaveMonthDate);
                previousMonth.setMonth(previousMonth.getMonth() - 1);
                const previousMonthKey = `${previousMonth.getFullYear()}-${String(previousMonth.getMonth() + 1).padStart(2, '0')}`;

                let previousTotal = 0;

                // Calculate the total at the end of the previous month
                Object.keys(balances).forEach(accountId => {
                    const accountBalances = balances[accountId] || {};
                    const previousMonthBalances = Object.keys(accountBalances)
                        .filter(date => date.startsWith(previousMonthKey))
                        .sort();

                    if (previousMonthBalances.length > 0) {
                        const latestDate = previousMonthBalances[previousMonthBalances.length - 1];
                        const latestBalance = accountBalances[latestDate];

                        const amount = latestBalance && typeof latestBalance === 'object' ?
                            latestBalance.amount : latestBalance;

                        if (typeof amount === 'number' && !isNaN(amount)) {
                            previousTotal += amount;
                        }
                    }
                });


                return { currentTotal, previousTotal, lastDate };
            }
        }

        // Get total balance for a specific date
        function getTotalBalanceForDate(balances, date) {
            let totalBalance = 0;

            // Sum up all account balances for the given date
            Object.keys(balances).forEach(accountId => {
                const accountBalances = balances[accountId] || {};
                if (accountBalances[date]) {
                    const balance = accountBalances[date];
                    // Handle both old format (direct number) and new format (object with amount)
                    const amount = balance && typeof balance === 'object' ? balance.amount : balance;

                    if (typeof amount === 'number' && !isNaN(amount)) {
                        totalBalance += amount;
                    }
                }
            });

            return totalBalance;
        }

        // Get previous date (yesterday)
        function getPreviousDate(dateString) {
            const date = new Date(dateString);
            date.setDate(date.getDate() - 1);
            return date.toISOString().split('T')[0];
        }

        // Get same day last month
        function getSameDayLastMonth(dateString) {
            const date = new Date(dateString);
            date.setMonth(date.getMonth() - 1);

            // Handle edge case: if current day doesn't exist in previous month
            // (e.g., Jan 31 -> Feb 28/29), use the last day of previous month
            const lastDayOfPrevMonth = new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
            if (date.getDate() > lastDayOfPrevMonth) {
                date.setDate(lastDayOfPrevMonth);
            }

            return date.toISOString().split('T')[0];
        }

        // Get the most recent balance date for the selected month
        function getMostRecentBalanceDate() {
            try {
                const balances = loadAccountBalances();

                // For the current/selected month
                let year, month;
                if (currentSavePeriodMode === 'today') {
                    const today = new Date();
                    year = today.getFullYear();
                    month = today.getMonth();
                } else {
                    year = selectedSaveMonthDate.getFullYear();
                    month = selectedSaveMonthDate.getMonth();
                }

                // Get the start and end of the month
                const startDate = new Date(year, month, 1);
                const endDate = new Date(year, month + 1, 0);


                // Find all balance dates within this month across all accounts
                let allDatesInMonth = [];

                if (balances && typeof balances === 'object') {
                    Object.keys(balances).forEach(accountId => {
                        const accountBalances = balances[accountId] || {};

                        Object.keys(accountBalances).forEach(dateStr => {
                            try {
                                const balanceDate = new Date(dateStr);
                                if (balanceDate >= startDate && balanceDate <= endDate) {
                                    allDatesInMonth.push(dateStr);
                                }
                            } catch (e) {
                                console.error('Error processing date:', dateStr, e);
                            }
                        });
                    });
                }

    
                // If there are no dates, return 'No data'
                if (allDatesInMonth.length === 0) {
                    return 'No data';
                }

                // Sort dates to find the most recent
                allDatesInMonth.sort((a, b) => new Date(b) - new Date(a));

                // Format the most recent date nicely
                // Parse the date in UTC to prevent timezone issues
                const mostRecentDate = new Date(allDatesInMonth[0] + 'T00:00:00Z');
                const formattedDate = mostRecentDate.toLocaleDateString('en-US', {
                    month: 'short',
                    day: 'numeric',
                    year: 'numeric',
                    timeZone: 'UTC' // Ensure consistent date display regardless of local timezone
                });

                return formattedDate;
            } catch (error) {
                console.error('Error in getMostRecentBalanceDate:', error);
                return 'No data';
            }
        }

        // Update save screen total savings display
        async function updateSaveTotalSavingsDisplay() {
            const balances = loadAccountBalances();

            // Update the "Last updated" note with the actual last balance date
            const lastUpdatedNote = document.getElementById('lastUpdatedNote');
            if (lastUpdatedNote) {
                // Check if the function is defined first
                if (typeof getMostRecentBalanceDate === 'function') {
                    const mostRecentDate = getMostRecentBalanceDate();
                    // Only show the note if there is actual data
                    if (mostRecentDate !== 'No data') {
                        lastUpdatedNote.textContent = `Last updated: ${mostRecentDate}`;
                        lastUpdatedNote.style.display = 'block'; // Show the note
                    } else {
                        lastUpdatedNote.style.display = 'none'; // Hide the note if no data
                    }
                } else {
                    console.error('getMostRecentBalanceDate function not defined');
                    lastUpdatedNote.style.display = 'none'; // Hide the note if function not available
                }
            }

            // Calculate total balance based on current view mode
            let actualTotalBalance = 0;

            if (currentSavePeriodMode === 'month') {
                // For month mode, use the balances from the selected month
                const selectedMonthKey = getSelectedSaveMonthKey();

                Object.keys(balances).forEach(accountId => {
                    // Get all balance entries for this account in the selected month
                    const monthEntries = Object.keys(balances[accountId] || {})
                        .filter(date => date.startsWith(selectedMonthKey))
                        .sort();  // Sort dates chronologically

                    if (monthEntries.length > 0) {
                        // Get the last entry for the month
                        const lastDateInMonth = monthEntries[monthEntries.length - 1];
                        const lastBalanceInMonth = balances[accountId][lastDateInMonth];


                        // Handle both object format and direct number format
                        if (lastBalanceInMonth !== null && lastBalanceInMonth !== undefined) {
                            if (typeof lastBalanceInMonth === 'object' && typeof lastBalanceInMonth.amount === 'number') {
                                actualTotalBalance += lastBalanceInMonth.amount;
                            } else if (typeof lastBalanceInMonth === 'number') {
                                actualTotalBalance += lastBalanceInMonth;
                            } else {
                                console.warn(`Invalid balance format for account ${accountId}:`, lastBalanceInMonth);
                            }
                        }
                    }
                });
            } else {
                // For 'today' mode, use the latest balance regardless of date
                Object.keys(balances).forEach(accountId => {
                    const latestBalance = getLastBalanceForAccount(accountId);
                    if (latestBalance && typeof latestBalance.amount === 'number') {
                        actualTotalBalance += latestBalance.amount;
                    }
                });
            }

            // Log individual account balances for verification
            if (currentSavePeriodMode === 'month') {
                const selectedMonthKey = getSelectedSaveMonthKey();
                Object.keys(balances).forEach(accountId => {
                    const monthEntries = Object.keys(balances[accountId] || {})
                        .filter(date => date.startsWith(selectedMonthKey))
                        .sort();

                    const accountInfo = savingsAccounts.find(acc => acc.id === accountId) || { name: 'Unknown Account' };

                    if (monthEntries.length > 0) {
                        const lastDateInMonth = monthEntries[monthEntries.length - 1];
                        const lastBalanceInMonth = balances[accountId][lastDateInMonth];

                    } else {
                    }
                });
            } else {
                Object.keys(balances).forEach(accountId => {
                    const latestBalance = getLastBalanceForAccount(accountId);
                    const accountInfo = savingsAccounts.find(acc => acc.id === accountId) || { name: 'Unknown Account' };
                    if (latestBalance && typeof latestBalance.amount === 'number') {
                    }
                });
            }

            // Display the calculated total balance based on period mode
            const saveTotalAccountBalance = document.getElementById('saveTotalAccountBalance');
            if (saveTotalAccountBalance) {
                saveTotalAccountBalance.textContent = formatCurrency(actualTotalBalance);
            }

            // For comparison and change calculation
            const saveTotalBalanceChange = document.getElementById('saveTotalBalanceChange');

            if (currentSavePeriodMode === 'today') {
                // For today mode, use current date
                const { previousTotal, lastDate } = getBalanceComparison();
                const balanceChange = actualTotalBalance - previousTotal;

                if (saveTotalBalanceChange) {
                    // Show the change since yesterday with a plus/minus sign
                    const sign = balanceChange >= 0 ? '+' : '';
                    saveTotalBalanceChange.textContent = `${sign}${formatCurrency(balanceChange)} since yesterday`;
                    saveTotalBalanceChange.className = balanceChange >= 0 ?
                        'balance-change-modern positive' : 'balance-change-modern negative';
                }

                // Update the date display
                const saveBalanceDate = document.getElementById('saveBalanceDate');
                if (saveBalanceDate) {
                    const today = new Date();
                    saveBalanceDate.textContent = today.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });
                }

            } else {
                // For monthly mode, use selected month data
                const { currentTotal, previousTotal, lastDate } = getSaveBalanceComparison();
                const balanceChange = actualTotalBalance - previousTotal;

                if (saveTotalBalanceChange) {
                    // Show the change since previous month with a plus/minus sign
                    const sign = balanceChange >= 0 ? '+' : '';
                    // Get the previous month name for display
                    const prevMonth = new Date(selectedSaveMonthDate);
                    prevMonth.setMonth(prevMonth.getMonth() - 1);
                    const prevMonthName = prevMonth.toLocaleDateString('en-US', { month: 'long' });
                    saveTotalBalanceChange.textContent = `${sign}${formatCurrency(balanceChange)} since ${prevMonthName}`;
                    saveTotalBalanceChange.className = balanceChange >= 0 ?
                        'balance-change-modern positive' : 'balance-change-modern negative';

                }

                // Update the date display
                const saveBalanceDate = document.getElementById('saveBalanceDate');
                if (saveBalanceDate) {
                    const selectedMonthName = selectedSaveMonthDate.toLocaleDateString('en-US', { month: 'long' });
                    saveBalanceDate.textContent = selectedMonthName;
                }

            }

            // Update save screen balance history
            await updateSaveBalanceHistory();
        }

        // Update save screen balance history

        // Get appropriate icon for account type
        function getAccountIcon(accountType, accountId) {
            const iconMap = {
                'cash': { icon: 'banknote' },
                'investment': { icon: 'trending-up' },
                'liability': { icon: 'credit-card' },
                'checking': { icon: 'banknote' },
                'savings': { icon: 'piggy-bank' },
                'creditcard': { icon: 'credit-card' },
                'emergency': { icon: 'shield' }
            };

            return iconMap[accountId] || iconMap[accountType] || { icon: 'wallet' };
        }

        // Update account type chart and total balance
        function updateAccountSummary() {
            const balances = loadAccountBalances();

            // Calculate totals by type
            let investmentTotal = 0;
            let cashTotal = 0;
            let debtTotal = 0;
            let totalBalance = 0;

            savingsAccounts.forEach(account => {
                const currentBalance = getLastBalanceForAccount(account.id);
                const balance = currentBalance ? currentBalance.amount : 0;

                if (account.type === 'investment') {
                    investmentTotal += balance;
                } else if (account.type === 'liability') {
                    debtTotal += Math.abs(balance); // Show as positive for chart
                    totalBalance -= Math.abs(balance); // Subtract debt from net worth
                } else {
                    cashTotal += balance;
                    totalBalance += balance; // Add assets to net worth
                }

                // Investment accounts also add to net worth
                if (account.type === 'investment') {
                    totalBalance += balance;
                }
            });


            // Old chart update code removed - now using networth chart
        }

        // Render new accounts layout
        async function renderNewAccountsLayout() {
            const container = document.getElementById('accountsList');
            if (!container) return;

            // Accounts data should already be loaded by updateSaveScreen()

            const balances = loadAccountBalances();

            // Group accounts by type
            const accountTypes = {
                'cash': { title: 'Cash & Checking', accounts: [] },
                'investment': { title: 'Investments', accounts: [] },
                'liability': { title: 'Credit & Loans', accounts: [] }
            };

            // Get current balances and group accounts
            let html = '';
            savingsAccounts.forEach(account => {
                const accountType = account.type || 'cash';
                // Use currentBalance from API data if available, otherwise use local balance
                let balance;
                if (account.currentBalance !== undefined && typeof account.currentBalance === 'number') {
                    balance = account.currentBalance;
                } else {
                    const currentBalance = getLastBalanceForAccount(account.id);
                    balance = currentBalance ? currentBalance.amount : 0;
                }

                if (!accountTypes[accountType]) {
                    accountTypes[accountType] = { title: accountType.charAt(0).toUpperCase() + accountType.slice(1), accounts: [] };
                }

                accountTypes[accountType].accounts.push({
                    ...account,
                    balance: balance
                });
            });

            // Render each account type group
            Object.entries(accountTypes).forEach(([type, group]) => {
                if (group.accounts.length === 0) return;

                const groupTotal = group.accounts.reduce((sum, account) => {
                    // For liability accounts, treat balance as negative
                    const isLiability = account.type === 'liability';
                    const displayBalance = isLiability ? -Math.abs(account.balance) : account.balance;
                    return sum + displayBalance;
                }, 0);
                const formattedGroupTotal = groupTotal < 0 ?
                    `(${formatCurrency(Math.abs(groupTotal))})` :
                    formatCurrency(groupTotal);

                html += `
                        <div class="account-group-header">
                            <div class="account-group-title">${group.title}</div>
                            <div class="account-group-total">${formattedGroupTotal}</div>
                        </div>
                    `;

                group.accounts.forEach(account => {
                    const { icon } = getAccountIcon(account.type, account.id);
                    // Use real recent transactions from API data or empty array for non-Plaid accounts
                    const accountTransactions = account.recentTransactions || [];
                    // For liability accounts, show balance as negative with parentheses
                    const isLiability = account.type === 'liability';
                    const displayBalance = isLiability ? -Math.abs(account.balance) : account.balance;
                    const formattedBalance = displayBalance < 0 ?
                        `(${formatCurrency(Math.abs(displayBalance))})` :
                        formatCurrency(displayBalance);

                    html += `
                            <div class="account-item" onclick="openAccountDetail('${account.id}')">
                                <div class="account-icon">
                                    <i data-lucide="${icon}" class="w-5 h-5"></i>
                                </div>
                                <div class="account-info">
                                    <div class="account-name">${account.name}</div>
                                </div>
                                <div class="account-balance">${formattedBalance}</div>
                            </div>
                        `;
                });
            });

            container.innerHTML = html;

            // Reinitialize Lucide icons
            if (window.safeInitLucideIcons) {
                window.safeInitLucideIcons();
            }
        }

        // Render transactions for an account (similar to transaction list style)
        function renderAccountTransactions(transactions) {
            if (!transactions || transactions.length === 0) {
                return '<div style="text-align: center; color: #7f8c8d; padding: 1rem;">No recent transactions</div>';
            }

            let html = '';
            transactions.slice(0, 5).forEach(transaction => {
                // Defensive checks for transaction data
                const amount = transaction.amount || 0;
                const description = transaction.description || transaction.name || 'Unknown Transaction';
                const category = transaction.category || 'other';
                const transactionType = transaction.type || (amount < 0 ? 'expense' : 'income');

                // For display: expenses (negative amounts) should show as red outgoing, income (positive) as green incoming
                const isIncome = transactionType === 'income' || amount > 0;
                const amountColor = isIncome ? '#5fa42e' : 'hsl(var(--foreground))';
                const formattedAmount = isIncome ?
                    formatCurrency(Math.abs(amount)) :
                    `(${formatCurrency(Math.abs(amount))})`;

                html += `
                        <div class="transaction-item">
                            <div class="transaction-icon">
                                <i data-lucide="${getTransactionIcon(transactionType)}" class="w-4 h-4"></i>
                            </div>
                            <div class="transaction-info">
                                <div class="transaction-description">${description}</div>
                                <div class="transaction-category">${category}</div>
                            </div>
                            <div class="transaction-amount" style="color: ${amountColor};">
                                ${formattedAmount}
                            </div>
                        </div>
                    `;
            });

            return html;
        }

        // Get icon for transaction type
        function getTransactionIcon(type) {
            const iconMap = {
                'income': 'arrow-down-left',
                'expense': 'arrow-up-right',
                'transfer': 'arrow-right-left'
            };
            return iconMap[type] || 'circle';
        }

        // Toggle account transactions accordion
        function toggleAccountTransactions(accountId) {
            const transactionsEl = document.getElementById(`transactions-${accountId}`);
            if (transactionsEl) {
                transactionsEl.classList.toggle('expanded');
            }
        }

        // Open account detail page (placeholder)
        async function openAccountDetail(accountId) {
            const account = savingsAccounts.find(acc => acc.id === accountId);
            if (!account) {
                console.error('Account not found:', accountId);
                return;
            }

            // Store current account for detail view
            window.currentAccountDetail = {
                id: accountId,
                account: account,
                timeRange: 'month'
            };

            // Update header info
            document.getElementById('accountDetailTitle').textContent = account.name;

            // Get current balance
            const currentBalance = getLastBalanceForAccount(accountId);
            const balance = currentBalance ? currentBalance.amount : 0;
            const isLiability = account.type === 'liability';
            const displayBalance = isLiability ? -Math.abs(balance) : balance;

            document.getElementById('accountDetailBalance').textContent = formatCurrency(displayBalance);

            // Show the overlay
            document.getElementById('accountDetailOverlay').classList.add('active');

            // Add slide transition to main content
            const appContainer = document.querySelector('.app-container');
            appContainer.classList.add('settings-open');

            // Load account data
            updateAccountDetailChart();
            await updateAccountDetailTransactions();

            // Initialize swipe-to-go-back
            initAccountDetailSwipe();
        }

        function closeAccountDetail() {
            const screen = document.getElementById('accountDetailScreen');
            const overlay = document.getElementById('accountDetailOverlay');
            const appContainer = document.querySelector('.app-container');

            if (overlay && screen) {
                // Remove slide transition from main content
                appContainer.classList.remove('settings-open');

                // Animate the screen sliding out to the right with snappier transition
                screen.style.transition = 'transform 0.2s cubic-bezier(0.4, 0.0, 0.2, 1)';
                screen.style.transform = 'translateX(100%)';

                // Start fading out the overlay with snappier transition
                overlay.style.transition = 'opacity 0.2s cubic-bezier(0.4, 0.0, 0.2, 1)';
                overlay.style.opacity = '0';

                // Clean up after animation completes
                setTimeout(() => {
                    overlay.classList.remove('active');
                    overlay.style.transition = '';
                    overlay.style.opacity = '';
                    screen.style.transition = '';
                    screen.style.transform = '';

                    if (window.currentAccountDetail) {
                        window.currentAccountDetail = null;
                    }
                }, 200);
            }
        }

        function updateAccountDetailChart() {
            if (!window.currentAccountDetail) return;

            const accountId = window.currentAccountDetail.id;
            const timeRange = window.currentAccountDetail.timeRange;

            // Generate account history for the specific account
            const accountHistory = generateAccountHistory(accountId, timeRange);

            // Draw the chart
            drawAccountDetailChart(accountHistory);
        }

        function smoothAccountData(data) {
            if (data.length <= 2) return data;

            const smoothed = [];
            const windowSize = Math.min(3, data.length); // Use smaller window for limited data

            for (let i = 0; i < data.length; i++) {
                if (i === 0 || i === data.length - 1) {
                    // Keep first and last points unchanged
                    smoothed.push(data[i]);
                } else {
                    // Calculate moving average for middle points
                    const start = Math.max(0, i - Math.floor(windowSize / 2));
                    const end = Math.min(data.length, i + Math.floor(windowSize / 2) + 1);

                    let sum = 0;
                    let count = 0;
                    for (let j = start; j < end; j++) {
                        sum += data[j].value;
                        count++;
                    }

                    smoothed.push({
                        date: data[i].date,
                        value: sum / count
                    });
                }
            }

            return smoothed;
        }

        function generateAccountHistory(accountId, range) {
            const balances = loadAccountBalances();
            const accountBalances = balances[accountId] || {};

            if (Object.keys(accountBalances).length === 0) {
                return [];
            }

            // Get available dates for this account
            const availableDates = Object.keys(accountBalances).sort();

            // Determine sampling and range
            let maxDaysBack = 30;
            let sampleEveryNDays = 1;

            switch (range) {
                case 'week': maxDaysBack = 7; sampleEveryNDays = 1; break;
                case 'month': maxDaysBack = 30; sampleEveryNDays = 1; break;
                case 'quarter': maxDaysBack = 90; sampleEveryNDays = 3; break;
                case 'year': maxDaysBack = 365; sampleEveryNDays = 7; break;
                case 'all': maxDaysBack = 1095; sampleEveryNDays = 30; break;
            }

            // Filter dates within range
            const today = new Date();
            const cutoffDate = new Date();
            cutoffDate.setDate(today.getDate() - maxDaysBack);
            const cutoffDateStr = cutoffDate.toISOString().split('T')[0];

            const relevantDates = availableDates.filter(date => date >= cutoffDateStr);

            if (relevantDates.length === 0) {
                return [];
            }

            // Sample dates
            const sampledDates = [];
            let lastSampledIndex = -sampleEveryNDays;

            for (let i = 0; i < relevantDates.length; i++) {
                if (i - lastSampledIndex >= sampleEveryNDays || i === relevantDates.length - 1) {
                    sampledDates.push(relevantDates[i]);
                    lastSampledIndex = i;
                }
            }

            // Build history
            const history = [];
            sampledDates.forEach(date => {
                const balanceData = accountBalances[date];
                const balance = balanceData && typeof balanceData === 'object' ? balanceData.amount : balanceData;

                if (typeof balance === 'number' && !isNaN(balance)) {
                    history.push({
                        date: date,
                        value: Math.abs(balance) // Use absolute value for chart display
                    });
                }
            });

            // Smooth the data to reduce rough deltas
            const smoothedHistory = smoothAccountData(history);

            return smoothedHistory;
        }


        function drawAccountDetailChart(data) {
            const canvas = document.getElementById('accountDetailCanvas');
            if (!canvas || !data.length) return;

            // Use the same drawing logic as the assets chart
            const container = canvas.parentElement;
            const rect = container.getBoundingClientRect();
            const containerHeight = Math.max(rect.height, 200);

            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = containerHeight * window.devicePixelRatio;
            canvas.style.width = rect.width + 'px';
            canvas.style.height = containerHeight + 'px';

            const ctx = canvas.getContext('2d');
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);

            const width = rect.width;
            const height = containerHeight;

            ctx.clearRect(0, 0, width, height);

            const margin = { top: 20, right: 20, bottom: 20, left: 60 };
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;

            const values = data.map(d => d.value);
            const minValue = Math.min(...values);
            const maxValue = Math.max(...values);
            const valueRange = maxValue - minValue;

            const roundedMax = Math.ceil(maxValue / 1000) * 1000;
            const adjustedRange = roundedMax - minValue;

            const xScale = (index) => {
                if (data.length === 1) {
                    // Center single data point
                    return margin.left + chartWidth / 2;
                }
                return margin.left + (index / (data.length - 1)) * chartWidth;
            };
            const yScale = (value) => margin.top + chartHeight - ((value - minValue) / adjustedRange) * chartHeight;

            // Current value reference line
            const currentValue = data[data.length - 1].value;
            const currentY = yScale(currentValue);

            ctx.strokeStyle = '#9ca3af';
            ctx.lineWidth = 1;
            ctx.setLineDash([4, 4]);
            ctx.beginPath();
            ctx.moveTo(margin.left, currentY);
            ctx.lineTo(margin.left + chartWidth, currentY);
            ctx.stroke();

            // Current amount label
            ctx.fillStyle = '#6b7280';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText(`$${(currentValue / 1000).toFixed(1)}k`, 10, currentY - 8);

            ctx.setLineDash([]);

            // Gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, height);
            gradient.addColorStop(0, '#5fa42e');
            gradient.addColorStop(1, '#4a7c23');

            // Area fill
            ctx.globalAlpha = 0.1;
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.moveTo(xScale(0), yScale(data[0].value));

            for (let i = 1; i < data.length; i++) {
                ctx.lineTo(xScale(i), yScale(data[i].value));
            }

            ctx.lineTo(xScale(data.length - 1), height - margin.bottom);
            ctx.lineTo(xScale(0), height - margin.bottom);
            ctx.closePath();
            ctx.fill();

            // Main line with animation
            ctx.globalAlpha = 1;
            if (data.length > 1) {
                // Convert data to points for animation
                const points = data.map((point, index) => ({
                    x: xScale(index),
                    y: yScale(point.value)
                }));

                // Animate only the line from left to right
                animateLinePath(ctx, points, {
                    strokeStyle: '#5fa42e',
                    lineWidth: 2.5,
                    duration: 1000
                });
            }
        }

        function toggleAccountDetailTimeRange() {
            const dropdown = document.getElementById('accountDetailTimeRangeDropdown');
            const menuBtn = document.getElementById('accountDetailTimeRangeBtn');
            const isCurrentlyOpen = dropdown && dropdown.classList.contains('show');

            // Close all dropdowns first
            closeAllDropdowns();

            // If this dropdown wasn't open, open it
            if (dropdown && menuBtn && !isCurrentlyOpen) {
                dropdown.classList.add('show');

                if (dropdown.classList.contains('show')) {
                    setTimeout(() => {
                        document.addEventListener('click', closeAccountDetailTimeRangeOutside);
                    }, 0);
                }
            }
        }

        function closeAccountDetailTimeRangeOutside(event) {
            const dropdown = document.getElementById('accountDetailTimeRangeDropdown');
            const menuBtn = document.getElementById('accountDetailTimeRangeBtn');

            if (dropdown && !dropdown.contains(event.target) && !menuBtn.contains(event.target)) {
                dropdown.classList.remove('show');
                document.removeEventListener('click', closeAccountDetailTimeRangeOutside);
            }
        }

        async function updateAccountDetailTimeRange(rangeType, event) {
            if (!window.currentAccountDetail) return;

            // Close dropdown
            const dropdown = document.getElementById('accountDetailTimeRangeDropdown');
            if (dropdown) {
                dropdown.classList.remove('show');
                document.removeEventListener('click', closeAccountDetailTimeRangeOutside);
            }

            // Update active state in dropdown
            const dropdownItems = document.querySelectorAll('#accountDetailTimeRangeDropdown .dropdown-item');
            dropdownItems.forEach(item => item.classList.remove('active'));
            if (event && event.currentTarget) {
                event.currentTarget.classList.add('active');
            }

            // Update subtitle
            const subtitle = document.getElementById('accountDetailActivitySubtitle');
            if (subtitle && event && event.currentTarget) {
                subtitle.textContent = event.currentTarget.textContent;
            }

            // Update stored range and refresh data
            window.currentAccountDetail.timeRange = rangeType;
            updateAccountDetailChart();
            await updateAccountDetailTransactions();
        }

        async function updateAccountDetailTransactions() {
            if (!window.currentAccountDetail) return;

            const accountId = window.currentAccountDetail.id;
            const timeRange = window.currentAccountDetail.timeRange;

            // Get transactions for this account
            const transactions = await getAccountTransactions(accountId, timeRange);

            // Render transaction list
            renderAccountDetailTransactions(transactions);
        }

        async function getAccountTransactions(accountId, timeRange) {
            // Load real expense data from localStorage
            const expenses = await loadExpenses();
            let transactions = [];

            // Convert expenses to transaction format
            Object.keys(expenses).forEach(dateKey => {
                const dayExpenses = expenses[dateKey] || [];
                dayExpenses.forEach(expense => {
                    // Include all transactions as they represent account activity
                    transactions.push({
                        date: dateKey,
                        description: expense.description || getCategoryDisplayName(expense.category),
                        amount: -expense.amount, // Expenses are negative transactions
                        type: 'debit',
                        category: expense.category
                    });
                });
            });

            // No demo data - use only real transactions

            // Filter by time range
            const today = new Date();
            let cutoffDate = new Date();

            switch (timeRange) {
                case 'week': cutoffDate.setDate(today.getDate() - 7); break;
                case 'month': cutoffDate.setMonth(today.getMonth() - 1); break;
                case 'quarter': cutoffDate.setMonth(today.getMonth() - 3); break;
                case 'year': cutoffDate.setFullYear(today.getFullYear() - 1); break;
                case 'all': cutoffDate = new Date('2000-01-01'); break;
            }

            return transactions
                .filter(transaction => new Date(transaction.date) >= cutoffDate)
                .sort((a, b) => new Date(b.date) - new Date(a.date)); // Sort by date descending
        }


        function getCategoryDisplayName(category) {
            const categoryMap = {
                'groceries': 'Groceries',
                'transportation': 'Transportation',
                'dining': 'Dining Out',
                'entertainment': 'Entertainment',
                'personal': 'Personal Care',
                'clothing': 'Clothing',
                'utilities': 'Utilities',
                'healthcare': 'Healthcare',
                'subscription': 'Subscriptions',
                'rent': 'Rent/Mortgage',
                'other': 'Other'
            };
            return categoryMap[category] || 'Other Expense';
        }


        function renderAccountDetailTransactions(transactions) {
            const container = document.getElementById('accountDetailTransactionsList');

            if (!transactions || transactions.length === 0) {
                container.innerHTML = `
                        <div style="text-align: center; color: #7f8c8d; padding: 20px;">
                            No transactions found for this period
                        </div>
                    `;
                return;
            }

            const transactionsHtml = transactions.map(transaction => {
                const isCredit = transaction.amount > 0;
                const amountClass = isCredit ? 'credit' : 'debit';
                const amountText = isCredit ? `+${formatCurrency(transaction.amount)}` : formatCurrency(transaction.amount);

                return `
                        <div class="expense-item">
                            <div class="expense-date">${formatDate(transaction.date)}</div>
                            <div class="expense-details">
                                <div class="expense-description">${transaction.description}</div>
                            </div>
                            <div class="expense-amount ${amountClass}">${amountText}</div>
                        </div>
                    `;
            }).join('');

            container.innerHTML = transactionsHtml;
        }

        function initAccountDetailSwipe() {
            const screen = document.getElementById('accountDetailScreen');
            const overlay = document.getElementById('accountDetailOverlay');
            let startX = 0;
            let startY = 0;
            let currentX = 0;
            let isDragging = false;
            let isHorizontalSwipe = false;

            function handleTouchStart(e) {
                startX = e.touches[0].clientX;
                startY = e.touches[0].clientY;
                currentX = startX;
                isDragging = true;
                isHorizontalSwipe = false;

                // Disable CSS transitions during drag
                screen.style.transition = 'none';
                overlay.style.transition = 'none';
            }

            function handleTouchMove(e) {
                if (!isDragging) return;

                currentX = e.touches[0].clientX;
                const currentY = e.touches[0].clientY;
                const deltaX = currentX - startX;
                const deltaY = currentY - startY;

                // Determine if this is a horizontal swipe
                if (!isHorizontalSwipe && (Math.abs(deltaX) > 10 || Math.abs(deltaY) > 10)) {
                    isHorizontalSwipe = Math.abs(deltaX) > Math.abs(deltaY);

                    if (isHorizontalSwipe) {
                        // Prevent vertical scrolling during horizontal swipe
                        screen.style.touchAction = 'pan-x';
                        e.preventDefault();
                    } else {
                        // Allow vertical scrolling for non-horizontal gestures
                        screen.style.touchAction = 'pan-y';
                        isDragging = false;
                        return;
                    }
                }

                // Only allow rightward swipes (closing gesture) and only if horizontal
                if (isHorizontalSwipe && deltaX > 0) {
                    e.preventDefault(); // Prevent vertical scroll
                    const transform = Math.min(deltaX, screen.offsetWidth);
                    screen.style.transform = `translateX(${transform}px)`;
                }
            }

            function handleTouchEnd(e) {
                if (!isDragging) return;

                isDragging = false;
                isHorizontalSwipe = false;
                const deltaX = currentX - startX;

                // Restore normal touch behavior
                screen.style.touchAction = '';

                // If swiped more than 1/3 of the screen width, close
                if (deltaX > screen.offsetWidth / 3) {
                    // Close immediately without snap back
                    closeAccountDetail();
                } else if (deltaX > 0) {
                    // Snap back to original position with snappier transition
                    screen.style.transition = 'transform 0.2s cubic-bezier(0.4, 0.0, 0.2, 1)';
                    screen.style.transform = 'translateX(0)';

                    // Clean up after animation
                    setTimeout(() => {
                        screen.style.transition = '';
                        screen.style.transform = '';
                    }, 200);
                } else {
                    // No drag happened, just clean up
                    screen.style.transition = '';
                    screen.style.transform = '';
                }
            }

            // Add touch event listeners
            screen.addEventListener('touchstart', handleTouchStart, { passive: true });
            screen.addEventListener('touchmove', handleTouchMove, { passive: false });
            screen.addEventListener('touchend', handleTouchEnd, { passive: true });
        }

        function formatDate(dateString) {
            const date = new Date(dateString);
            const today = new Date();
            const yesterday = new Date(today);
            yesterday.setDate(yesterday.getDate() - 1);

            if (date.toDateString() === today.toDateString()) {
                return 'Today';
            } else if (date.toDateString() === yesterday.toDateString()) {
                return 'Yesterday';
            } else {
                return date.toLocaleDateString('en-US', {
                    month: 'long',
                    day: 'numeric',
                    year: 'numeric'
                });
            }
        }

        async function updateSaveBalanceHistory() {
            // Use new accounts layout instead of old balance history
            updateAccountSummary();
            await renderNewAccountsLayout();
            return;

            // Group balance records by account for the selected month
            const selectedMonthKey = getSelectedSaveMonthKey();
            const previousMonth = new Date(selectedSaveMonthDate);
            previousMonth.setMonth(previousMonth.getMonth() - 1);
            const previousMonthKey = `${previousMonth.getFullYear()}-${String(previousMonth.getMonth() + 1).padStart(2, '0')}`;

            // Ensure savingsAccounts is initialized
            if (!savingsAccounts || savingsAccounts.length === 0) {
                const savedAccounts = localStorage.getItem('savingsAccounts');
                if (savedAccounts) {
                    savingsAccounts = JSON.parse(savedAccounts);
                }
            }

            // Group accounts by type
            const accountTypes = {
                'cash': { title: 'Cash Accounts', accounts: [] },
                'investment': { title: 'Investments', accounts: [] },
                'liability': { title: 'Debt', accounts: [] },
                'other': { title: 'Other Accounts', accounts: [] }
            };


            // Prepare grouped data
            const grouped = {};
            savingsAccounts.forEach(account => {
                // Determine account type - default to 'other' if not specified
                const accountType = account.type || 'other';

                const accountBalances = balances[account.id] || {};
                // Get all updates for the selected month, sort by date (chronologically, not alphabetically)
                const monthUpdates = Object.keys(accountBalances)
                    .filter(date => date.startsWith(selectedMonthKey))
                    .map(date => {
                        const entry = accountBalances[date];
                        return {
                            date,
                            amount: entry.amount !== undefined ? entry.amount : entry,
                            created: entry.created || new Date(date).getTime(),
                            updated: entry.updated || entry.created || new Date(date).getTime()
                        };
                    })
                    .sort((a, b) => {
                        // Sort by date (most recent first)
                        return new Date(b.date) - new Date(a.date);
                    });
                // Get last value from previous month
                const prevMonthDates = Object.keys(accountBalances)
                    .filter(date => date.startsWith(previousMonthKey))
                    .sort();
                const prevMonthLastDate = prevMonthDates.length > 0 ? prevMonthDates[prevMonthDates.length - 1] : null;
                const prevMonthLastValue = prevMonthLastDate ? (accountBalances[prevMonthLastDate].amount !== undefined ? accountBalances[prevMonthLastDate].amount : accountBalances[prevMonthLastDate]) : 0;

                grouped[account.id] = {
                    name: account.name,
                    type: accountType,
                    monthUpdates,
                    prevMonthLastValue
                };

                // Only add to type group if it has updates this month
                if (monthUpdates.length > 0) {
                    // Add to the appropriate type group
                    if (accountTypes[accountType]) {
                        accountTypes[accountType].accounts.push(account.id);
                    } else {
                        accountTypes.other.accounts.push(account.id);
                    }
                }
            });

            // Render account sections by type
            let html = '';
            let anyData = false;

            // Process each account type section
            Object.keys(accountTypes).forEach(type => {
                const { title, accounts } = accountTypes[type];

                // Skip types with no accounts
                if (accounts.length === 0) return;

                anyData = true;
                // Create section header outside the card
                html += `
                    <h2 class="account-section-header">${title}</h2>
                    <div class="account-type-section">
                    `;

                // Add accounts for this section
                accounts.forEach(accountId => {
                    const { name, monthUpdates, type: accountType } = grouped[accountId];
                    if (monthUpdates.length === 0) return; // Only show accounts with data

                    // Latest value for the selected month (should be first in the array since we sorted by date descending)
                    const latest = monthUpdates[0];

                    // Calculate all-time percent (from first ever value)
                    const accountBalances = balances[accountId] || {};
                    const allDates = Object.keys(accountBalances).sort(); // Sort chronologically
                    const firstValue = allDates.length > 0 ?
                        (accountBalances[allDates[0]].amount !== undefined ?
                            accountBalances[allDates[0]].amount : accountBalances[allDates[0]]) : 0;
                    const allTimePercent = firstValue && latest.amount ? ((latest.amount - firstValue) / firstValue) * 100 : 0;

                    // Check if this is a debt account
                    const isDebt = accountType === 'liability';
                    const debtClass = isDebt ? ' debt' : '';
                    const formatAmount = (amount) => isDebt ? `(${formatCurrency(amount)})` : formatCurrency(amount);
                    // Account header: account name, latest value
                    html += `<div class="modern-account-accordion" data-account-id="${accountId}">
                        <div class="modern-account-accordion-header" onclick="toggleAccountAccordion('${accountId}')">
                            <div class="modern-account-header-left">
                                <div class="modern-account-title">${name}</div>
                            </div>
                            <div class="modern-account-header-right">
                                <div class="modern-account-balance${debtClass}">${formatAmount(latest.amount)}</div>
                                <div class="modern-account-change ${allTimePercent >= 0 ? 'positive' : 'negative'}">
                                    <i data-lucide="${allTimePercent >= 0 ? 'trending-up' : 'trending-down'}" class="change-arrow"></i>
                                    ${Math.abs(allTimePercent).toFixed(1)}%
                                </div>
                            </div>
                            <div class="account-chevron"><i data-lucide="chevron-down" class="modern-account-chevron" id="chevron-${accountId}"></i></div>
                        </div>
                        <div class="modern-account-accordion-body" id="accordion-body-${accountId}">
                            <div class="modern-account-updates">
                    `;
                    // Sort updates by date in descending order (newest first)
                    const sortedUpdates = [...monthUpdates].sort((a, b) => {
                        return new Date(b.date) - new Date(a.date);
                    });

                    // Process updates in chronological order for display
                    let prevValue = null;
                    let prevDate = null;

                    // First pass to determine previous values
                    const updatesWithPercents = sortedUpdates.map((update, index) => {
                        // Calculate percent change from previous value (next in array)
                        let percent = null;
                        let arrow = '';

                        // If we have a next item (which is the previous date's value)
                        const nextItem = sortedUpdates[index + 1];
                        if (nextItem) {
                            const previousAmount = nextItem.amount;
                            if (previousAmount !== null && previousAmount !== 0) {
                                percent = ((update.amount - previousAmount) / Math.abs(previousAmount)) * 100;
                                if (percent > 0.01) {
                                    arrow = '<i data-lucide="arrow-up-right" class="balance-arrow positive"></i>';
                                } else if (percent < -0.01) {
                                    arrow = '<i data-lucide="arrow-down-right" class="balance-arrow negative"></i>';
                                } else {
                                    arrow = '<i data-lucide="arrow-right" class="balance-arrow neutral"></i>';
                                }
                            }
                        }

                        const percentClass = percent > 0 ? 'positive' : percent < 0 ? 'negative' : 'neutral';

                        const [year, month, day] = update.date.split('-').map(Number);
                        const dateObj = new Date(year, month - 1, day);
                        const displayDate = dateObj.toLocaleDateString('en-US', { month: 'long', day: 'numeric', year: 'numeric' });

                        return {
                            ...update,
                            displayDate,
                            percent,
                            percentClass,
                            arrow
                        };
                    });

                    // Render updates
                    updatesWithPercents.forEach(update => {
                        html += `<div class="swipe-container" data-type="balance" data-account-id="${accountId}" data-date="${update.date}">
                            <div class="swipe-content">
                                <div class="modern-account-update-row">
                                    <div class="modern-update-date">${update.displayDate}</div>
                                    <div class="modern-update-amount-stack">
                                    <div class="modern-update-diff${debtClass}">${formatAmount(update.amount)}</div>
                                    <div class="modern-update-percent ${update.percentClass}">${update.percent !== null ? `${update.arrow}${update.percent >= 0 ? '+' : ''}${update.percent.toFixed(2)}%` : '--'}</div>
                                    </div>
                                </div>
                            </div>
                            <div class="swipe-action" onclick="handleBalanceDelete(this); event.stopPropagation(); return false;"><i data-lucide="x" class="w-4 h-4"></i></div>
                        </div>`;
                    });

                    html += `</div></div></div>`; // Close modern-account-updates, modern-account-accordion-body, modern-account-accordion
                });

                html += `</div>`; // Close account-type-section
            });
            if (!anyData) {
                const selectedMonthName = selectedSaveMonthDate.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
                html = `<div style="text-align: center; color: #7f8c8d; padding: 20px;">No balance records for ${selectedMonthName}</div>`;
            }
            historyContainer.innerHTML = html;
            // Ensure Lucide icons are rendered
            if (window.safeInitLucideIcons) {
                window.safeInitLucideIcons();
            }
        }

        // Accordion toggle function
        function toggleAccountAccordion(accountId) {
            const body = document.getElementById(`accordion-body-${accountId}`);
            const chevron = document.getElementById(`chevron-${accountId}`);
            const accordion = document.querySelector(`.modern-account-accordion[data-account-id='${accountId}']`);
            const header = document.querySelector(`.modern-account-accordion[data-account-id='${accountId}'] .modern-account-accordion-header`);
            // Remove any inline styles that might have been set
            if (body) {
                body.style.display = '';
                body.style.maxHeight = '';
                body.style.opacity = '';
            }
            if (accordion) {
                accordion.classList.toggle('expanded');
            }
            if (body.classList.contains('expanded')) {
                body.classList.remove('expanded');
                if (header) header.classList.remove('expanded');
            } else {
                body.classList.add('expanded');
                if (header) header.classList.add('expanded');
            }
        }

        // Account type section toggle function
        function toggleAccountTypeSection(typeKey) {
            const section = document.querySelector(`.account-type-section[onclick*="${typeKey}"]`);
            const body = document.getElementById(`type-body-${typeKey}`);
            const chevron = document.getElementById(`type-chevron-${typeKey}`);

            if (section && body) {
                // Toggle collapsed class on section
                section.classList.toggle('collapsed');

                // Toggle chevron rotation
                if (chevron) {
                    chevron.style.transform = section.classList.contains('collapsed') ? 'rotate(0deg)' : 'rotate(180deg)';
                }

                // Add expanded class for border styling when not collapsed
                if (section.classList.contains('collapsed')) {
                    section.classList.remove('expanded');
                } else {
                    section.classList.add('expanded');
                }
            }
        }

        // Get all available dates from balance data
        function getAllAvailableDates(balances) {
            const allDates = new Set();

            Object.keys(balances).forEach(accountId => {
                const accountBalances = balances[accountId] || {};
                Object.keys(accountBalances).forEach(date => {
                    allDates.add(date);
                });
            });

            return Array.from(allDates).sort();
        }

        // Get the last balance for a specific account
        function getLastBalanceForAccount(accountId) {
            const balances = loadAccountBalances();
            const accountBalances = balances[accountId] || {};

            if (Object.keys(accountBalances).length === 0) {
                return { amount: 0 }; // No balance records for this account
            }

            // Get all dates for this account and sort them chronologically (newest first)
            const dates = Object.keys(accountBalances).sort((a, b) => {
                // Sort dates in descending order (newest first)
                return new Date(b) - new Date(a);
            });

            // Get the latest balance (first in the sorted array)
            const lastBalance = accountBalances[dates[0]];

            // Log for debugging

            // Handle both old format (direct number) and new format (object with amount)
            if (lastBalance === null || lastBalance === undefined) {
                return { amount: 0 };
            } else if (typeof lastBalance === 'object') {
                return lastBalance;
            } else {
                return { amount: lastBalance };
            }
        }


        function generateAccountTypeChart() {
            const accountTypeChart = document.getElementById('accountTypeChart');
            if (!accountTypeChart) return;

            // Group accounts by type and calculate totals
            const accountTypes = {
                'cash': { total: 0, icon: 'dollar-sign', label: 'Cash' },
                'investment': { total: 0, icon: 'trending-up', label: 'Investments' },
                'liability': { total: 0, icon: 'credit-card', label: 'Debt' }
            };

            // Process accounts using API data only
            savingsAccounts.forEach((account, index) => {
                // Determine account type from API data
                let accountType;
                if (account.type === 'plaid') {
                    // For Plaid accounts, use subtype to determine category
                    if (account.subtype === 'credit card') {
                        accountType = 'liability';
                    } else if (account.subtype === 'investment') {
                        accountType = 'investment';
                    } else {
                        accountType = 'cash'; // Default for checking, savings, etc.
                    }
                } else {
                    // For manual accounts, use the type directly
                    accountType = account.type || 'cash';
                }

                // Use API balance data if available, otherwise use a default sample balance
                let balance = 0;
                if (account.currentBalance !== undefined && typeof account.currentBalance === 'number') {
                    balance = account.currentBalance;
                } else if (account.type === 'plaid' || account.name) {
                    // For accounts that exist but don't have balance data yet, use a sample balance
                    balance = accountType === 'liability' ? -2500 : 5000; // Sample balances for demo
                } else {
                    return;
                }

                if (accountTypes[accountType]) {
                    // For liability accounts, use absolute value since debt should show as positive amounts in the chart
                    const absBalance = Math.abs(balance);
                    accountTypes[accountType].total += absBalance;
                } else {
                }
            });

            // Convert to array format for the chart, filtering out zero amounts
            const accountData = Object.entries(accountTypes)
                .filter(([type, data]) => data.total > 0)
                .map(([type, data]) => ({
                    type: type,
                    label: data.label,
                    amount: data.total,
                    icon: data.icon
                }));

            // Calculate total for percentage
            const totalValue = accountData.reduce((sum, account) => sum + account.amount, 0);

            // If no accounts with balances, show placeholder
            if (accountData.length === 0 || totalValue === 0) {
                accountTypeChart.innerHTML = `
                        <div class="card-content">
                            <div style="text-align: center; color: #7f8c8d; padding: 1rem;">
                                <i data-lucide="info" class="w-4 h-4" style="margin-bottom: 0.5rem;"></i>
                                <div>Add accounts or update balances to see chart</div>
                            </div>
                        </div>
                    `;
                accountTypeChart.classList.add('home-section');

                // Ensure Lucide icons are rendered
                if (window.safeInitLucideIcons) {
                    window.safeInitLucideIcons();
                }
                return;
            }

            // Clear existing content and create new structure with home container
            accountTypeChart.innerHTML = `
                    <div class="card-header">
                        <div class="home-section-header">
                            <div class="section-subtitle">Investment, cash & debt</div>
                        </div>
                    </div>
                    <div class="card-content">
                        <div class="account-type-horizontal" id="accountTypeHorizontal">
                            <!-- Account bars will be generated here -->
                        </div>
                    </div>
                `;

            // Add the home-section class to the chart container
            accountTypeChart.classList.add('home-section');

            const container = document.getElementById('accountTypeHorizontal');

            accountData.forEach((account, index) => {
                const percentage = (account.amount / totalValue) * 100;
                const displayAmount = account.type === 'liability' ? -account.amount : account.amount;

                const barItem = document.createElement('div');
                barItem.className = 'account-type-bar';

                barItem.innerHTML = `
                        <div class="account-type-header">
                            <div class="account-type-left">
                                <div class="account-type-icon">
                                    <i data-lucide="${account.icon}" class="w-4 h-4"></i>
                                </div>
                                <div class="account-type-label">${account.label}</div>
                            </div>
                            <div class="account-type-amount">$${formatAccountTypeAmount(displayAmount)}</div>
                        </div>
                        <div class="account-type-bar-container">
                            <div class="account-type-bar-visual ${account.type}" style="width: ${percentage}%">
                                <div class="account-type-percentage">${Math.round(percentage)}%</div>
                            </div>
                        </div>
                    `;

                // Apply staggered fade animation
                barItem.style.opacity = '0';
                setTimeout(() => {
                    barItem.classList.add('chart-bar-stagger-in');
                    setTimeout(() => {
                        barItem.classList.remove('chart-bar-stagger-in');
                        barItem.style.opacity = '';
                    }, 300);
                }, index * 100); // 100ms delay between each bar

                container.appendChild(barItem);
            });

            // Ensure Lucide icons are rendered
            if (window.safeInitLucideIcons) {
                window.safeInitLucideIcons();
            }
        }

        function formatAccountTypeAmount(amount) {
            const absAmount = Math.abs(amount);
            const formattedAmount = absAmount.toLocaleString('en-US', {
                minimumFractionDigits: 2,
                maximumFractionDigits: 2
            });

            // Show negative amounts in brackets
            return amount < 0 ? `(${formattedAmount})` : formattedAmount;
        }

        function updateAccountsView() {
            // Generate the account type chart
            generateAccountTypeChart();

        }

        // Function to get the default account ID
        function getDefaultAccountId() {
            // If there are savings accounts, use the first one as default
            if (savingsAccounts && savingsAccounts.length > 0) {
                return savingsAccounts[0].id;
            }

            // If no accounts exist, return null
            return null;
        }

        // Update save screen display
        async function updateSaveScreen() {
            renderSaveTitle();
            updateSaveTargetDisplay();
            await updateSaveTotalSavingsDisplay();
            
            // Load accounts data when accessing accounts screen
            await loadAccountsWithTransactions();
            
            updateAccountsView();
            await updateAccountsNetWorth(); // Initialize accounts networth chart
        }

        /**
         * Renders the save screen title area with month/year selector.
         * Shows a large, centered, clickable month/year with chevron.
         */
        function renderSaveTitle() {
            const container = document.getElementById('saveTargetTitleContainer');
            if (!container) return;
            container.innerHTML = '';

            // Create month/year selector button
            const btn = document.createElement('button');
            btn.id = 'saveMonthYearSelectorBtn';
            btn.onclick = showSaveMonthYearSlideOut;
            btn.style.background = 'none';
            btn.style.border = 'none';
            btn.style.borderRadius = '14px';
            btn.style.display = 'inline-flex';
            btn.style.alignItems = 'center';
            btn.style.justifyContent = 'flex-start';
            btn.style.fontSize = '1.5rem';
            btn.style.fontWeight = '700';
            btn.style.color = 'inherit';
            btn.style.cursor = 'pointer';
            btn.style.padding = '0';
            btn.style.outline = 'none';
            btn.style.width = 'auto';

            // Month/year text
            const span = document.createElement('span');
            span.id = 'saveMonthYearSelectorText';
            span.textContent = getMonthYearString(selectedSaveMonthDate);

            // Lucide chevron icon
            const icon = document.createElement('i');
            icon.setAttribute('data-lucide', 'chevron-down');
            icon.className = 'w-7 h-7';
            icon.style.marginLeft = '0.5rem';
            icon.style.color = 'hsl(var(--muted-foreground))';

            btn.appendChild(span);
            btn.appendChild(icon);
            container.appendChild(btn);

            // Ensure Lucide icons are rendered
            if (window.safeInitLucideIcons) {
                window.safeInitLucideIcons();
            }
        }

        /**
         * Shows the save month/year selection slide-out
         */
        function showSaveMonthYearSlideOut() {
            showMonthYearSlideOut();
        }

        /**
         * Updates the save month/year selector text
         */
        function updateSaveMonthYearSelector() {
            const btnText = document.getElementById('saveMonthYearSelectorText');
            if (btnText) {
                btnText.textContent = getMonthYearString(selectedSaveMonthDate);
            }
        }

        // Set save period mode (today/month)
        function setSavePeriodMode(mode) {
            currentSavePeriodMode = mode;

            // Update compact button states
            const saveTodayBtn = document.getElementById('saveTodayBtnCompact');
            const saveMonthBtn = document.getElementById('saveMonthBtnCompact');
            if (saveTodayBtn) saveTodayBtn.classList.toggle('active', mode === 'today');
            if (saveMonthBtn) saveMonthBtn.classList.toggle('active', mode === 'month');

            // Update icon-only button states
            const saveTodayBtnIcon = document.getElementById('saveTodayBtnIcon');
            const saveMonthBtnIcon = document.getElementById('saveMonthBtnIcon');
            if (saveTodayBtnIcon) saveTodayBtnIcon.classList.toggle('active', mode === 'today');
            if (saveMonthBtnIcon) saveMonthBtnIcon.classList.toggle('active', mode === 'month');

            // Update save screen display
            updateSaveScreen();
        }

        /**
         * Initialize click-outside-to-close functionality for all slide-out menus
         * This function sets up event listeners on the overlay backgrounds to close menus when clicked
         */
        function initializeSlideOutClickOutside() {
            // Get all slide-out overlays
            const slideOutOverlays = document.querySelectorAll('.slide-out-overlay, .account-management-slide-out');

            slideOutOverlays.forEach(overlay => {
                overlay.addEventListener('click', function (event) {
                    // Check if the click was on the overlay background (not on the content)
                    if (event.target === overlay) {
                        // Close the specific slide-out based on its ID
                        const slideOutId = overlay.id;
                        switch (slideOutId) {
                            case 'expenseSlideOut':
                                hideExpenseSlideOut();
                                break;
                            case 'balanceSlideOut':
                                hideBalanceSlideOut();
                                break;
                            case 'monthYearSlideOut':
                                hideMonthYearSlideOut();
                                break;
                            case 'accountManagementSlideOut':
                                hideAccountManagementSlideOut();
                                break;
                            default:
                                // Generic fallback - remove active class
                                overlay.classList.remove('active');
                                break;
                        }
                    }
                });
            });
        }

        /**
         * Header title removed - navigation labels now shown in bottom nav only.
         */


        document.addEventListener('DOMContentLoaded', function () {
            // Header title removed - navigation now handled by bottom nav labels
        });

        // Settings Slide-out Functions
        function openSettings() {
            const overlay = document.getElementById('settingsOverlay');
            const panel = document.getElementById('settingsPanel');
            const appContainer = document.querySelector('.app-container');

            // Load settings data
            loadSettings();

            // Show overlay and panel
            overlay.classList.add('active');
            panel.classList.add('active');

            // Add slide transition to main content
            appContainer.classList.add('settings-open');

            // Hide bottom navigation
            document.querySelector('.bottom-nav').style.display = 'none';
        }

        function closeSettings() {
            const overlay = document.getElementById('settingsOverlay');
            const panel = document.getElementById('settingsPanel');
            const appContainer = document.querySelector('.app-container');

            // Hide overlay and panel
            overlay.classList.remove('active');
            panel.classList.remove('active');

            // Remove slide transition from main content
            appContainer.classList.remove('settings-open');

            // Show bottom navigation
            document.querySelector('.bottom-nav').style.display = 'flex';
        }

        // Close settings when clicking overlay
        document.addEventListener('DOMContentLoaded', function () {
            const overlay = document.getElementById('settingsOverlay');
            overlay.addEventListener('click', function (e) {
                if (e.target === overlay) {
                    closeSettings();
                }
            });

            // Close budget setup when clicking overlay
            const budgetOverlay = document.getElementById('budgetOverlay');
            budgetOverlay.addEventListener('click', function (e) {
                if (e.target === budgetOverlay) {
                    closeBudgetSetup();
                }
            });
        });

        // Settings Functions
        function loadSettings() {
            // Budget settings are now loaded in the budget slide-out
            // No need to load them here since the settings slide-out no longer contains budget forms
        }

        function updateSimpleBudgetSummary() {
            // Get values from inputs
            const grossIncome = parseFloat(document.getElementById('grossIncome').value) || 0;
            const federalTax = parseFloat(document.getElementById('federalTax').value) || 0;
            const provincialTax = parseFloat(document.getElementById('provincialTax').value) || 0;
            const cppEi = parseFloat(document.getElementById('cppEi').value) || 0;
            let netIncome = parseFloat(document.getElementById('netIncome').value) || 0;
            const annualSavingsGoal = parseFloat(document.getElementById('annualSavingsGoal').value) || 0;
            let monthlySavingsTarget = parseFloat(document.getElementById('monthlySavingsTarget').value) || 0;
            const fixedExpenses = parseFloat(document.getElementById('fixedExpenses').value) || 0;
            const essentialExpenses = parseFloat(document.getElementById('essentialExpenses').value) || 0;
            const discretionaryExpenses = parseFloat(document.getElementById('discretionaryExpenses').value) || 0;

            // Auto-calculate net income if not manually overridden
            const calculatedNet = grossIncome - federalTax - provincialTax - cppEi;
            if (!document.getElementById('netIncome').dataset.manual) {
                document.getElementById('netIncome').value = calculatedNet > 0 ? calculatedNet.toFixed(2) : '';
                netIncome = calculatedNet;
            }

            // Auto-calculate monthly savings target (now always calculated from annual goal)
            const calculatedMonthlySavings = annualSavingsGoal / 12;
            document.getElementById('monthlySavingsTarget').value = calculatedMonthlySavings > 0 ? calculatedMonthlySavings.toFixed(2) : '';
            monthlySavingsTarget = calculatedMonthlySavings;

            // Calculate remaining budget
            const totalExpenses = fixedExpenses + essentialExpenses + discretionaryExpenses;
            const remainingBudget = netIncome - monthlySavingsTarget - totalExpenses;
            document.getElementById('remainingBudgetSummary').textContent = '$' + remainingBudget.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 });

            // Calculate savings rate
            const savingsRate = netIncome > 0 ? (monthlySavingsTarget / netIncome) * 100 : 0;
            document.getElementById('savingsRateSummary').textContent = savingsRate.toFixed(1) + '%';

            // Validation
            let validation = '-';
            if (remainingBudget >= -10 && remainingBudget <= 10) {
                validation = ' Tight but feasible';
            } else if (remainingBudget > 10) {
                validation = ' Feasible';
            } else {
                validation = 'Over budget';
            }
            document.getElementById('budgetValidationSummary').textContent = validation;
        }

        function loadSimpleBudgetSettings() {
            const savedSettings = localStorage.getItem('simpleBudgetSettings');
            if (savedSettings) {
                const settings = JSON.parse(savedSettings);

                // Populate form fields with saved values
                document.getElementById('grossIncome').value = settings.grossIncome || '';
                document.getElementById('federalTax').value = settings.federalTax || '';
                document.getElementById('provincialTax').value = settings.provincialTax || '';
                document.getElementById('cppEi').value = settings.cppEi || '';
                document.getElementById('netIncome').value = settings.netIncome || '';
                document.getElementById('annualSavingsGoal').value = settings.annualSavingsGoal || '';
                document.getElementById('monthlySavingsTarget').value = settings.monthlySavingsTarget || '';
                document.getElementById('fixedExpenses').value = settings.fixedExpenses || '';
                document.getElementById('essentialExpenses').value = settings.essentialExpenses || '';
                document.getElementById('discretionaryExpenses').value = settings.discretionaryExpenses || '';
            } else {
                // Set default values based on your budget breakdown
                document.getElementById('grossIncome').value = '11667';
                document.getElementById('federalTax').value = '2500';
                document.getElementById('provincialTax').value = '750';
                document.getElementById('cppEi').value = '333';
                document.getElementById('netIncome').value = '8084';
                document.getElementById('annualSavingsGoal').value = '52000';
                document.getElementById('monthlySavingsTarget').value = '4333';
                document.getElementById('fixedExpenses').value = '2450';
                document.getElementById('essentialExpenses').value = '750';
                document.getElementById('discretionaryExpenses').value = '501';
            }
        }

        async function saveSimpleBudgetSettings() {
            const settings = {
                grossIncome: parseFloat(document.getElementById('grossIncome').value) || 0,
                federalTax: parseFloat(document.getElementById('federalTax').value) || 0,
                provincialTax: parseFloat(document.getElementById('provincialTax').value) || 0,
                cppEi: parseFloat(document.getElementById('cppEi').value) || 0,
                netIncome: parseFloat(document.getElementById('netIncome').value) || 0,
                annualSavingsGoal: parseFloat(document.getElementById('annualSavingsGoal').value) || 0,
                monthlySavingsTarget: parseFloat(document.getElementById('monthlySavingsTarget').value) || 0,
                fixedExpenses: parseFloat(document.getElementById('fixedExpenses').value) || 0,
                essentialExpenses: parseFloat(document.getElementById('essentialExpenses').value) || 0,
                discretionaryExpenses: parseFloat(document.getElementById('discretionaryExpenses').value) || 0
            };

            localStorage.setItem('simpleBudgetSettings', JSON.stringify(settings));

            // Update all displays to reflect new settings
            await updatePeriodView();
            updateReports();
            updateSaveScreen();

            // Update chart if on reports screen
            if (currentScreen === 2) {
                setTimeout(updateChart, 100);
            }

            alert('Settings saved! All budgets and targets have been updated.');
            closeSettings();
        }

        // Tax Calculator Functions
        const TAX_BRACKETS_2024 = {
            federal: [
                { min: 0, max: 55967, rate: 0.15 },
                { min: 55967, max: 111733, rate: 0.205 },
                { min: 111733, max: 173205, rate: 0.26 },
                { min: 173205, max: 246752, rate: 0.29 },
                { min: 246752, max: Infinity, rate: 0.33 }
            ],
            provinces: {
                ON: [ // Ontario
                    { min: 0, max: 51446, rate: 0.0505 },
                    { min: 51446, max: 102894, rate: 0.0915 },
                    { min: 102894, max: 150000, rate: 0.1116 },
                    { min: 150000, max: 220000, rate: 0.1216 },
                    { min: 220000, max: Infinity, rate: 0.1316 }
                ],
                BC: [ // British Columbia
                    { min: 0, max: 45654, rate: 0.0506 },
                    { min: 45654, max: 91310, rate: 0.077 },
                    { min: 91310, max: 104835, rate: 0.105 },
                    { min: 104835, max: 127299, rate: 0.1229 },
                    { min: 127299, max: 172602, rate: 0.147 },
                    { min: 172602, max: 240716, rate: 0.168 },
                    { min: 240716, max: Infinity, rate: 0.205 }
                ],
                AB: [ // Alberta
                    { min: 0, max: 148269, rate: 0.10 },
                    { min: 148269, max: 177922, rate: 0.12 },
                    { min: 177922, max: 237230, rate: 0.13 },
                    { min: 237230, max: 355845, rate: 0.14 },
                    { min: 355845, max: Infinity, rate: 0.15 }
                ],
                SK: [ // Saskatchewan
                    { min: 0, max: 52057, rate: 0.105 },
                    { min: 52057, max: 148734, rate: 0.125 },
                    { min: 148734, max: Infinity, rate: 0.145 }
                ],
                MB: [ // Manitoba
                    { min: 0, max: 36842, rate: 0.108 },
                    { min: 36842, max: 79625, rate: 0.1275 },
                    { min: 79625, max: Infinity, rate: 0.174 }
                ],
                QC: [ // Quebec
                    { min: 0, max: 49275, rate: 0.14 },
                    { min: 49275, max: 98540, rate: 0.19 },
                    { min: 98540, max: 119910, rate: 0.24 },
                    { min: 119910, max: Infinity, rate: 0.2575 }
                ],
                NB: [ // New Brunswick
                    { min: 0, max: 47715, rate: 0.0968 },
                    { min: 47715, max: 95431, rate: 0.1482 },
                    { min: 95431, max: 176756, rate: 0.1652 },
                    { min: 176756, max: Infinity, rate: 0.195 }
                ],
                NS: [ // Nova Scotia
                    { min: 0, max: 29590, rate: 0.0879 },
                    { min: 29590, max: 59180, rate: 0.1495 },
                    { min: 59180, max: 93000, rate: 0.1667 },
                    { min: 93000, max: 150000, rate: 0.175 },
                    { min: 150000, max: Infinity, rate: 0.21 }
                ],
                PE: [ // Prince Edward Island
                    { min: 0, max: 31984, rate: 0.098 },
                    { min: 31984, max: 63969, rate: 0.138 },
                    { min: 63969, max: Infinity, rate: 0.167 }
                ],
                NL: [ // Newfoundland and Labrador
                    { min: 0, max: 43198, rate: 0.087 },
                    { min: 43198, max: 86395, rate: 0.145 },
                    { min: 86395, max: 154244, rate: 0.158 },
                    { min: 154244, max: 215943, rate: 0.173 },
                    { min: 215943, max: 275870, rate: 0.183 },
                    { min: 275870, max: 551739, rate: 0.198 },
                    { min: 551739, max: 1103478, rate: 0.208 },
                    { min: 1103478, max: Infinity, rate: 0.218 }
                ],
                NT: [ // Northwest Territories
                    { min: 0, max: 50877, rate: 0.059 },
                    { min: 50877, max: 101754, rate: 0.086 },
                    { min: 101754, max: 165429, rate: 0.122 },
                    { min: 165429, max: Infinity, rate: 0.1405 }
                ],
                NU: [ // Nunavut
                    { min: 0, max: 50877, rate: 0.04 },
                    { min: 50877, max: 101754, rate: 0.07 },
                    { min: 101754, max: 165429, rate: 0.09 },
                    { min: 165429, max: Infinity, rate: 0.115 }
                ],
                YT: [ // Yukon
                    { min: 0, max: 55967, rate: 0.064 },
                    { min: 55967, max: 111733, rate: 0.09 },
                    { min: 111733, max: 173205, rate: 0.109 },
                    { min: 173205, max: 500000, rate: 0.128 },
                    { min: 500000, max: Infinity, rate: 0.15 }
                ]
            }
        };

        function calculateTaxes() {
            const yearlyIncome = parseFloat(document.getElementById('grossYearlyIncome').value) || 0;
            const province = document.getElementById('provinceValue').textContent;
            const provinceCode = getProvinceCode(province);

            if (yearlyIncome <= 0) {
                alert('Please enter a valid yearly income');
                return;
            }

            // Calculate federal tax
            const federalTax = calculateTax(yearlyIncome, TAX_BRACKETS_2024.federal);

            // Calculate provincial tax
            const provincialTax = calculateTax(yearlyIncome, TAX_BRACKETS_2024.provinces[provinceCode]);

            // Calculate CPP/EI (2024 rates)
            const cppContribution = Math.min(yearlyIncome, 68500) * 0.0595; // 5.95% up to $68,500
            const eiContribution = Math.min(yearlyIncome, 63100) * 0.0163; // 1.63% up to $63,100
            const totalCppEi = cppContribution + eiContribution;

            // Calculate monthly amounts
            const monthlyGross = yearlyIncome / 12;
            const monthlyFederalTax = federalTax / 12;
            const monthlyProvincialTax = provincialTax / 12;
            const monthlyCppEi = totalCppEi / 12;
            const monthlyNet = monthlyGross - monthlyFederalTax - monthlyProvincialTax - monthlyCppEi;

            // Display results
            document.getElementById('monthlyGrossResult').textContent = formatCurrency(monthlyGross);
            document.getElementById('federalTaxResult').textContent = formatCurrency(monthlyFederalTax);
            document.getElementById('provincialTaxResult').textContent = formatCurrency(monthlyProvincialTax);
            document.getElementById('cppEiResult').textContent = formatCurrency(monthlyCppEi);
            document.getElementById('netIncomeResult').textContent = formatCurrency(monthlyNet);

            // Show results section
            document.getElementById('taxResults').style.display = 'block';

            // Auto-populate manual override fields
            document.getElementById('grossIncome').value = monthlyGross.toFixed(2);
            document.getElementById('federalTax').value = monthlyFederalTax.toFixed(2);
            document.getElementById('provincialTax').value = monthlyProvincialTax.toFixed(2);
            document.getElementById('cppEi').value = monthlyCppEi.toFixed(2);
            document.getElementById('netIncome').value = monthlyNet.toFixed(2);

            // Update budget summary - this function is now deprecated since budget is in its own slide-out
            // updateSimpleBudgetSummary();
        }

        function calculateTax(income, brackets) {
            let totalTax = 0;

            for (let bracket of brackets) {
                if (income > bracket.min) {
                    const taxableInBracket = Math.min(income - bracket.min, bracket.max - bracket.min);
                    totalTax += taxableInBracket * bracket.rate;
                }
            }

            return totalTax;
        }

        function getProvinceCode(provinceName) {
            const provinceMap = {
                'Ontario': 'ON',
                'British Columbia': 'BC',
                'Alberta': 'AB',
                'Saskatchewan': 'SK',
                'Manitoba': 'MB',
                'Quebec': 'QC',
                'New Brunswick': 'NB',
                'Nova Scotia': 'NS',
                'Prince Edward Island': 'PE',
                'Newfoundland and Labrador': 'NL',
                'Northwest Territories': 'NT',
                'Nunavut': 'NU',
                'Yukon': 'YT'
            };
            return provinceMap[provinceName] || 'ON';
        }

        function toggleAccordion(id) {
            const header = document.querySelector(`[onclick="toggleAccordion('${id}')"]`);
            const content = document.getElementById(`${id}Content`);
            const icon = document.getElementById(`${id}Icon`);

            const isExpanded = header.classList.contains('expanded');

            if (isExpanded) {
                // Collapse
                header.classList.remove('expanded');
                content.classList.remove('expanded');
            } else {
                // Expand
                header.classList.add('expanded');
                content.classList.add('expanded');
            }
        }

        // Add event listeners for settings inputs
        document.addEventListener('DOMContentLoaded', function () {
            // Budget form event listeners are now handled in the budget slide-out
            // The old settings form elements no longer exist

            // Setup province dropdown
            const provinceItems = document.querySelectorAll('#provinceContent .select-item');
            provinceItems.forEach(item => {
                item.addEventListener('click', function () {
                    const value = this.getAttribute('data-value');
                    const text = this.textContent;
                    selectSlideOutOption('province', value, text);
                });
            });

            // Setup budget province dropdown
            const budgetProvinceItems = document.querySelectorAll('#budgetProvinceContent .select-item');
            budgetProvinceItems.forEach(item => {
                item.addEventListener('click', function () {
                    const value = this.getAttribute('data-value');
                    const text = this.textContent;
                    selectSlideOutOption('budgetProvince', value, text);
                });
            });

            // Add event listeners for budget form inputs
            ['budgetGrossYearlyIncome', 'budgetGrossIncome', 'budgetFederalTax', 'budgetProvincialTax', 'budgetCppEi', 'budgetNetIncome', 'budgetAnnualSavingsGoal', 'budgetFixedExpenses', 'budgetEssentialExpenses', 'budgetDiscretionaryExpenses'].forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.addEventListener('input', function () {
                        updateBudgetSummary();
                    });
                }
            });
        });

        // Budget Flow Management
        let currentBudgetStep = 1;
        const totalBudgetSteps = 6;
        
        function openBudgetFlow() {
            const budgetOverlay = document.getElementById('budgetOverlay');
            const budgetPanel = document.getElementById('budgetPanel');
            const appContainer = document.querySelector('.app-container');

            // Show budget overlay and panel
            budgetOverlay.classList.add('active');
            budgetPanel.classList.add('active');
            appContainer.classList.add('settings-open');

            // Reset to first step
            currentBudgetStep = 1;
            showBudgetStep(1);
            
            // Load existing settings into budget form
            loadBudgetSettings();
        }

        function closeBudgetFlow() {
            const budgetOverlay = document.getElementById('budgetOverlay');
            const budgetPanel = document.getElementById('budgetPanel');
            const appContainer = document.querySelector('.app-container');

            // Hide budget overlay and panel
            budgetOverlay.classList.remove('active');
            budgetPanel.classList.remove('active');
            appContainer.classList.remove('settings-open');
        }
        
        function showBudgetStep(step) {
            // Hide all screens
            document.querySelectorAll('.budget-flow-screen').forEach(screen => {
                screen.classList.remove('active');
            });
            
            // Show current screen
            document.getElementById(`budgetScreen${step}`).classList.add('active');
            
            // Update progress indicators
            updateBudgetProgress(step);
            
            // Update navigation buttons
            updateBudgetNavigation(step);
            
            // Update interactive elements based on current step
            setTimeout(() => {
                if (step === 2) {
                    updateSavingsVisualization();
                } else if (step === 3) {
                    updateFixedExpenseVisualization();
                } else if (step === 4) {
                    updateEssentialExpenseVisualization();
                } else if (step === 5) {
                    updateDiscretionaryExpenseVisualization();
                } else if (step === 6) {
                    updateSummaryCharts();
                }
                // Initialize icons for the new screen
                safeInitLucideIcons();
            }, 100);
            
            currentBudgetStep = step;
        }
        
        function updateBudgetProgress(step) {
            // Update progress dots
            document.querySelectorAll('.progress-dot').forEach((dot, index) => {
                dot.classList.remove('active', 'completed');
                if (index + 1 < step) {
                    dot.classList.add('completed');
                } else if (index + 1 === step) {
                    dot.classList.add('active');
                }
            });
            
            // Update progress label
            const labels = [
                'Income & Taxes',
                'Savings Goals', 
                'Fixed Expenses',
                'Essential Expenses',
                'Discretionary Expenses',
                'Review & Summary'
            ];
            
            document.getElementById('budgetProgressLabel').textContent = 
                `Step ${step} of ${totalBudgetSteps}: ${labels[step - 1]}`;
        }
        
        function updateBudgetNavigation(step) {
            const prevBtn = document.getElementById('budgetPrevBtn');
            const nextBtn = document.getElementById('budgetNextBtn');
            const saveBtn = document.getElementById('budgetSaveBtn');
            
            // Previous button
            prevBtn.disabled = step === 1;
            
            // Next/Save buttons
            if (step === totalBudgetSteps) {
                nextBtn.style.display = 'none';
                saveBtn.style.display = 'block';
            } else {
                nextBtn.style.display = 'block';
                saveBtn.style.display = 'none';
            }
        }
        
        function nextBudgetStep() {
            if (currentBudgetStep < totalBudgetSteps) {
                showBudgetStep(currentBudgetStep + 1);
            }
        }
        
        function previousBudgetStep() {
            if (currentBudgetStep > 1) {
                showBudgetStep(currentBudgetStep - 1);
            }
        }
        
        // Legacy function names for compatibility
        function openBudgetSetup() {
            openBudgetFlow();
        }
        
        function closeBudgetSetup() {
            closeBudgetFlow();
        }
        
        // Budget Overview Card Functions
        function toggleBudgetTimeRange(range) {
            // Update button states
            document.querySelectorAll('.timerange-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-range="${range}"]`).classList.add('active');
            
            // Update subtitle
            const subtitle = document.getElementById('budgetSubtitle');
            subtitle.textContent = range === 'monthly' ? 'Monthly overview' : 'Yearly overview';
            
            // Update budget bars
            updateBudgetOverview(range);
        }
        
        function updateBudgetOverview(timeRange = 'monthly') {
            const settings = getSimpleBudgetSettings();
            
            if (!settings.netIncome) {
                // Show placeholder data if no budget is set
                return;
            }
            
            const isMonthly = timeRange === 'monthly';
            const multiplier = isMonthly ? 1 : 12;
            
            // Savings data
            const savingsGoal = isMonthly ? settings.monthlySavingsTarget : settings.annualSavingsGoal;
            const currentSavings = savingsGoal * 0.6; // Placeholder - would come from actual savings data
            const savingsPercentage = Math.min((currentSavings / savingsGoal) * 100, 100);
            
            // Update savings bar
            document.getElementById('savingsAmount').textContent = 
                `$${Math.round(currentSavings).toLocaleString()} / $${Math.round(savingsGoal).toLocaleString()}`;
            document.getElementById('savingsProgress').style.width = `${savingsPercentage}%`;
            
            // Spending data - budget limits
            const fixedBudget = (settings.fixedExpenses || 0) * multiplier;
            const essentialBudget = (settings.essentialExpenses || 0) * multiplier;
            const discretionaryBudget = (settings.discretionaryExpenses || 0) * multiplier;
            const totalBudget = fixedBudget + essentialBudget + discretionaryBudget;
            
            // Get actual spending data (placeholder - would come from actual expense tracking)
            const fixedSpent = fixedBudget * 0.85; // 85% of budget spent
            const essentialSpent = essentialBudget * 0.72; // 72% of budget spent  
            const discretionarySpent = discretionaryBudget * 0.95; // 95% of budget spent
            const totalSpent = fixedSpent + essentialSpent + discretionarySpent;
            
            // Calculate percentages for spending segments (based on budget, filled based on spent)
            const fixedPercent = totalBudget > 0 ? (fixedBudget / totalBudget) * 100 : 0;
            const essentialPercent = totalBudget > 0 ? (essentialBudget / totalBudget) * 100 : 0;
            const discretionaryPercent = totalBudget > 0 ? (discretionaryBudget / totalBudget) * 100 : 0;
            
            // Calculate fill percentages (how much of each category budget is spent)
            const fixedFillPercent = fixedBudget > 0 ? (fixedSpent / fixedBudget) * 100 : 0;
            const essentialFillPercent = essentialBudget > 0 ? (essentialSpent / essentialBudget) * 100 : 0;
            const discretionaryFillPercent = discretionaryBudget > 0 ? (discretionarySpent / discretionaryBudget) * 100 : 0;
            
            // Update spending bar header
            document.getElementById('spendingAmount').textContent = 
                `$${Math.round(totalSpent).toLocaleString()} / $${Math.round(totalBudget).toLocaleString()}`;
            
            // Update spending segments - width based on percentage of total spent
            const fixedSegment = document.getElementById('fixedSpending');
            const essentialSegment = document.getElementById('essentialSpending');  
            const discretionarySegment = document.getElementById('discretionarySpending');
            
            // Calculate widths based on actual spending percentages
            const fixedSpentPercent = totalSpent > 0 ? (fixedSpent / totalSpent) * 100 : 0;
            const essentialSpentPercent = totalSpent > 0 ? (essentialSpent / totalSpent) * 100 : 0;
            const discretionarySpentPercent = totalSpent > 0 ? (discretionarySpent / totalSpent) * 100 : 0;
            
            fixedSegment.style.width = `${fixedSpentPercent}%`;
            fixedSegment.style.background = ''; // Clear any custom background, use CSS class
            fixedSegment.title = `Fixed: $${Math.round(fixedSpent).toLocaleString()} / $${Math.round(fixedBudget).toLocaleString()}`;
                
            essentialSegment.style.width = `${essentialSpentPercent}%`;
            essentialSegment.style.background = ''; // Clear any custom background, use CSS class
            essentialSegment.title = `Essential: $${Math.round(essentialSpent).toLocaleString()} / $${Math.round(essentialBudget).toLocaleString()}`;
                
            discretionarySegment.style.width = `${discretionarySpentPercent}%`;
            discretionarySegment.style.background = ''; // Clear any custom background, use CSS class
            discretionarySegment.title = `Discretionary: $${Math.round(discretionarySpent).toLocaleString()} / $${Math.round(discretionaryBudget).toLocaleString()}`;
        }

        function loadBudgetSettings() {
            const settings = getSimpleBudgetSettings();

            // Populate form fields with existing settings
            document.getElementById('budgetGrossYearlyIncome').value = settings.grossYearlyIncome || '';
            document.getElementById('budgetProvinceValue').textContent = settings.province || 'Ontario';
            document.getElementById('budgetGrossIncome').value = settings.grossIncome || '';
            document.getElementById('budgetFederalTax').value = settings.federalTax || '';
            document.getElementById('budgetProvincialTax').value = settings.provincialTax || '';
            document.getElementById('budgetCppEi').value = settings.cppEi || '';
            document.getElementById('budgetNetIncome').value = settings.netIncome || '';
            document.getElementById('budgetAnnualSavingsGoal').value = settings.annualSavingsGoal || '';
            document.getElementById('budgetFixedExpenses').value = settings.fixedExpenses || '';
            document.getElementById('budgetEssentialExpenses').value = settings.essentialExpenses || '';
            document.getElementById('budgetDiscretionaryExpenses').value = settings.discretionaryExpenses || '';

            // Update budget summary
            updateBudgetSummary();
        }

        function calculateBudgetTaxes() {
            const yearlyIncome = parseFloat(document.getElementById('budgetGrossYearlyIncome').value) || 0;
            const province = document.getElementById('budgetProvinceValue').textContent;
            const provinceCode = getProvinceCode(province);

            if (yearlyIncome <= 0) {
                alert('Please enter a valid yearly income');
                return;
            }

            // Calculate federal tax
            const federalTax = calculateTax(yearlyIncome, TAX_BRACKETS_2024.federal);

            // Calculate provincial tax
            const provincialTax = calculateTax(yearlyIncome, TAX_BRACKETS_2024.provinces[provinceCode]);

            // Calculate CPP/EI (2024 rates)
            const cppContribution = Math.min(yearlyIncome, 68500) * 0.0595; // 5.95% up to $68,500
            const eiContribution = Math.min(yearlyIncome, 63100) * 0.0163; // 1.63% up to $63,100
            const totalCppEi = cppContribution + eiContribution;

            // Calculate monthly amounts
            const monthlyGross = yearlyIncome / 12;
            const monthlyFederalTax = federalTax / 12;
            const monthlyProvincialTax = provincialTax / 12;
            const monthlyCppEi = totalCppEi / 12;
            const monthlyNet = monthlyGross - monthlyFederalTax - monthlyProvincialTax - monthlyCppEi;

            // Display results
            document.getElementById('budgetMonthlyGrossResult').textContent = formatCurrency(monthlyGross);
            document.getElementById('budgetFederalTaxResult').textContent = formatCurrency(monthlyFederalTax);
            document.getElementById('budgetProvincialTaxResult').textContent = formatCurrency(monthlyProvincialTax);
            document.getElementById('budgetCppEiResult').textContent = formatCurrency(monthlyCppEi);
            document.getElementById('budgetNetIncomeResult').textContent = formatCurrency(monthlyNet);

            // Show results section
            document.getElementById('budgetTaxResults').style.display = 'block';

            // Auto-populate manual override fields
            document.getElementById('budgetGrossIncome').value = monthlyGross.toFixed(2);
            document.getElementById('budgetFederalTax').value = monthlyFederalTax.toFixed(2);
            document.getElementById('budgetProvincialTax').value = monthlyProvincialTax.toFixed(2);
            document.getElementById('budgetCppEi').value = monthlyCppEi.toFixed(2);
            document.getElementById('budgetNetIncome').value = monthlyNet.toFixed(2);

            // Update budget summary
            updateBudgetSummary();
            
            // Show income visualization
            updateIncomeVisualization();
        }

        function updateBudgetSummary() {
            const grossIncome = parseFloat(document.getElementById('budgetGrossIncome').value) || 0;
            const federalTax = parseFloat(document.getElementById('budgetFederalTax').value) || 0;
            const provincialTax = parseFloat(document.getElementById('budgetProvincialTax').value) || 0;
            const cppEi = parseFloat(document.getElementById('budgetCppEi').value) || 0;
            const netIncome = parseFloat(document.getElementById('budgetNetIncome').value) || 0;
            const annualSavingsGoal = parseFloat(document.getElementById('budgetAnnualSavingsGoal').value) || 0;
            const fixedExpenses = parseFloat(document.getElementById('budgetFixedExpenses').value) || 0;
            const essentialExpenses = parseFloat(document.getElementById('budgetEssentialExpenses').value) || 0;
            const discretionaryExpenses = parseFloat(document.getElementById('budgetDiscretionaryExpenses').value) || 0;

            // Calculate monthly savings target
            const monthlySavingsTarget = annualSavingsGoal / 12;
            document.getElementById('budgetMonthlySavingsTarget').value = monthlySavingsTarget.toFixed(2);

            // Calculate remaining budget
            const totalExpenses = fixedExpenses + essentialExpenses + discretionaryExpenses + monthlySavingsTarget;
            const remainingBudget = netIncome - totalExpenses;

            // Calculate savings rate
            const savingsRate = netIncome > 0 ? (monthlySavingsTarget / netIncome) * 100 : 0;

            // Update summary display
            document.getElementById('budgetRemainingBudgetSummary').textContent = formatCurrency(remainingBudget);
            document.getElementById('budgetSavingsRateSummary').textContent = savingsRate.toFixed(1) + '%';

            // Validation
            let validationText = '-';
            let validationClass = '';

            if (remainingBudget < 0) {
                validationText = 'Over Budget';
                validationClass = 'negative';
            } else if (remainingBudget < 100) {
                validationText = 'Tight Budget';
                validationClass = 'warning';
            } else {
                validationText = 'Good Budget';
                validationClass = 'positive';
            }

            const validationElement = document.getElementById('budgetValidationSummary');
            validationElement.textContent = validationText;
            validationElement.className = 'budget-value ' + validationClass;
            
            // Update summary charts if on summary screen
            if (document.getElementById('budgetScreen6').classList.contains('active')) {
                updateSummaryCharts();
            }
        }

        // Interactive chart functions
        function updateSavingsVisualization() {
            const annualSavings = parseFloat(document.getElementById('budgetAnnualSavingsGoal').value) || 0;
            const netIncome = parseFloat(document.getElementById('budgetNetIncome').value) || 0;
            const monthlySavings = annualSavings / 12;
            
            document.getElementById('budgetMonthlySavingsTarget').value = monthlySavings.toFixed(2);
            
            if (netIncome > 0 && annualSavings > 0) {
                const savingsRate = (monthlySavings / netIncome) * 100;
                document.getElementById('savingsRateDisplay').textContent = savingsRate.toFixed(1) + '%';
                document.getElementById('savingsRateDescription').textContent = `$${monthlySavings.toFixed(0)} per month of your $${netIncome.toFixed(0)} net income`;
                document.getElementById('savingsVisualization').style.display = 'block';
            } else {
                document.getElementById('savingsVisualization').style.display = 'none';
            }
        }

        function updateFixedExpenseVisualization() {
            const fixedExpenses = parseFloat(document.getElementById('budgetFixedExpenses').value) || 0;
            const netIncome = parseFloat(document.getElementById('budgetNetIncome').value) || 0;
            
            if (netIncome > 0 && fixedExpenses > 0) {
                const expenseRate = (fixedExpenses / netIncome) * 100;
                document.getElementById('fixedExpenseRateDisplay').textContent = expenseRate.toFixed(1) + '%';
                document.getElementById('fixedExpenseRateDescription').textContent = `$${fixedExpenses.toFixed(0)} per month of your $${netIncome.toFixed(0)} net income`;
                document.getElementById('fixedExpenseVisualization').style.display = 'block';
            } else {
                document.getElementById('fixedExpenseVisualization').style.display = 'none';
            }
            updateBudgetSummary();
        }

        function updateEssentialExpenseVisualization() {
            const essentialExpenses = parseFloat(document.getElementById('budgetEssentialExpenses').value) || 0;
            const netIncome = parseFloat(document.getElementById('budgetNetIncome').value) || 0;
            
            if (netIncome > 0 && essentialExpenses > 0) {
                const expenseRate = (essentialExpenses / netIncome) * 100;
                document.getElementById('essentialExpenseRateDisplay').textContent = expenseRate.toFixed(1) + '%';
                document.getElementById('essentialExpenseRateDescription').textContent = `$${essentialExpenses.toFixed(0)} per month of your $${netIncome.toFixed(0)} net income`;
                document.getElementById('essentialExpenseVisualization').style.display = 'block';
            } else {
                document.getElementById('essentialExpenseVisualization').style.display = 'none';
            }
            updateBudgetSummary();
        }

        function updateDiscretionaryExpenseVisualization() {
            const discretionaryExpenses = parseFloat(document.getElementById('budgetDiscretionaryExpenses').value) || 0;
            const netIncome = parseFloat(document.getElementById('budgetNetIncome').value) || 0;
            
            if (netIncome > 0 && discretionaryExpenses > 0) {
                const expenseRate = (discretionaryExpenses / netIncome) * 100;
                document.getElementById('discretionaryExpenseRateDisplay').textContent = expenseRate.toFixed(1) + '%';
                document.getElementById('discretionaryExpenseRateDescription').textContent = `$${discretionaryExpenses.toFixed(0)} per month of your $${netIncome.toFixed(0)} net income`;
                document.getElementById('discretionaryExpenseVisualization').style.display = 'block';
            } else {
                document.getElementById('discretionaryExpenseVisualization').style.display = 'none';
            }
            updateBudgetSummary();
        }

        function updateExpenseVisualization() {
            // Legacy function for backward compatibility
            updateBudgetSummary();
        }

        function updateIncomeVisualization() {
            const grossIncome = parseFloat(document.getElementById('budgetGrossIncome').value) || 0;
            const federalTax = parseFloat(document.getElementById('budgetFederalTax').value) || 0;
            const provincialTax = parseFloat(document.getElementById('budgetProvincialTax').value) || 0;
            const cppEi = parseFloat(document.getElementById('budgetCppEi').value) || 0;
            const netIncome = grossIncome - federalTax - provincialTax - cppEi;
            
            if (grossIncome > 0) {
                document.getElementById('incomeVisualization').style.display = 'block';
                createIncomeBreakdownChart();
            } else {
                document.getElementById('incomeVisualization').style.display = 'none';
            }
        }

        function createIncomeBreakdownChart() {
            const canvas = document.getElementById('incomeBreakdownChart');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            const grossIncome = parseFloat(document.getElementById('budgetGrossIncome').value) || 0;
            const federalTax = parseFloat(document.getElementById('budgetFederalTax').value) || 0;
            const provincialTax = parseFloat(document.getElementById('budgetProvincialTax').value) || 0;
            const cppEi = parseFloat(document.getElementById('budgetCppEi').value) || 0;
            const netIncome = grossIncome - federalTax - provincialTax - cppEi;

            if (window.incomeChart) {
                window.incomeChart.destroy();
            }

            window.incomeChart = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: ['Take Home', 'Federal Tax', 'Provincial Tax', 'CPP/EI'],
                    datasets: [{
                        data: [netIncome, federalTax, provincialTax, cppEi],
                        backgroundColor: ['#10b981', '#ef4444', '#f59e0b', '#8b5cf6'],
                        borderWidth: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: {
                                padding: 15,
                                font: { size: 11 }
                            }
                        }
                    }
                }
            });
        }

        function updateSummaryCharts() {
            const netIncome = parseFloat(document.getElementById('budgetNetIncome').value) || 0;
            const fixedExpenses = parseFloat(document.getElementById('budgetFixedExpenses').value) || 0;
            const essentialExpenses = parseFloat(document.getElementById('budgetEssentialExpenses').value) || 0;
            const discretionaryExpenses = parseFloat(document.getElementById('budgetDiscretionaryExpenses').value) || 0;
            const annualSavingsGoal = parseFloat(document.getElementById('budgetAnnualSavingsGoal').value) || 0;
            const monthlySavingsTarget = annualSavingsGoal / 12;
            const totalExpenses = fixedExpenses + essentialExpenses + discretionaryExpenses;
            const remainingBudget = netIncome - totalExpenses - monthlySavingsTarget;

            // Update summary values
            document.getElementById('budgetNetIncomeSummary').textContent = formatCurrency(netIncome);
            document.getElementById('budgetTotalExpensesSummary').textContent = formatCurrency(totalExpenses);
            document.getElementById('budgetMonthlySavingsSummary').textContent = formatCurrency(monthlySavingsTarget);
            document.getElementById('budgetRemainingBudgetSummary').textContent = formatCurrency(remainingBudget);

            // Create main budget breakdown chart
            createBudgetSummaryChart(netIncome, fixedExpenses, essentialExpenses, discretionaryExpenses, monthlySavingsTarget, remainingBudget);
            
            // Create mini charts for each card
            createMiniChart('incomeChart', [netIncome], ['#3b82f6']);
            createMiniChart('expensesChart', [fixedExpenses, essentialExpenses, discretionaryExpenses], ['#ef4444', '#f59e0b', '#8b5cf6']);
            createMiniChart('savingsChart', [monthlySavingsTarget], ['#10b981']);
            createMiniChart('remainingChart', [Math.max(0, remainingBudget)], remainingBudget >= 0 ? ['#10b981'] : ['#ef4444']);
        }

        function createBudgetSummaryChart(netIncome, fixed, essential, discretionary, savings, remaining) {
            const canvas = document.getElementById('budgetSummaryChart');
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            
            if (window.budgetSummaryChart) {
                window.budgetSummaryChart.destroy();
            }

            const data = [];
            const labels = [];
            const colors = [];

            if (fixed > 0) { data.push(fixed); labels.push('Fixed Expenses'); colors.push('#9333ea'); }
            if (essential > 0) { data.push(essential); labels.push('Essential Expenses'); colors.push('#7c3aed'); }
            if (discretionary > 0) { data.push(discretionary); labels.push('Discretionary'); colors.push('#8b5cf6'); }
            if (savings > 0) { data.push(savings); labels.push('Savings Target'); colors.push('#5fa42e'); }
            if (remaining > 0) { data.push(remaining); labels.push('Remaining'); colors.push('#6b7280'); }

            window.budgetSummaryChart = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: labels,
                    datasets: [{
                        data: data,
                        backgroundColor: colors,
                        borderWidth: 0
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            position: 'bottom',
                            labels: {
                                padding: 20,
                                font: { size: 12 }
                            }
                        }
                    },
                    animation: {
                        animateScale: true,
                        duration: 1000
                    }
                }
            });
make         }

        function createMiniChart(canvasId, data, colors) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            
            if (window[canvasId + 'Instance']) {
                window[canvasId + 'Instance'].destroy();
            }

            window[canvasId + 'Instance'] = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: [''],
                    datasets: [{
                        data: data,
                        backgroundColor: colors,
                        borderWidth: 0,
                        barThickness: 20
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        x: { display: false },
                        y: { display: false }
                    },
                    animation: {
                        duration: 800,
                        easing: 'easeOutQuart'
                    }
                }
            });
        }

        async function saveBudgetSettings() {
            // Calculate monthly savings target first
            const annualSavingsGoal = parseFloat(document.getElementById('budgetAnnualSavingsGoal').value) || 0;
            const monthlySavingsTarget = annualSavingsGoal / 12;

            const settings = {
                grossYearlyIncome: parseFloat(document.getElementById('budgetGrossYearlyIncome').value) || 0,
                province: document.getElementById('budgetProvinceValue').textContent,
                grossIncome: parseFloat(document.getElementById('budgetGrossIncome').value) || 0,
                federalTax: parseFloat(document.getElementById('budgetFederalTax').value) || 0,
                provincialTax: parseFloat(document.getElementById('budgetProvincialTax').value) || 0,
                cppEi: parseFloat(document.getElementById('budgetCppEi').value) || 0,
                netIncome: parseFloat(document.getElementById('budgetNetIncome').value) || 0,
                annualSavingsGoal: annualSavingsGoal,
                monthlySavingsTarget: monthlySavingsTarget, // Save monthly savings target
                fixedExpenses: parseFloat(document.getElementById('budgetFixedExpenses').value) || 0,
                essentialExpenses: parseFloat(document.getElementById('budgetEssentialExpenses').value) || 0,
                discretionaryExpenses: parseFloat(document.getElementById('budgetDiscretionaryExpenses').value) || 0
            };

            localStorage.setItem('simpleBudgetSettings', JSON.stringify(settings));

            // Update the save target display after saving
            updateSaveTargetDisplay();

            // Update the main app's budget display
            updateBudgetDisplay();
            
            // Update the budget overview card
            updateBudgetOverview('monthly');

            // Close the budget setup
            closeBudgetFlow();

            // Redirect to home page (screen 0)
            goToScreen(0);

            // Show success message
            alert('Budget settings saved successfully!');
        }
        async function loadSampleBudget() {
            const button = event?.currentTarget;
            if (!button) return;
            
            // Get the arrow element and label
            const arrow = button.querySelector('.settings-menu-arrow');
            const label = button.querySelector('.settings-menu-label');
            
            if (!arrow || !label) return;
            
            // Save original state
            const originalArrowHTML = arrow.innerHTML;
            const originalLabelText = label.textContent;
            
            try {
                // Set loading state
                button.style.pointerEvents = 'none';
                arrow.innerHTML = '<div class="spinner-circle"></div>';
                label.textContent = 'Loading...';
                
                // Show loading in transaction list too
                const transactionsList = document.getElementById('homeTransactionsList');
                const originalTransactionsHTML = transactionsList?.innerHTML;
                if (transactionsList) {
                    transactionsList.innerHTML = '<div style="text-align: center; color: #7f8c8d; padding: 20px;">Loading transactions...</div>';
                }
                
                // Load the data
                await loadTestData();
                
                // Transaction list will be updated by updateHomeScreen() called from loadTestData()
                
            } catch (error) {
                console.error('Error loading sample data:', error);
            } finally {
                // Restore original state
                button.style.pointerEvents = 'auto';
                arrow.innerHTML = originalArrowHTML;
                label.textContent = originalLabelText;
            }
        }

        async function clearAllData() {
            const button = event?.currentTarget;
            if (!button) return;
            
            // Get the arrow element and label
            const arrow = button.querySelector('.settings-menu-arrow');
            const label = button.querySelector('.settings-menu-label');
            
            if (!arrow || !label) return;
            
            // Save original state
            const originalArrowHTML = arrow.innerHTML;
            const originalLabelText = label.textContent;
            
            try {
                // Set loading state
                button.style.pointerEvents = 'none';
                arrow.innerHTML = '<div class="spinner-circle"></div>';
                label.textContent = 'Clearing...';
                
                // Clear database data first (if user is authenticated)
                if (window.plaidService) {
                    try {
                        const sessionToken = await window.plaidService.getClerkSessionToken();
                        
                        const response = await fetch(`${window.plaidService.baseUrl}/api/user/data`, {
                            method: 'DELETE',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${sessionToken}`,
                            }
                        });

                        if (response.ok) {
                            const result = await response.json();
                        } else {
                            console.warn('Failed to clear database data:', response.status);
                            // Continue with localStorage clearing even if database clearing fails
                        }
                    } catch (dbError) {
                        console.error('Error clearing database data:', dbError);
                        // Continue with localStorage clearing even if database clearing fails
                    }
                }

                // Clear all localStorage data
                localStorage.clear();

                // Clear API cache
                if (typeof clearAccountsCache === 'function') {
                    clearAccountsCache();
                }

                // For additional safety, clear all localStorage
                localStorage.clear();

                // Reload the page to reflect changes
                console.log("All data has been cleared successfully from both your device and our servers.");
                window.location.reload();
                
            } catch (error) {
                console.error('Error clearing data:', error);
                // Restore original state on error
                button.style.pointerEvents = 'auto';
                arrow.innerHTML = originalArrowHTML;
                label.textContent = originalLabelText;
            }
        }

        function openSupport() {
            // Don't close settings, just slide to support page
            const supportOverlay = document.getElementById('supportOverlay');
            const supportPanel = document.getElementById('supportPanel');
            const settingsPanel = document.getElementById('settingsPanel');
            const appContainer = document.querySelector('.app-container');

            // Show support overlay and panel
            supportOverlay.classList.add('active');
            supportPanel.classList.add('active');

            // Slide settings panel left
            settingsPanel.classList.add('budget-open');

            // Add slide transition to main content
            appContainer.classList.add('settings-open');
        }

        function closeSupport() {
            const supportOverlay = document.getElementById('supportOverlay');
            const supportPanel = document.getElementById('supportPanel');
            const settingsPanel = document.getElementById('settingsPanel');
            const appContainer = document.querySelector('.app-container');

            // Hide support overlay and panel
            supportOverlay.classList.remove('active');
            supportPanel.classList.remove('active');

            // Slide settings panel back to center
            settingsPanel.classList.remove('budget-open');

            // Remove slide transition from main content
            appContainer.classList.remove('settings-open');

            // Clear form fields
            document.getElementById('supportTitle').value = '';
            document.getElementById('supportDescription').value = '';
        }

        function sendSupportEmail() {
            const title = document.getElementById('supportTitle').value.trim();
            const description = document.getElementById('supportDescription').value.trim();

            if (!title || !description) {
                alert('Please fill in both subject and message fields.');
                return;
            }

            // Create mailto link
            const subject = encodeURIComponent(`Expense Tracker Support: ${title}`);
            const body = encodeURIComponent(`Subject: ${title}\n\nMessage:\n${description}\n\n---\nSent from Expense Tracker App`);
            const mailtoLink = `mailto:wdean.francis@gmail.com?subject=${subject}&body=${body}`;

            // Open email client
            window.location.href = mailtoLink;

            // Close support page
            closeSupport();

            // Show success message
            alert('Email client opened! Please send the email to complete your support request.');
        }
        function backToSettingsMenu() {
            document.getElementById('settingsForm').style.display = 'none';
            document.getElementById('settingsMenu').style.display = '';
        }


        // --- Expense Editing Support ---
        let editingExpense = null;
        async function editExpense(date, timestamp) {
            const expenses = await loadExpenses();
            const expenseList = expenses[date] || [];
            const expense = expenseList.find(e => e.timestamp === Number(timestamp));
            if (!expense) return;
            editingExpense = { date, timestamp: Number(timestamp) };
            showExpenseSlideOut();
            // Set date (for month mode)
            if (currentPeriodMode === 'month') {
                const datepickerId = 'expenseCustomDatepicker';
                if (!datepickerStates[datepickerId]) {
                    initializeDatepicker(datepickerId);
                }
                const state = datepickerStates[datepickerId];
                // Parse date properly to avoid timezone issues
                const dateParts = date.split('-').map(Number);
                state.selectedDate = new Date(dateParts[0], dateParts[1] - 1, dateParts[2]);
                updateDatepickerValue(datepickerId);
                renderCalendar(datepickerId);
            }
            document.getElementById('slideOutExpenseAmount').value = expense.amount;
            selectSlideOutOption('expenseCategory', expense.category, capitalizeFirstLetter(expense.category));
            document.getElementById('slideOutExpenseDescription').value = expense.description || '';
            // Change CTA text and handler
            const ctaBtn = document.querySelector('.slide-out-form .add-btn');
            if (ctaBtn) {
                ctaBtn.textContent = 'Save Expense';
                ctaBtn.onclick = saveEditedExpense;
            }
        }
        async function saveEditedExpense() {
            if (!editingExpense) return;
            const amount = parseFloat(document.getElementById('slideOutExpenseAmount').value);
            const category = document.getElementById('slideOutExpenseCategory').value;
            const description = document.getElementById('slideOutExpenseDescription').value;
            let targetDate = currentPeriodMode === 'month'
                ? document.getElementById('slideOutExpenseDate').value
                : getCurrentDate();
            if (!amount || amount <= 0) {
                alert('Please enter a valid amount');
                return;
            }
            if (!category) {
                alert('Please select a category');
                return;
            }
            const expenses = await loadExpenses();
            // Remove the old expense and get its index
            let oldList = expenses[editingExpense.date] || [];
            const oldIndex = oldList.findIndex(e => e.timestamp === editingExpense.timestamp);
            const oldExpense = oldList.find(e => e.timestamp === editingExpense.timestamp);

            // Preserve the original created timestamp
            const created = oldExpense && oldExpense.created ? oldExpense.created : editingExpense.timestamp;

            // Remove the old expense
            oldList = oldList.filter(e => e.timestamp !== editingExpense.timestamp);
            expenses[editingExpense.date] = oldList;

            // Create the updated expense
            const updatedExpense = {
                amount,
                category,
                description: description || '',
                timestamp: editingExpense.timestamp,
                created: created, // Preserve original created timestamp
                updated: Date.now()
            };

            // Add the updated expense at the same index if date is unchanged, else push to new date
            if (!expenses[targetDate]) expenses[targetDate] = [];

            if (editingExpense.date === targetDate && oldIndex !== -1) {
                // Insert at the same position to maintain order
                expenses[targetDate].splice(oldIndex, 0, updatedExpense);
            } else {
                // If date changed, add to the end of the new date's list
                expenses[targetDate].push(updatedExpense);
            }
            saveExpenses(expenses);
            // Reset form and editing state
            document.getElementById('slideOutExpenseAmount').value = '';
            document.getElementById('slideOutExpenseDescription').value = '';
            selectSlideOutOption('expenseCategory', 'groceries', 'Groceries');
            if (currentPeriodMode === 'month') clearDate('expenseCustomDatepicker');
            editingExpense = null;
            // Restore CTA
            const ctaBtn = document.querySelector('.slide-out-form .add-btn');
            if (ctaBtn) {
                ctaBtn.textContent = 'Add Expense';
                ctaBtn.onclick = addExpenseFromSlideOut;
            }
            hideExpenseSlideOut();
            await updatePeriodView();
            updateChart();
        }
        function capitalizeFirstLetter(str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
        }
        function handleExpenseDelete(element, e) {
            // Use the provided event or the global event
            const evt = e || window.event;

            // Stop propagation immediately to prevent any click events from bubbling
            if (evt) {
                evt.preventDefault();
                evt.stopPropagation();
            }


            // Find the parent swipe-container and get its data attributes
            const container = element.closest('.swipe-container');
            if (!container) {
                console.error('Could not find parent swipe container');
                return;
            }

            // Get expense data from the container
            const date = container.dataset.date;
            const timestamp = container.dataset.timestamp;


            if (!date || !timestamp) {
                console.error('Missing date or timestamp for expense deletion');
                return;
            }

            // Add visual feedback - mark container as deleting
            container.classList.add('deleting');

            // Call deleteExpense with the data after a short delay to allow animation
            setTimeout(() => {
                deleteExpense(date, timestamp);
            }, 10); // Short timeout to ensure animation starts
        }

        function handleBalanceDelete(element, e) {
            // Use the provided event or the global event
            const evt = e || window.event;

            // Stop propagation immediately to prevent any click events from bubbling
            if (evt) {
                evt.preventDefault();
                evt.stopPropagation();
            }


            // Find the parent swipe-container and get its data attributes
            const container = element.closest('.swipe-container');
            if (!container) {
                console.error('Could not find parent swipe container');
                return;
            }

            // Get balance data from the container
            const accountId = container.dataset.accountId;
            const date = container.dataset.date;


            if (!accountId || !date) {
                console.error('Missing accountId or date for balance deletion');
                return;
            }

            // Add visual feedback - mark container as deleting
            container.classList.add('deleting');

            // Call deleteBalance with the data
            setTimeout(() => {
                deleteBalance(accountId, date);
            }, 10); // Short timeout to ensure animation starts
        }


    </script>

    <!-- Global Loading Bar -->
    <div id="globalSpinner" class="global-loading-bar">
        <div class="loading-bar-track">
            <div class="loading-bar-fill"></div>
        </div>
    </div>

    </body>
</html>