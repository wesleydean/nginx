<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <!-- Content Security Policy for local development -->
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' https://balanced-shiner-88.clerk.accounts.dev https://clerk.com https://*.clerk.com https://clerk-telemetry.com https://*.clerk-telemetry.com https://api.stripe.com https://*.js.stripe.com https://js.stripe.com https://maps.googleapis.com https://*.sentry-cdn.com https://*.sentry.io https://challenges.cloudflare.com https://cdn.jsdelivr.net https://cdnjs.cloudflare.com https://unpkg.com https://www.gstatic.com https://cdn.plaid.com http://localhost:5000 http://127.0.0.1:5000 https://plaid-api-production.up.railway.app; connect-src 'self' https://balanced-shiner-88.clerk.accounts.dev https://clerk.com https://*.clerk.com https://clerk-telemetry.com https://*.clerk-telemetry.com https://api.stripe.com https://*.js.stripe.com https://js.stripe.com https://maps.googleapis.com https://*.sentry-cdn.com https://*.sentry.io https://challenges.cloudflare.com https://cdn.jsdelivr.net https://cdnjs.cloudflare.com https://unpkg.com https://www.gstatic.com https://cdn.plaid.com http://localhost:5000 http://127.0.0.1:5000 https://plaid-api-production.up.railway.app; worker-src 'self' blob:;">
    <title>Expense Tracker</title>
    
    <!-- Web App Manifest -->
    <link rel="manifest" href="manifest.json">
    
    <!-- iOS specific meta tags -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Expenses">
    
    <!-- Capacitor and haptic feedback support -->
    <script src="capacitor.js"></script>
    <script src="haptics.js"></script>
    <script src="haptic-debug.js"></script>
    <!-- Add this in the head section -->
    <script src="https://cdn.plaid.com/link/v2/stable/link-initialize.js"></script>
    <script src="js/plaid-service.js"></script>
    
    <!-- iOS icons -->
    <link rel="apple-touch-icon" href="icons/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="152x152" href="icons/icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="icons/apple-touch-icon.png">
    <link rel="apple-touch-icon" sizes="167x167" href="icons/icon-167x167.png">
    
    <!-- iOS splash screens -->
    <link rel="apple-touch-startup-image" href="icons/apple-splash-2048-2732.png" media="(device-width: 1024px) and (device-height: 1366px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="icons/apple-splash-1668-2388.png" media="(device-width: 834px) and (device-height: 1194px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="icons/apple-splash-1536-2048.png" media="(device-width: 768px) and (device-height: 1024px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="icons/apple-splash-1125-2436.png" media="(device-width: 375px) and (device-height: 812px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="icons/apple-splash-1242-2688.png" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="icons/apple-splash-828-1792.png" media="(device-width: 414px) and (device-height: 896px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="icons/apple-splash-1242-2208.png" media="(device-width: 414px) and (device-height: 736px) and (-webkit-device-pixel-ratio: 3) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="icons/apple-splash-750-1334.png" media="(device-width: 375px) and (device-height: 667px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
    <link rel="apple-touch-startup-image" href="icons/apple-splash-640-1136.png" media="(device-width: 320px) and (device-height: 568px) and (-webkit-device-pixel-ratio: 2) and (orientation: portrait)">
    
    <!-- Theme color for browser chrome -->
    <meta name="theme-color" content="#3b82f6">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <!-- Lucide Icons -->
    <script src="https://unpkg.com/lucide@latest/dist/umd/lucide.js"></script>
    <!-- Firebase SDKs -->
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-firestore-compat.js"></script>
     <script
        async
        crossorigin="anonymous"
        data-clerk-publishable-key="pk_test_YmFsYW5jZWQtc2hpbmVyLTg4LmNsZXJrLmFjY291bnRzLmRldiQ" 
        src="https://balanced-shiner-88.clerk.accounts.dev/npm/@clerk/clerk-js@5/dist/clerk.browser.js"
        type="text/javascript">
    </script>
    <script>
        // Initialize Lucide icons when the DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            initializeLucideIcons();
            
            // Add additional retries with increasing delays
            setTimeout(initializeLucideIcons, 500);
            setTimeout(initializeLucideIcons, 1000);
        });
        
        function initializeLucideIcons() {
            if (window.lucide && typeof window.lucide.createIcons === 'function') {
                try {
                    window.lucide.createIcons();
                    console.log('Lucide icons initialized successfully');
                } catch (error) {
                    console.error('Error initializing Lucide icons:', error);
                }
            } else {
                console.warn('Lucide not loaded yet, retrying...');
                setTimeout(initializeLucideIcons, 100);
            }
        }
    </script>
    
    <style>
        
        #user-button {
            /* position: absolute; */
            z-index: 100;
            top: 15px;
            left: 15px;
        }
        /* shadcn/ui Design System */
        :root {
            /* Colors */
            --background: 0 0% 100%;
            --foreground: 222.2 84% 4.9%;
            --card: 0 0% 100%;
            --card-foreground: 222.2 84% 4.9%;
            --popover: 0 0% 100%;
            --popover-foreground: 222.2 84% 4.9%;
            --primary: 221.2 83.2% 53.3%;
            --primary-foreground: 210 40% 98%;
            --secondary: 210 40% 96%;
            --secondary-foreground: 222.2 84% 4.9%;
            --muted: 210 40% 96%;
            --muted-foreground: 215.4deg 24.61% 40.65%;
            --accent: 210 40% 96%;
            --accent-foreground: 222.2 84% 4.9%;
            --destructive: 0 84.2% 60.2%;
            --destructive-foreground: 210 40% 98%;
            --border: 214.3 31.8% 91.4%;
            --input: 214.3 31.8% 91.4%;
            --ring: 221.2 83.2% 53.3%;
            --radius: 0.5rem;
            
            /* Success & Warning */
            --success: 142.1 76.2% 36.3%;
            --success-foreground: 210 40% 98%;
            --warning: 47.9 95.8% 53.1%;
            --warning-foreground: 26 83.3% 14.1%;
        }
        
        /* Dark Mode */
        @media (prefers-color-scheme: dark) {
            :root {
                --background: 222.2 84% 4.9%;
                --foreground: 210 40% 98%;
                --card: 222.2 84% 4.9%;
                --card-foreground: 210 40% 98%;
                --primary: 217.2 91.2% 59.8%;
                --primary-foreground: 222.2 84% 4.9%;
                --secondary: 217.2 32.6% 17.5%;
                --secondary-foreground: 210 40% 98%;
                --muted: 217.2 32.6% 17.5%;
                --muted-foreground: 215 20.2% 65.1%;
                --accent: 217.2 32.6% 17.5%;
                --accent-foreground: 210 40% 98%;
                --destructive: 0 62.8% 30.6%;
                --destructive-foreground: 210 40% 98%;
                --border: 217.2 32.6% 17.5%;
                --input: 217.2 32.6% 17.5%;
                --ring: 224.3 76.3% 94.1%;
            }
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
            border-color: hsl(var(--border));
            /* Disable text selection and improve mobile touch behavior */
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            /* Optimize touch behavior for mobile */
            -webkit-touch-callout: none;
            -webkit-touch-action: manipulation;
            touch-action: manipulation;
        }
        
        /* Allow text selection for specific elements that need it */
        input, textarea, [contenteditable="true"], .selectable-text {
            -webkit-user-select: text;
            -moz-user-select: text;
            -ms-user-select: text;
            user-select: text;
        }
        
        /* Prevent text selection on buttons and interactive elements */
        button, .btn, .swipe-container, .expense-item, .balance-item, .card {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
            -webkit-touch-callout: none;
            -webkit-touch-action: manipulation;
            touch-action: manipulation;
        }
        
        /* Disable context menu on long press for mobile */
        * {
            -webkit-touch-callout: none;
        }
        
        /* Improve touch targets for mobile */
        .btn, button, .swipe-container, .expense-item, .balance-item {
            min-height: 44px; /* iOS recommended minimum touch target */
            min-width: 44px;
        }
        
        /* Ensure all form elements have minimum touch target size */
        input, select, textarea, .form-input, .date-input, .select-trigger, .date-picker-trigger, .datepicker-trigger {
            min-height: 44px; /* iOS recommended minimum touch target */
        }
        
        /* Disable hover effects on touch devices */
        @media (hover: none) and (pointer: coarse) {
            .btn:hover, button:hover, .swipe-action:hover {
                background-color: inherit;
            }
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: hsl(var(--background));
            color: hsl(var(--foreground));
            height: 100vh;
            overflow: hidden;
            font-feature-settings: "rlig" 1, "calt" 1;
        }
        
        /* Card Components */
        .stat-card, .home-section, .modern-balance-card {
            background-color: hsl(var(--card));
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
        }
        
        /* Account Section Headers */
        .account-section-header {
                font-size: 1.2rem;
                font-weight: 400;
                margin: 1.5rem 0 0.75rem 0.4rem;
                color: hsl(220, 13%, 28%);
        }

        /* New Accounts Layout - Match Cashflow Styling */
        .accounts-list {
            margin: 0 -1rem;
        }

        .account-group-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 1rem;
            margin-bottom: 0;
            background: hsl(0deg 0% 0% / 2%);
            font-weight: 600;
        }
        
        .account-group-title {
            font-size: 0.875rem;
            font-weight: 600;
            color: hsl(var(--foreground));
        }
        
        .account-group-total {
            font-size: 0.875rem;
            font-weight: 600;
            color: hsl(var(--foreground));
        }
        
        .account-item {
            display: flex;
            flex: 1;
            align-items: center;
            padding: 0.5rem;
            background-color: hsl(var(--card));
            border-bottom: 1px solid hsl(var(--border));
            transition: transform 0.12s, background-color 0.16s;
            cursor: pointer;
            gap: 0.75rem;
        }
        
        .account-item:active {
            transform: scale(0.98);
            background-color: hsl(var(--muted));
        }
        
        .account-icon {
            width: 40px;
            height: 40px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .account-info {
            flex: 1;
            display: flex;
            flex-direction: column;
        }
        
        .account-name {
            font-size: 1rem;
            font-weight: 500;
            color: hsl(var(--foreground));
            margin-bottom: 0.125rem;
        }
        
        .account-balance {
            font-size: 1rem;
            color: hsl(var(--foreground));
            text-align: right;
        }
        

        .date-group-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 1rem;
            margin: 0;
            background: hsl(0deg 0% 0% / 2%);
            font-weight: 600;
            position: sticky;
            top: 86px; /* Account for fixed header height */
            z-index: 10;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
        }

        .transaction-item {
            display: flex;
            flex: 1;
            align-items: center;
            padding: 0.6rem 1rem;
            background-color: hsl(var(--card));
            border: 1px solid hsl(var(--border));
            border-radius: 0;
            transition: transform 0.12s, background-color 0.16s;
            cursor: pointer;
            gap: 0.75rem;
        }

        .transaction-item:active {
            transform: scale(0.98);
            background-color: hsl(var(--muted));
        }

        .transaction-icon {
            width: 32px;
            height: 32px;
            border-radius: 6px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: hsl(var(--muted) / 0.3);
            color: hsl(var(--muted-foreground));
        }

        .transaction-info {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .transaction-description {
            display: flex;
            font-weight: 500;
            color: hsl(var(--foreground));
            margin-bottom: 0.1rem;
            font-size: 0.875rem;
            align-items: center;
            gap: 0.5rem;
            line-height: 1.4;
        }

        .transaction-category {
            font-size: 0.75rem;
            color: hsl(var(--muted-foreground));
        }

        .transaction-amount {
            font-size: 0.875rem;
            font-weight: 600;
            text-align: right;
        }

        /* Account Type Chart - Match cashflow chart style */
        .investment-visual {
            background: linear-gradient(to bottom, #f59e0b73, #ffffff00);
            border: 2px solid #f59e0b;
            border-bottom: 0;
        }
        
        .cash-visual {
            background: linear-gradient(to bottom, #06b6d473, #ffffff00);
            border: 2px solid #06b6d4;
            border-bottom: 0;
        }
        
        .debt-visual {
            background: linear-gradient(to bottom, #ef444473, #ffffff00);
            border: 2px solid #ef4444;
            border-bottom: 0;
        }

        .stat-card, .home-section, .account-type-section, .modern-balance-card {
            background-color: hsl(var(--card));
        }
        /* Button Components */
        .btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            white-space: nowrap;
            border-radius: var(--radius);
            font-size: 0.875rem;
            font-weight: 500;
            transition: all 150ms ease;
            cursor: pointer;
            user-select: none;
            border: 1px solid transparent;
            position: relative;
            overflow: hidden;
            text-decoration: none;
        }
        
        .btn:disabled {
            pointer-events: none;
            opacity: 0.5;
        }
        
        .btn:focus-visible {
            outline: 2px solid hsl(var(--ring));
            outline-offset: 2px;
        }
        
        .btn-primary {
            background-color: hsl(var(--primary));
            color: hsl(var(--primary-foreground));
        }
        
        .btn-primary:hover {
            background-color: hsl(var(--primary) / 0.9);
        }
        
        .btn-secondary {
            background-color: hsl(var(--secondary));
            color: hsl(var(--secondary-foreground));
        }
        
        .btn-secondary:hover {
            background-color: hsl(var(--secondary) / 0.8);
        }
        
        .btn-outline {
            border: 1px solid hsl(var(--border));
            background-color: hsl(var(--background));
            color: hsl(var(--foreground));
        }
        
        .btn-outline:hover {
            background-color: hsl(var(--accent));
            color: hsl(var(--accent-foreground));
        }
        
        .btn-ghost {
            background-color: transparent;
            color: hsl(var(--foreground));
        }
        
        .btn-ghost:hover {
            background-color: hsl(var(--accent));
            color: hsl(var(--accent-foreground));
        }
        
        .btn-destructive {
            background-color: hsl(var(--destructive));
            color: hsl(var(--destructive-foreground));
        }
        
        .btn-destructive:hover {
            background-color: hsl(var(--destructive) / 0.9);
        }
        
        /* Button Sizes */
        .btn-sm {
            height: 2rem;
            padding: 0 0.75rem;
            font-size: 0.8rem;
        }
        
        .btn-xs {
            height: 1.5rem;
            padding: 0.8rem;
            min-height: 0;
        }
        
        .btn-md {
            height: 2.5rem;
            padding: 0 1rem;
        }
        
        .btn-lg {
            height: 2.75rem;
            padding: 0 2rem;
        }
        
        .btn-icon {
            height: 2.5rem;
            width: 2.5rem;
            padding: 0;
        }
        
        /* Card Components */
        .card {
            color: hsl(var(--card-foreground));
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
            padding: .2rem;
        }
        
        /* Today view: remove borders and shadows from main cards */
        .today-view .card {
            border: none;
            box-shadow: none;
            background-color: transparent;
        }
        
        /* Keep borders for specific cards in today view that need them */
        .today-view .expense-item {
            border: 1px solid hsl(var(--border));
            box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
        }
        
        .today-view .balance-item {
            border: 1px solid hsl(var(--border));
            box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
        }
        
        /* Month view: remove borders and shadows from main cards */
        
       
        
        .expense-item:active {
            transform: scale(0.98);
            background-color: hsl(var(--muted));
        }
        
        .balance-item {
            border: 1px solid hsl(var(--border));
            box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
        }
        

        .swipe-container {
            position: relative;
            border-radius: 0;
            background-color: hsl(var(--background)); /* Changed from destructive to background */
            position: relative;
            overflow: hidden;
            width: 100%;
            border-radius: 0;
            /* margin-bottom: 8px; */
            touch-action: pan-y; /* Change to pan-y to enable horizontal swiping */
            user-select: none;
            -webkit-user-select: none;
            -webkit-touch-callout: none;
            overflow: hidden;
        }
       
         .swipe-action {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            background: hsl(260deg 54.55% 69.74%);
            color: hsl(var(--destructive-foreground));
            width: 80px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            font-weight: bold;
            cursor: pointer;
            z-index: 1;
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            align-items: center;
            justify-content: center;
            font-size: 1.5rem;
            font-weight: bold;
            cursor: pointer;
            z-index: 0;
            -webkit-tap-highlight-color: rgba(255,255,255,0.3);
            touch-action: manipulation;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            z-index: 0; /* Higher z-index to ensure it's above other elements */
            cursor: pointer;
            -webkit-tap-highlight-color: transparent;
            touch-action: none; /* Disable browser handling of all panning and zooming gestures */
        }
        
        .swipe-action:hover {
            background-color: hsl(var(--destructive) / 0.9);
        }
        
        .swipe-container.swiped .swipe-content {
            transform: translateX(-80px);
            border-right: none;
            border-top-right-radius: 0;
            border-bottom-right-radius: 0;
        }
        
        /* Ensure swipe container maintains background even when swiped */
        .swipe-container.swiped {
            background-color: hsl(var(--background));
        }
        
        .swipe-container.deleting {
            animation: fade-out 0.45s cubic-bezier(0.4, 0, 0.2, 1) forwards;
            pointer-events: none;
            overflow: hidden;
        }
        
        .swipe-container.deleting .swipe-content {
            opacity: 0;
            transition: opacity 0.45s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        @keyframes fade-out {
            0% {
                height: auto;
                margin-bottom: 0.5rem;
                opacity: 1;
            }
            70% {
                height: auto;
                margin-bottom: 0.5rem;
                opacity: 0;
            }
            100% {
                height: 0;
                margin-bottom: 0;
                opacity: 0;
            }
        }
        
        /* Hide original delete buttons when swipe is enabled */
        .swipe-container .delete-btn,
        .swipe-container .delete-balance-btn {
            display: none;
        }
        
        /* Items inside swipe containers should fill the container completely */
        .swipe-container .expense-item {
            border: none;
            box-shadow: none;
            background-color: hsl(var(--card));
            width: 100%;
            margin: 0;
            height: 100%;
            border-radius: 0; /* This matches parent container's radius */
            display: flex;
            align-items: center;
        }
        
        .swipe-container .balance-item {
            border: none;
            box-shadow: none;
            background-color: hsl(var(--card));
            width: 100%;
            margin: 0;
            height: 100%;
            border-radius: var(--radius); /* This matches parent container's radius */
            display: flex;
            align-items: center;
        }
        
        /* Keep borders for slide-out content and modals */
        .slide-out-content .card,
        .modal-content .card,
        .account-management-content .card {
            border: 1px solid hsl(var(--border));
            box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1);
            background-color: hsl(var(--card));
        }
        
        /* Give stat cards a subtle background for better visual separation */
        .stat-card {
            background-color: hsl(var(--muted) / 0.3);
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            text-align: left;
            align-items: flex-start;
            padding: 1rem;
        }
        .stat-card > div {
            text-align: left;
            margin-left: 0 !important;
            padding-left: 0 !important;
        }
        .stat-card .text-sm,
        .stat-card .text-2xl,
        .stat-card .stat-label,
        .stat-card .stat-value {
            text-align: left;
            margin-left: 0 !important;
            padding-left: 0 !important;
        }
        
        .card-header {
            position: sticky;
            display: flex;
            flex-direction: row;
            align-items: center;
        }
        
        .card-title {
            font-size: 1.5rem;
            font-weight: 600;
            line-height: 1.2;
            margin: 0;
            color: hsl(var(--foreground));
        }
        
        .card-description {
            font-size: 0.875rem;
            color: hsl(var(--muted-foreground));
            margin-top: 0.375rem;
        }
        
        .card-content {
            padding: 0;
        }
        
        /* Income/Spending Bar Chart Layout */

        #budgetDisplay {
            overflow: hidden;
            margin-bottom: 0;
        }

        #budgetDisplay .card-content {
            padding: 0;
        }
        
        .income-spending-chart {
            display: flex;
            align-items: end;
            justify-content: center;
            gap: 1.5rem;
            padding: 2rem 1rem 1rem 1rem;
            height: 140px;
            position: relative;
        }
        
        .monthly-spending-chart {
            display: flex;
            align-items: end;
            gap: 0.5rem;
            padding: 2rem 1rem 0.5rem 1rem;
            height: 140px;
            position: relative;
            overflow-x: auto;
            scroll-behavior: smooth;
            -webkit-overflow-scrolling: touch;
        }
        
        .monthly-spending-chart .chart-bar {
            min-width: 40px;
            max-width: 40px;
            flex-shrink: 0;
            cursor: pointer;
            transition: opacity 0.2s ease;
        }
        
        .monthly-spending-chart .chart-bar:hover {
            opacity: 0.8;
        }
        
        .monthly-spending-chart .chart-bar.selected .bar-visual {
            border-width: 2px !important;
            background: linear-gradient(to bottom, rgba(234, 88, 12, 1) 0%, rgba(234, 88, 12, 0.6) 100%) !important;
            opacity: 1 !important;
        }
        
        /* Push button effect for chart bars */
        .monthly-spending-chart .chart-bar .bar-visual {
            transition: transform 0.1s ease, box-shadow 0.1s ease;
        }
        
        .monthly-spending-chart .chart-bar .bar-visual:active {
            transform: scale(0.95);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .monthly-spending-chart .chart-bar.current-month .bar-visual {
            background: #e7743c3d;
        }
        
        .monthly-spending-chart .chart-bar:not(.current-month):not(.selected) .bar-visual {
            opacity: 0.7;
        }
        
        /* Fade out non-selected bars when one is selected */
        .monthly-spending-chart.has-selection .chart-bar:not(.selected) {
            opacity: 0.3;
            transition: opacity 0.3s ease;
        }
        
        .monthly-spending-chart.has-selection .chart-bar.selected {
            opacity: 1;
            transition: opacity 0.3s ease;
        }
        
        .monthly-spending-chart .bar-visual {
            border: 1px solid #ea580c;
            background: linear-gradient(to bottom, rgba(234, 88, 12, 0.8) 0%, rgba(234, 88, 12, 0.4) 100%);
            border-radius: 4px;
        }
        
        .selected-month-total {
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            align-items: center;
            font-size: 1.1rem;
            font-weight: 600;
            color: hsl(var(--foreground));
            margin-top: 0.6rem;
            margin-bottom: 0.5rem;
        }
        
        .selected-month-total .month-name {
            flex: 1;
            text-align: left;
            font-weight: 400;
            font-size: 1rem;
        }
        
        .selected-month-total .month-amount {
            flex: 1;
            text-align: right;
            font-variant-numeric: tabular-nums;
            color: #ce5a2a;
            font-size: 1.3rem;
        }
        
        .chart-carousel-container {
            position: relative;
            width: 100%;
            overflow: hidden;
        }
        
        .chart-carousel {
            display: flex;
            width: 200%;
            transition: transform 0.3s ease;
            overflow: hidden;
            margin-bottom: 0 !important;
        }
        
        .chart-fade-transition {
            opacity: 0.7;
            transition: opacity 0.2s ease;
        }
        
        .chart-fade-in {
            opacity: 1 !important;
        }
        
        .chart-fade-slide-in {
            animation: slideInFromLeft 0.3s ease-out forwards;
        }
        
        .chart-fade-slide-out {
            animation: slideOutToRight 0.3s ease-out forwards;
        }
        
        @keyframes slideInFromLeft {
            0% {
                opacity: 0;
                transform: translateX(-20px);
            }
            100% {
                opacity: 1;
                transform: translateX(0);
            }
        }
        
        @keyframes slideOutToRight {
            0% {
                opacity: 1;
                transform: translateX(0);
            }
            100% {
                opacity: 0;
                transform: translateX(20px);
            }
        }
        
        .chart-bar-stagger-in {
            opacity: 0;
            animation: barFadeInStagger 0.3s ease-out forwards;
        }
        
        @keyframes barFadeInStagger {
            0% {
                opacity: 0;
            }
            100% {
                opacity: 1;
            }
        }
        
        .chart-slide {
            width: 50%;
            flex-shrink: 0;
        }
        
        .chart-slide.active {
            /* No specific styling needed, position handled by transform */
        }
        
        .chart-dots {
            display: flex;
            justify-content: center;
            gap: 6px;
            padding: 0.5rem;
        }
        
        .chart-dots .dot {
            width: 6px;
            height: 6px;
            border-radius: 50%;
            background-color: #9ca3af;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        
        .chart-dots .dot.active {
            background-color: #374151;
        }
        
        .chart-dots .dot:hover {
            opacity: 0.8;
        }
        
        .category-spending-chart {
            display: flex;
            align-items: end;
            gap: 0.5rem;
            min-height: 140px;
            position: relative;
            justify-content: center;
        }
        
        .category-spending-chart .chart-bar {
            min-width: 40px;
            max-width: 40px;
            flex-shrink: 0;
            cursor: pointer;
            transition: opacity 0.2s ease;
        }
        
        /* Fade out non-selected bars when one is selected */
        .category-spending-chart.has-selection .chart-bar:not(.selected) {
            opacity: 0.3;
            transition: opacity 0.3s ease;
        }
        
        .category-spending-chart.has-selection .chart-bar.selected {
            opacity: 1;
            transition: opacity 0.3s ease;
        }
        
        /* Push button effect for category chart bars */
        .category-spending-chart .chart-bar .bar-visual {
            transition: transform 0.1s ease, box-shadow 0.1s ease;
        }
        
        .category-spending-chart .chart-bar .bar-visual:active {
            transform: scale(0.95);
            box-shadow: inset 0 2px 4px rgba(0, 0, 0, 0.2);
        }
        
        .chart-bar {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            flex: 1;
            max-width: 40%;
            position: relative;
            /* height: 100px; */
        }
        
        .bar-amount {
            font-weight: 500;
            text-align: center;
            font-size: 0.7rem;
            text-transform: uppercase;
        }

        .bar-amount span,
        .bar-amount-icon {
            font-size: 1.1rem;
        }
        
        .bar-visual {
            width: 100%;
            border-radius: 4px;
            transition: height 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            min-height: 24px;
            height: 0px;
            /* position: absolute; */
            /* bottom: 0;
            left: 0; */
        }
        
        /* Category bar colors */
        .category-visual.food { 
            background: linear-gradient(to bottom, #f59e0bCC 0%, #f59e0b66 100%); 
            border: 1px solid #f59e0b; 
        }
        .category-visual.transportation { 
            background: linear-gradient(to bottom, #3b82f6CC 0%, #3b82f666 100%); 
            border: 1px solid #3b82f6; 
        }
        .category-visual.entertainment { 
            background: linear-gradient(to bottom, #8b5cf6CC 0%, #8b5cf666 100%); 
            border: 1px solid #8b5cf6; 
        }
        .category-visual.shopping { 
            background: linear-gradient(to bottom, #ef4444CC 0%, #ef444466 100%); 
            border: 1px solid #ef4444; 
        }
        .category-visual.health { 
            background: linear-gradient(to bottom, #10b981CC 0%, #10b98166 100%); 
            border: 1px solid #10b981; 
        }
        .category-visual.utilities { 
            background: linear-gradient(to bottom, #f97316CC 0%, #f9731666 100%); 
            border: 1px solid #f97316; 
        }
        .category-visual.other { 
            background: linear-gradient(to bottom, #6b7280CC 0%, #6b728066 100%); 
            border: 1px solid #6b7280; 
        }
        
        .income-visual {
            background: linear-gradient(to bottom, #cb82f273, #ffffff00);
            border: 2px solid #853dc7;
            border-bottom: 0;
        }
        
        .spending-visual {
            background: linear-gradient(to bottom, #ff6a2461, #ffffff00);
            border: 2px solid #ff7474;
            border-bottom: 0;  
        }
        
        .current-month .spending-visual {
            border-style: dashed;
        }
        
        /* Horizontal Account Type Chart */
        .account-type-horizontal {
            display: flex;
            flex-direction: column;
            gap: 0.4rem;
        }
        
        .account-type-bar {
            display: flex;
            flex-direction: column;
        }
        
        .account-type-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        
        .account-type-left {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .account-type-label {
            font-size: 1rem;
            font-weight: 500;
            color: hsl(var(--foreground));
        }
        
        .account-type-amount {
            font-size: 1rem;
            font-weight: 600;
            color: hsl(var(--foreground));
        }
        
        .account-type-bar-row {
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }
        
        .account-type-icon {
            height: 32px;
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            color: hsl(var(--foreground));
            flex-shrink: 0;
        }
        
        .account-type-bar-container {
            position: relative;
            height: 35px;
            background: hsl(var(--muted));
            border-radius: 4px;
            overflow: hidden;
            flex: 1;
            display: flex;
            align-items: center;
        }
        
        .account-type-bar-visual {
            display: flex;
            align-items: center;
            height: 100%;
            border-radius: 4px 1rem 0rem 4px;
            position: relative;
            transition: all 0.3s ease;
            min-height: 30px;
        }
        
        .account-type-bar-visual.investments,
        .account-type-bar-visual.investment {
            background: linear-gradient(to right, #f59e0b66 0%, #f59e0bCC 100%);
            border: 1px solid #f59e0b;
        }
        
        .account-type-bar-visual.cash {
            background: linear-gradient(to right, #10b98166 0%, #10b981CC 100%);
            border: 1px solid #10b981;
        }
        
        .account-type-bar-visual.debt,
        .account-type-bar-visual.liability {
            background: linear-gradient(to left, #ef444466 0%, #ef4444CC 100%);
            border: 1px solid #ef4444;
            margin-left: auto;
            margin-right: 0;
            border-radius: 1rem 4px 4px 4px;
        }
        
        .account-type-percentage {
            color: white;
            font-size: 0.75rem;
            font-weight: 600;
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.5);
            margin-left: 10px;
        }
        
        #budgetDisplay .stat-card {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            margin-bottom: 0;
            position: relative;
            min-height: 120px;
            height: auto;
        }

        /* Change indicator styling */
        .change-indicator {
            display: flex;
            align-items: center;
            gap: 4px;
            font-size: 0.875rem;
            font-weight: 500;
            margin-top: 4px;
        }
        
        .change-arrow {
            font-size: 1rem;
        }
        
        .spending-card .change-indicator {
            color: #ef4444; /* red for spending */
        }
        
        .remaining-card .change-indicator {
            color: #5fa42e; /* green for remaining/positive */
        }
        
        .remaining-card .change-indicator.over-budget {
            color: #ef4444; /* red when over budget */
        }
        
        /* Side-by-side squares layout for save screen */
        #saveTargetDisplay .card-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            padding: 0;
        }
        
        #saveTargetDisplay .stat-card {
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            margin-bottom: 0;
            position: relative;
            min-height: 120px;
            height: auto;
        }
        
        /* Save screen change indicators */
        .saving-target-card .change-indicator {
            color: #3b82f6; /* blue for target */
        }
        
        .save-progress-card .change-indicator {
            color: #5fa42e; /* green for progress */
        }
        
        .save-progress-card .change-indicator.behind-target {
            color: #ef4444; /* red when behind target */
        }
        
        /* Home Screen Styles */
        .home-section {
            margin-bottom: 1.5rem;
            cursor: pointer;
            position: relative;
            background-color: hsl(var(--card)) !important;
            border: 2px solid hsl(var(--border) / 0.5) !important;
            border-radius: 12px;
            box-shadow: none !important;
            padding: 1rem;
        }
        
        .home-section .card-header {
            display: flex;
            flex-direction: row;
            justify-content: space-between;
            align-items: flex-start;
            gap: 0.5rem;
            text-align: left;
            position: relative;
            width: 100%;
            /* border-bottom: 1px solid #e9e9e9; */
            padding-bottom: 0.6rem;
        }
        
        .home-section .card-header > .home-section-header {
            flex: 1;
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
            align-items: flex-start;
            text-align: left;
        }
        
        .home-section-header {
            display: flex;
            align-items: flex-start;
            justify-content: space-between;
            gap: 1rem;
            cursor: pointer;
            width: 100%;
        }
        
        .section-header-left {
            display: flex;
            flex-direction: column;
            gap: 0.15rem;
            align-items: flex-start;
            text-align: left;
            flex: 1;
        }
        
        .section-header-right {
            display: flex;
            align-items: flex-start;
            justify-content: flex-end;
            flex-shrink: 0;
        }
        
        /* Account Balance Summary in Net Worth Section */
        .account-balance-summary {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-top: 0.5rem;
            font-size: 0.875rem;
        }
        
        .balance-label {
            color: hsl(var(--muted-foreground));
            font-weight: 500;
        }
        
        .balance-amount {
            color: hsl(var(--foreground));
            font-weight: 600;
        }
        
        .manage-accounts-btn {
            background: hsl(var(--secondary));
            color: hsl(var(--secondary-foreground));
            border: none;
            padding: 0.25rem 0.75rem;
            border-radius: 12px;
            font-size: 0.75rem;
            font-weight: 500;
            cursor: pointer;
            transition: background-color 0.2s ease;
        }
        
        .manage-accounts-btn:hover {
            background: hsl(var(--secondary) / 0.8);
        }
        
        /* Account Balance Display Layout */
        .balance-header-section {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
        }
        
        .balance-left-stack {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
            align-items: flex-start;
        }
        
        .balance-info-group {
            display: flex;
            flex-direction: column;
            gap: 0;
        }
        
        .balance-section-title {
            font-size: 1rem;
            font-weight: 600;
            margin: 0;
            color: hsl(var(--foreground));
        }
        
        .section-title {
            font-size: 1.2rem;
            font-weight: 400;
            margin: 0;
            color: hsl(220, 13%, 28%);
        }
        
        /* Transactions title on cashflow page - match other section headers */
        #expensesListTitle {
            font-size: 1.2rem !important;
            font-weight: 400 !important;
            color: hsl(220, 13%, 28%) !important;
        }
        
        /* Card header styling handled by home-section class */
        
        .section-subtitle {
            color: hsl(var(--muted-foreground));
            font-size: 0.875rem;
            display: flex;
            align-items: center;
            gap: 0.25rem;
            margin: 0;
        }
        
        .cashflow-menu-container {
            position: relative;
            z-index: 100;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .dot-menu-btn {
            background: none;
            border: none;
            padding: 0.5rem;
            border-radius: 0.5rem;
            cursor: pointer;
            color: hsl(var(--muted-foreground));
            transition: color 0.2s ease, background-color 0.2s ease;
        }
        
        .dot-menu-btn:hover {
            color: hsl(var(--foreground));
            background-color: hsl(var(--muted));
        }

        .connect-account-btn {
            margin: 1rem;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            padding: 16px 20px;
            background: transparent;
            border: 2px dashed #c8a03d;
            border-radius: 12px;
            color: #8b6914;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 16px;
            font-weight: 500;
        }

        .connect-account-btn:hover,
        .connect-account-btn:active {
            background-color: #c8a03d0a;
            border-color: #8b6914;
            border-style: solid;
        }

        .account-buttons-container .connect-account-btn [data-lucide] {
            color: #685012;
        }

        .add-balance-btn {
            margin: 1rem;
            display: flex;
            justify-content: center;
            align-items: center;
            gap: 8px;
            padding: 16px 20px;
            background: transparent;
            border: 2px dashed #c8a03d;
            border-radius: 12px;
            color: #8b6914;
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 16px;
            font-weight: 500;
        }

        .add-balance-btn:hover,
        .add-balance-btn:active {
            background-color: #c8a03d0a;
            border-color: #8b6914;
            border-style: solid;
        }

        .account-buttons-container .add-balance-btn [data-lucide] {
            color: #8a6c20;
        }

        .account-buttons-container {
            display: flex;
            flex-direction: row;
            gap: 0;
        }

        .account-buttons-container .connect-account-btn,
        .account-buttons-container .add-balance-btn {
            margin: 0.5rem;
            flex: 1;
        }

        /* Hide the original quick action add balance button */
        #saveBalanceActionCard {
            display: none !important;
        }
        
        .dropdown-menu {
            position: absolute;
            top: calc(100% + 0.25rem) !important;
            left: 0;
            max-height: 80vh;
            overflow-y: auto;
            background: hsl(var(--background));
            border: 1px solid hsl(var(--border));
            border-radius: 0.5rem;
            box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
            min-width: 220px;
            z-index: 100;
            display: none;
            margin-top: 0.25rem;
            pointer-events: auto;
            transform: none !important;
        }
        
        .dropdown-menu.show {
            display: block;
            position: absolute !important;
        }

        .dropdown-menu.dropdown-right {
            right: 0 !important;
            left: auto !important;
        }

        .dropdown-menu.dropdown-left {
            left: 0 !important;
            right: auto !important;
        }
        
        .time-range-selector {
            background: transparent;
            border: 1px solid hsl(var(--border));
            border-radius: 1rem;
            display: inline-flex;
            align-items: center;
            justify-content: flex-start;
            cursor: pointer;
            font-size: 1rem;
            color: hsl(var(--muted-foreground));
            padding: 9px 12px;
            height: 38px;
            box-sizing: border-box;
            outline: none;
            width: auto;
        }
        
        .time-range-selector-icon:hover {
            background-color: hsl(var(--muted));
        }
        
        .dropdown-header {
            padding: 0.75rem 1rem 0.5rem;
            font-size: 0.75rem;
            font-weight: 500;
            color: hsl(var(--muted-foreground));
            text-transform: uppercase;
            letter-spacing: 0.025em;
        }
        
        .dropdown-item {
            padding: 0.75rem 1rem;
            cursor: pointer;
            font-size: 0.875rem;
            transition: background-color 0.2s ease;
            border-left: 3px solid transparent;
        }
        
        .dropdown-item:hover {
            background-color: hsl(var(--muted));
        }
        
        .dropdown-item.active {
            background-color: transparent;
            border-left-color: transparent;
            color: hsl(var(--foreground));
            font-weight: 700;
            text-decoration: underline;
        }
        
        .dropdown-item:first-of-type {
            border-top-left-radius: 0.5rem;
            border-top-right-radius: 0.5rem;
        }
        
        .dropdown-item:last-of-type {
            border-bottom-left-radius: 0.5rem;
            border-bottom-right-radius: 0.5rem;
        }
        
        .range-picker {
            display: flex;
            gap: 0.5rem;
            margin: 0;
            width: 100%;
        }
        
        .range-btn {
            padding: 0.25rem 0.75rem;
            background: hsl(var(--muted));
            border: none;
            border-radius: 0.375rem;
            color: hsl(var(--muted-foreground));
            cursor: pointer;
            transition: all 0.2s;
            font-size: 0.875rem;
        }
        
        .range-btn.active {
            background: hsl(var(--primary));
            color: hsl(var(--primary-foreground));
        }
        
        .range-btn:hover:not(.active) {
            background: hsl(var(--muted) / 0.8);
        }
        
        #homeTransactionsList {
            padding: 0;
        }
        
        .home-transaction-item {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            padding: 0.7rem 0;
            border-bottom: 1px solid hsl(var(--border));
        }
        
        .home-transaction-item:last-child {
            border-bottom: none;
        }
        
     
        
        .transaction-date {
            color: hsl(var(--muted-foreground));
            font-size: 0.75rem;
            margin-left: 1.5rem; /* Align with description text, accounting for icon + gap */
        }
        
        .transaction-amount {
            font-weight: 600;
            color: hsl(var(--foreground));
            font-size: 0.875rem;
            white-space: nowrap;
        }
        
        /* Chart Legend */
        .chart-legend {
            display: flex;
            justify-content: center;
            gap: 1.5rem;
            margin: 1rem 0 0.5rem 0;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .legend-color {
            width: 16px;
            height: 3px;
            border-radius: 2px;
        }
        
        .legend-label {
            font-size: 0.875rem;
            color: hsl(var(--muted-foreground));
            font-weight: 500;
        }
        
        /* Form Components */
        .form-group {
            display: flex;
            flex-direction: column;
            margin-bottom: 0.75rem; /* consistent spacing */
        }
        
        .form-label {
            font-size: 0.875rem;
            font-weight: 500;
            color: hsl(var(--foreground));
            margin-bottom: 0.5rem;
        }
        
        .form-input {
            display: flex;
            height: 2.5rem;
            min-height: 44px; /* iOS recommended minimum touch target */
            width: 100%;
            border-radius: var(--radius);
            border: 1px solid hsl(var(--border));
            background-color: hsl(var(--background));
            padding: 0.5rem 0.75rem;
            font-size: 0.875rem;
            transition: all 150ms ease;
            color: hsl(var(--foreground));
        }
        
        .form-input:focus {
            outline: 2px solid hsl(var(--ring));
            outline-offset: 2px;
            border-color: hsl(var(--ring));
        }
        
        .form-input[rows] {
            resize: vertical;
            min-height: 120px;
        }
        
        .form-input:disabled {
            cursor: not-allowed;
            opacity: 0.5;
        }
        
        .form-input[readonly] {
            background-color: hsl(var(--muted));
            color: hsl(var(--muted-foreground));
            cursor: not-allowed;
        }
        
        .form-input::placeholder {
            color: hsl(var(--muted-foreground));
        }
        
        /* Custom Select Component */
        .select-container {
            position: relative;
        }
        
        .select-trigger {
            display: flex;
            height: 2.5rem;
            min-height: 44px; /* iOS recommended minimum touch target */
            width: 100%;
            align-items: center;
            justify-content: space-between;
            border-radius: var(--radius);
            border: 1px solid hsl(var(--border));
            background-color: hsl(var(--background));
            padding: 0.5rem 0.75rem;
            font-size: 0.875rem;
            color: hsl(var(--foreground));
            cursor: pointer;
            transition: all 150ms ease;
            user-select: none;
        }
        
        .select-trigger:hover {
            background-color: hsl(var(--accent));
        }
        
        .select-trigger:focus {
            outline: 2px solid hsl(var(--ring));
            outline-offset: 2px;
            border-color: hsl(var(--ring));
        }
        
        .select-trigger[aria-expanded="true"] {
            background-color: hsl(var(--accent));
            border-color: hsl(var(--ring));
        }
        
        .select-content {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            z-index: 50;
            background-color: hsl(var(--popover));
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            margin-top: 0.25rem;
            max-height: 200px;
            overflow-y: auto;
            opacity: 0;
            transform: translateY(-10px);
            transition: all 150ms ease;
            pointer-events: none;
        }
        
        .select-content.open {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }
        
        .select-item {
            padding: 0.5rem 0.75rem;
            font-size: 0.875rem;
            cursor: pointer;
            transition: all 150ms ease;
            color: hsl(var(--foreground));
        }
        
        .select-item:hover {
            background-color: hsl(var(--accent));
        }
        
        .select-item.selected {
            background-color: transparent;
            color: hsl(var(--foreground));
            font-weight: 700;
            text-decoration: underline;
        }
        
        .select-item:first-child {
            border-radius: var(--radius) var(--radius) 0 0;
        }
        
        .select-item:last-child {
            border-radius: 0 0 var(--radius) var(--radius);
        }
        
        /* Date Input Styling */
        .date-input {
            display: flex;
            height: 2.5rem;
            min-height: 44px; /* iOS recommended minimum touch target */
            width: 100%;
            border-radius: var(--radius);
            border: 1px solid hsl(var(--border));
            background-color: hsl(var(--background));
            padding: 0.5rem 0.75rem;
            font-size: 0.875rem;
            transition: all 150ms ease;
            color: hsl(var(--foreground));
            cursor: pointer;
        }
        
        .date-input:focus {
            outline: 2px solid hsl(var(--ring));
            outline-offset: 2px;
            border-color: hsl(var(--ring));
        }
        
        /* Hide native date picker styling */
        .date-input::-webkit-calendar-picker-indicator {
            background: transparent;
            bottom: 0;
            color: transparent;
            cursor: pointer;
            height: auto;
            left: 0;
            position: absolute;
            right: 0;
            top: 0;
            width: auto;
        }
        
        .date-input::-webkit-inner-spin-button,
        .date-input::-webkit-clear-button {
            display: none;
        }
        
        /* Custom Date Picker Styles */
        .date-picker-container {
            position: relative;
        }

        .date-picker-trigger {
            display: flex;
            height: 2.5rem;
            min-height: 44px; /* iOS recommended minimum touch target */
            width: 100%;
            align-items: center;
            justify-content: space-between;
            border-radius: var(--radius);
            border: 1px solid hsl(var(--border));
            background-color: hsl(var(--background));
            padding: 0.5rem 0.75rem;
            font-size: 0.875rem;
            color: hsl(var(--foreground));
            cursor: pointer;
            transition: all 150ms ease;
            user-select: none;
        }

        .date-picker-trigger:hover {
            background-color: hsl(var(--accent));
        }

        .date-picker-trigger:focus {
            outline: 2px solid hsl(var(--ring));
            outline-offset: 2px;
            border-color: hsl(var(--ring));
        }

        .date-picker-trigger[aria-expanded="true"] {
            background-color: hsl(var(--accent));
            border-color: hsl(var(--ring));
        }

        .date-picker-content {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            z-index: 50;
            background-color: hsl(var(--popover));
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            margin-top: 0.25rem;
            opacity: 0;
            transform: translateY(-10px);
            transition: all 150ms ease;
            pointer-events: none;
            padding: 1rem;
            min-width: 280px;
        }

        .date-picker-content.open {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }

        .date-picker-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }

        .date-picker-nav {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .date-picker-nav-btn {
            background-color: transparent;
            border: none;
            width: 2rem;
            height: 2rem;
            border-radius: var(--radius);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.875rem;
            color: hsl(var(--foreground));
            transition: all 150ms ease;
        }

        .date-picker-nav-btn:hover {
            background-color: hsl(var(--accent));
        }

        .date-picker-nav-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .date-picker-month-year {
            font-size: 0.875rem;
            font-weight: 500;
            color: hsl(var(--foreground));
            min-width: 120px;
            text-align: center;
        }

        .date-picker-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 0.125rem;
        }

        .date-picker-day-header {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 2rem;
            font-size: 0.75rem;
            font-weight: 500;
            color: hsl(var(--muted-foreground));
        }

        .date-picker-day {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 2rem;
            font-size: 0.875rem;
            cursor: pointer;
            border-radius: var(--radius);
            transition: all 150ms ease;
            color: hsl(var(--foreground));
            background-color: transparent;
            border: none;
        }

        .date-picker-day:hover {
            background-color: hsl(var(--accent));
        }

        .date-picker-day.today {
            background-color: hsl(var(--accent));
            font-weight: 600;
        }

        .date-picker-day.selected {
            background-color: hsl(var(--primary));
            color: hsl(var(--primary-foreground));
        }

        .date-picker-day.disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .date-picker-day.disabled:hover {
            background-color: transparent;
        }

        .date-picker-day.other-month {
            opacity: 0.5;
        }

        .date-picker-footer {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 1rem;
            padding-top: 1rem;
            border-top: 1px solid hsl(var(--border));
        }

        .date-picker-today-btn {
            background-color: hsl(var(--secondary));
            color: hsl(var(--secondary-foreground));
            border: none;
            padding: 0.375rem 0.75rem;
            border-radius: var(--radius);
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 150ms ease;
        }

        .date-picker-today-btn:hover {
            background-color: hsl(var(--secondary) / 0.8);
        }

        .date-picker-clear-btn {
            background-color: transparent;
            color: hsl(var(--muted-foreground));
            border: none;
            padding: 0.375rem 0.75rem;
            border-radius: var(--radius);
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 150ms ease;
        }

        .date-picker-clear-btn:hover {
            background-color: hsl(var(--accent));
            color: hsl(var(--foreground));
        }
        
        /* Period dropdown custom styling */
        .period-dropdown {
            display: none; /* Hide native select */
        }
        
        .period-select-container {
            position: relative;
            min-width: 120px;
        }
        
        .period-select-trigger {
            display: flex;
            height: 2rem;
            align-items: center;
            justify-content: space-between;
            border-radius: var(--radius);
            border: 1px solid hsl(var(--border));
            background-color: hsl(var(--background));
            padding: 0.375rem 0.75rem;
            font-size: 0.875rem;
            font-weight: 500;
            color: hsl(var(--foreground));
            cursor: pointer;
            transition: all 150ms ease;
            user-select: none;
            gap: 0.5rem;
        }
        
        .period-select-trigger:hover {
            background-color: hsl(var(--accent));
        }
        
        .period-select-trigger:focus {
            outline: 2px solid hsl(var(--ring));
            outline-offset: 2px;
            border-color: hsl(var(--ring));
        }
        
        .period-select-content {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            z-index: 50;
            background-color: hsl(var(--popover));
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
            margin-top: 0.25rem;
            max-height: 200px;
            overflow-y: auto;
            opacity: 0;
            transform: translateY(-10px);
            transition: all 150ms ease;
            pointer-events: none;
        }
        
        .period-select-content.open {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }
        
        .period-select-item {
            padding: 0.5rem 0.75rem;
            font-size: 0.875rem;
            cursor: pointer;
            transition: all 150ms ease;
            color: hsl(var(--foreground));
        }
        
        .period-select-item:hover {
            background-color: hsl(var(--accent));
        }
        
        .period-select-item.selected {
            background-color: transparent;
            color: hsl(var(--foreground));
            font-weight: 700;
            text-decoration: underline;
        }
        
        /* Utility Classes */
        .text-sm { font-size: 0.875rem; line-height: 1.25rem; }
        .text-base { font-size: 1rem; line-height: 1.5rem; }
        .text-lg { font-size: 1.125rem; line-height: 1.75rem; }
        .text-xl { font-size: 1.25rem; line-height: 1.75rem; }
        .text-2xl { font-size: 1.5rem; line-height: 2rem; }
        .text-3xl { font-size: 1.875rem; line-height: 2.25rem; }
        
        .font-medium { font-weight: 500; }
        .font-semibold { font-weight: 600; }
        .font-bold { font-weight: 700; }
        
        /* Lucide Icon Fallbacks */
        [data-lucide] {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            height: 1em;
            width: 1em;
            color: hsl(var(--foreground)); /* Set icons to use the foreground color by default */
        }
        
        /* Icon color handling for specific icons */
        @media (prefers-color-scheme: light) {
            [data-lucide="settings"] {
                color: #000; /* Black in light mode */
            }
        }
        
        @media (prefers-color-scheme: dark) {
            [data-lucide="settings"] {
                color: hsl(var(--foreground)); /* Light color in dark mode */
            }
        }
        
        /* Always make icons in dark buttons (like Add Expense) white */
        .quick-action-card [data-lucide],
        .expense-btn [data-lucide],
        .balance-btn [data-lucide],
        .add-btn [data-lucide],
        .swipe-action [data-lucide] {
            color: #ffffff;
        }
        
        /* Fallback text for when icons don't load */
        [data-lucide]:empty::before {
            content: '';
            font-size: 1.2em;
        }
        
        .text-foreground { color: hsl(var(--foreground)); }
        .text-muted-foreground { color: hsl(var(--muted-foreground)); }
        .text-primary { color: hsl(var(--primary)); }
        .text-success { color: hsl(var(--success)); }
        .text-destructive { color: hsl(var(--destructive)); }
        
        .flex { display: flex; }
        .flex-col { flex-direction: column; }
        .items-center { align-items: center; }
        .justify-center { justify-content: center; }
        .justify-between { justify-content: space-between; }
        .gap-2 { gap: 0.5rem; }
        .gap-3 { gap: 0.75rem; }
        .gap-4 { gap: 1rem; }
        
        .p-2 { padding: 0.5rem; }
        .p-4 { padding: 1rem; }
        .px-3 { padding-left: 0.75rem; padding-right: 0.75rem; }
        .px-4 { padding-left: 1rem; padding-right: 1rem; }
        .py-2 { padding: 0.5rem 0; }
        .py-3 { padding: 0.75rem 0; }
        
        .mb-2 { margin-bottom: 0.5rem; }
        .mb-4 { margin-bottom: 1rem; }
        .mb-6 { margin-bottom: 1.5rem; }
        .mr-2 { margin-right: 0.5rem; }
        
        .rounded { border-radius: var(--radius); }
        .rounded-lg { border-radius: var(--radius); }
        .rounded-full { border-radius: 9999px; }
        
        /* Icon Styles */
        .w-4 { width: 1rem; }
        .h-4 { height: 1rem; }
        .w-5 { width: 1.25rem; }
        .h-5 { height: 1.25rem; }
        .w-6 { width: 1.5rem; }
        .h-6 { height: 1.5rem; }
        
        .app-container {
            height: 100vh;
            display: flex;
            flex-direction: column;
            position: relative;
            background-color: hsl(var(--background));
        }
        
        .app-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 20px;
            background: hsl(36deg 55.56% 98.24%);
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            z-index: 10;
        }
        
        .app-header::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            height: 30%;
            pointer-events: none;
        }
        
        .app-header::after {
            content: '';
            position: absolute;
            top: 30%;
            left: 0;
            right: 0;
            height: 40%;
            pointer-events: none;
        }
        
        .app-header h1 {
            font-size: 1.3rem;
            font-weight: 600;
            color: hsl(var(--foreground));
            margin-bottom: 0.25rem;
        }
        
        .date-display {
            font-size: 0.875rem;
            color: hsl(var(--muted-foreground));
        }
        
        .content-container {
            flex: 1;
            position: relative;
            overflow: hidden;
        }
        
        .screens-wrapper {
            display: flex;
            height: 100%;
            /* transition: transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94); */
            will-change: transform;
        }
        
        .screen {
            width: 100vw;
            flex-shrink: 0;
            overflow-y: auto;
            overflow-x: hidden; /* Prevent horizontal scrolling */
            padding: 1rem;
            padding-top: 86px; /* Account for fixed header height */
            background-color: rgba(200, 160, 61, 0.04);
        }
        
        /* Remove old daily-budget styles - now using card classes */
        
        /* Action Buttons */
        .action-buttons {
            display: flex;
            gap: 0.75rem;
            justify-content: center;
            margin-bottom: 1.5rem;
            margin-top: 1.5rem;
            padding: 0 1.5rem;
        }
        
        .action-btn {
            flex: 1;
            max-width: 200px;
        }
        
        .expense-btn {
            background-color: hsl(220, 13%, 18%);
            color: #ffffff;
        }
        
        .expense-btn:hover {
            background-color: hsl(220, 13%, 28%);
        }
        
        .balance-btn {
            background-color: hsl(220, 13%, 18%);
            color: #ffffff;
        }
        
        .balance-btn:hover {
            background-color: hsl(220, 13%, 28%);
        }
        
        /* Remove old action-label styles - using shadcn button styling */
        
        @media (max-width: 480px) {
            .action-buttons {
                padding: 0px;
                gap: 10px;
            }
            
            .action-btn {
                padding: 14px 16px;
                max-width: none;
            }
            
            .action-label {
                font-size: 0.85rem;
            }
        }
        
        .expense-input {
            margin-bottom: 25px;
        }
        
        .input-row {
            display: flex;
            gap: 10px;
            align-items: flex-end;
        }
        
        .input-group {
            flex: 1;
        }
        
        .input-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            color: hsl(var(--foreground));
            font-size: 0.9rem;
        }
        
        .input-group input, .input-group select {
            width: 100%;
            min-height: 44px; /* iOS recommended minimum touch target */
            padding: 14px 16px;
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            font-size: 1rem;
            background-color: hsl(var(--background));
            color: hsl(var(--foreground));
            transition: all 0.3s ease;
        }
        
        .input-group input:focus, .input-group select:focus {
            outline: 2px solid hsl(var(--ring));
            outline-offset: 2px;
            border-color: hsl(var(--ring));
        }
        
        .add-btn {
            background: linear-gradient(135deg, hsl(260deg 58.02% 57.98%), hsl(260deg 54.55% 69.74%));
            border-radius: 1rem;
            color: #ffffff;
            border: none;
            padding: 10px 16px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            display: block;
        }
        
        .add-btn:hover {
            background-color: hsl(220, 13%, 28%);
        }
        
        .add-btn:active {
            transform: translateY(1px);
        }
        
        /* Settings menu add-btn styling */
        .settings-menu-btn-item .add-btn {
            display: flex;
            align-items: center;
            justify-content: flex-start;
            gap: 1rem;
            font-size: 0.95rem;
            font-weight: 600;
            padding: 10px 16px;
            margin: 0;
            background-color: hsl(var(--primary));
            color: hsl(var(--primary-foreground));
            border: none;
            border-radius: var(--radius);
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
        }
        
        .settings-menu-btn-item .add-btn:hover {
            background-color: hsl(var(--primary) / 0.9);
        }
        
        .settings-menu-btn-item .add-btn:active {
            transform: translateY(1px);
        }
        
        .settings-menu-btn-item .add-btn .settings-menu-icon {
            color: #fff;
        }
        
        .expenses-list {
            /* max-height: 300px; */
            overflow-y: auto;
            margin: 0 -1rem;
        }
        
        
        /* .expense-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background-color: hsl(var(--card));
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
        } */

         /* Keep borders for specific cards that need them */
        .expense-item {
            display: flex;
            flex: 1;
            align-items: center;
            padding: 1rem;
            background-color: hsl(var(--card));
            border-top: 1px solid hsl(var(--border));
            border-radius: 0;
            transition: transform 0.3s, background-color 0.3s;
            cursor: pointer;
            gap: 0.75rem;
        }
        
        .expense-icon {
            font-size: 1.1rem;
            flex-shrink: 0;
        }
        
        .expense-details {
            display: flex;
            flex-direction: column;
            gap: .19rem;
            flex: 1;
        }
        
        .expense-description {
            text-transform: capitalize;
            /* font-size: 0.95rem; */
            color: #444;
            font-weight: 500;
            flex: 1 1 40%;
        }
        
        .expense-category {
            font-size: 0.8rem;
            color: rgba(124, 128, 138, 0.74);
            text-transform: uppercase;
            font-weight: 600;
            letter-spacing: .01rem;
        }
        
        .expense-amount {
            font-size: 1rem;
            color: hsl(var(--foreground));
            text-align: right;
            flex-shrink: 0;
        }
        
        
        .date-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 1rem;
            margin: 0;
            background: hsl(0deg 0% 0% / 2%);
            font-weight: 600;
        }
        
     
        
        .date-title {
            font-size: 0.9rem;
            color: hsl(var(--foreground));
        }
        
        .date-total {
            font-size: 0.9rem;
            font-weight: 600;
        }
        
        .account-header-section {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1rem;
        }
        
        .date-transactions {
            display: flex;
            flex-direction: column;
            gap: 0;
        }
        
        .delete-btn {
            background-color: hsl(0deg 0% 95.88%);
            color: hsl(0deg 0% 24.54%);
            border: none;
            padding: 6px 10px;
            border-radius: var(--radius);
            font-size: 0.8rem;
            cursor: pointer;
            margin-left: 10px;
            transition: all 150ms ease;
        }
        
        .delete-btn:hover {
            background-color: hsl(var(--destructive) / 0.9);
        }
        
        .chart-container {
            /* Use .card class instead of custom styling */
            height: 350px;
        }
        
        /* Charts with headers use flexbox layout */
        .chart-container.chart-with-header {
            display: flex;
            flex-direction: column;
        }
        
        .chart-container.chart-with-header canvas {
            flex: 1;
            min-height: 0;
        }
        
        .chart-canvas-wrapper {
            flex: 1;
            padding: 0 1rem 1rem 1rem;
            min-height: 0;
            position: relative;
        }
        
        .chart-canvas-wrapper canvas {
            width: 100% !important;
            height: 100% !important;
        }
        
        /* Specific styling for category chart to prevent height issues */
        #categoryChart {
            max-height: none !important;
            min-height: 200px !important;
        }
        
        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem;
            flex-shrink: 0;
        }
        
        .chart-header h3 {
            margin: 0;
            font-size: 1.1rem;
            font-weight: 600;
            color: hsl(var(--foreground));
        }
        
        .chart-time-range {
            font-size: 0.8rem;
            color: hsl(var(--muted-foreground));
            background: hsl(var(--muted));
            padding: 0.25rem 0.5rem;
            border-radius: 0.375rem;
        }
        
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 1rem;
            margin-bottom: 1rem;
        }
        
        /* Remove margin-bottom from stat cards since we're using gap */
        .stats-grid .stat-card {
            margin-bottom: 0;
        }
        
        .stat-card {
            /* Use .card class instead of custom styling */
            text-align: center;
            padding: 1rem;
        }
        
        .stat-label {
            font-size: 0.8rem;
            color: hsl(var(--muted-foreground));
            margin-bottom: 8px;
            font-weight: 500;
        }
        
        .stat-value {
            font-size: 1.4rem;
            font-weight: 700;
            color: hsl(var(--foreground));
        }
        
        .stat-subtitle {
            font-size: 0.75rem;
            color: hsl(var(--muted-foreground));
            margin-top: 4px;
            font-weight: 400;
        }
        
        .stat-subtitle.positive {
            color: hsl(var(--success));
        }
        
        .stat-subtitle.positive {
            color: hsl(var(--success));
        }
        
        .stat-value.positive {
            color: hsl(var(--success));
        }
        
        .stat-value.negative {
            color: hsl(var(--destructive));
        }
        
        .stat-value.warning {
            color: hsl(var(--warning));
        }
        
        .bottom-nav {
            background-color: hsl(var(--card));
            border-top: 1px solid hsl(var(--border));
            padding: 1.25rem 0; /* Further increased padding for iOS swipe bar clearance */
            display: flex;
            justify-content: center;
            align-items: center;
            backdrop-filter: blur(10px);
            position: relative;
        }
        
        .nav-item {
            display: flex;
            top: -6px;
            align-items: center;
            padding: 0.5rem;
            margin: 0 1.5rem; /* Increased margin for better spacing */
            cursor: pointer;
            transition: all 150ms ease, transform 0.12s;
            border-radius: var(--radius);
            user-select: none;
            color: hsl(var(--muted-foreground) / 0.5); /* More grayed out for inactive items */
            position: relative;
            opacity: 0.6; /* Additional opacity to ensure graying out */
        }
        
        .nav-item.active {
            color: hsl(var(--foreground)); /* Darker color for active item */
            font-weight: 500; /* Slightly bolder to enhance visibility */
            opacity: 1; /* Full opacity for active item */
        }
        
        .nav-item:hover:not(.active) {
            color: hsl(var(--foreground) / 0.8); /* Slightly darker on hover */
        }
        
        .nav-item:active {
            transform: scale(0.92);
        }
        
        .nav-item .icon {
            font-size: 1.3rem;
            transition: all 150ms ease;
            color: inherit; /* Ensure icon inherits the parent's color */
        }
        
        /* Make icon size slightly bigger for active state */
        .nav-item.active .icon {
            transform: scale(1.10);
        }
        
        /* Hide labels as requested */
        .nav-item .label {
            display: none;
        }
        
        .screen::-webkit-scrollbar {
            display: none;
        }
        
        .screen {
            -ms-overflow-style: none;
            scrollbar-width: none;
            -webkit-overflow-scrolling: touch;
        }
        
        .status-indicator {
            display: inline-block;
            width: 8px;
            height: 8px;
            border-radius: 50%;
            margin-right: 8px;
        }
        
        .status-good { background-color: hsl(var(--success)); }
        .status-warning { background-color: hsl(var(--warning)); }
        .status-danger { background-color: hsl(var(--destructive)); }
        
        .weekly-summary {
            background-color: hsl(var(--primary));
            color: hsl(var(--primary-foreground));
            text-align: center;
            margin-bottom: 20px;
            border-radius: var(--radius);
            padding: 1.5rem;
        }
        
        .weekly-summary h3 {
            margin-bottom: 10px;
            font-size: 1.1rem;
        }
        
        .weekly-stats {
            display: flex;
            justify-content: space-around;
            margin-top: 15px;
        }
        
        .weekly-stat {
            text-align: center;
        }
        
        .weekly-stat-value {
            font-size: 1.2rem;
            font-weight: 700;
        }
        
        .weekly-stat-label {
            font-size: 0.8rem;
            opacity: 0.8;
        }
        
        /* Combined spent/remaining card styles */
        .combined-stats {
            display: flex;
            align-items: center;
            justify-content: space-around;
            margin-top: 15px;
        }
        
        .combined-stat {
            text-align: center;
            flex: 1;
        }
        
        .combined-stat-value {
            font-size: 1.2rem;
            font-weight: 700;
        }
        
        .combined-stat-label {
            font-size: 0.8rem;
            margin-top: 5px;
            opacity: 0.8;
        }
        
        .stat-separator {
            width: 1px;
            height: 40px;
            background: hsla(var(--primary-foreground) / 0.3);
            margin: 0 1rem;
        }
        
        /* Combined budget stats for cashflow screen */
        .combined-budget-card {
            background: hsl(var(--card));
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            padding: 1.5rem;
            flex: 1;
            text-align: center;
        }
        
        .sticky-container {
            /* Container for sticky controls and expenses list */
        }
        
        .sticky-controls-section {
            position: sticky;
            top: -2px;
            z-index: 100;
            transform: translateY(0);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            margin: 0 -1rem;
            backdrop-filter: blur(21px);
            background: hsl(36deg 55.56% 98.24% / 70%);
        }
        
        .sticky-controls-section.hidden {
            transform: translateY(-100%);
        }
        
        .sticky-controls-content {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            min-height: 38px;
            padding: 0.6rem 0;
            margin: 1rem;
            border-radius: 1rem;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        /* Style the expenses list card inside sticky section */
        .sticky-controls-section .expenses-list-card {
            margin: 0 1rem 1rem 1rem;
        }
        
        .sticky-title-section {
            position: sticky;
            top: 69px;
            z-index: 99;
            background: rgba(255, 255, 255, 0.8);
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            padding: 0.6rem 1rem;
            margin: 0 -1rem;
            transition: top 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .sticky-controls-section.hidden ~ .sticky-title-section {
            top: 0;
        }
        
        /* Give white backgrounds only to interactive elements */
        #budgetTitleContainer button {
            background: hsl(var(--card)) !important;
        }
       
        
        
        
        #monthYearSelectorBtn {
            height: 38px !important;
            box-sizing: border-box !important;
            line-height: 1 !important;
            min-height: 38px !important;
            max-height: 38px !important;
        }
        
        #monthYearSelectorBtn:hover {
            background: hsl(var(--accent)) !important;
            transition: background 0.2s ease;
        }
        
        .expenses-list-card {
            position: sticky;
            top: 80px;
            z-index: 10;
        }
        
        .combined-budget-stats {
            display: flex;
            align-items: stretch;
            justify-content: space-between;
            gap: 2rem;
        }
        
        .combined-budget-stat {
            flex: 1;
            text-align: center;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
        }
        
        .budget-separator {
            width: 1px;
            background: hsl(var(--border));
            opacity: 0.5;
            align-self: stretch;
            margin: 0;
        }
        
        /* period-selector uses .card class for styling */

        .period-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            width: 100%;
        }

        .period-title {
            font-size: 1.2rem;
            font-weight: 700;
            margin: 0;
            color: hsl(var(--foreground));
        }

        /* Icon-only toggle for day/month - styled like chart-period-selector-bottom */
        .period-icon-toggle {
            display: flex;
            align-items: center;
            background: hsl(var(--card));
            border: 1px solid hsl(var(--border));
            border-radius: 1rem;
            padding: 4px;
            height: 38px;
            box-sizing: border-box;
            min-height: 38px;
            max-height: 38px;
        }
        
        .period-icon-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 36px;
            height: 30px;
            border: none;
            background: transparent;
            border-radius: 1rem;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            color: hsl(var(--muted-foreground));
            padding: 0;
            transform: scale(1);
        }
        button.period-icon-btn {
            min-height: 0;
        }
        
        .period-icon-btn.active {
            background: hsl(89.33deg 55.56% 68.24% / 52.16%);
            color: hsl(var(--foreground));
            transform: scale(1);
            opacity: 1;
        }
        
        .period-icon-btn:hover:not(.active) {
            color: hsl(var(--foreground));
            transform: scale(0.8);
        }
        
        .period-icon-btn:focus {
            outline: none;
        }

        /* Original period switch (to be hidden/replaced) */
        .period-switch {
            display: none; /* Hide the original switch */
        }

        .period-switch button {
            background-color: transparent;
            border: none;
            color: hsl(var(--muted-foreground));
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            transition: color 0.2s ease;
            padding: 0.5rem 1rem;
            border-radius: var(--radius);
        }

        .period-switch button.active {
            color: hsl(var(--foreground));
            background-color: hsl(var(--muted));
        }

        .month-navigation {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-top: 10px;
        }

        .month-nav-btn {
            background-color: hsl(var(--primary));
            color: hsl(var(--primary-foreground));
            border: none;
            width: 32px;
            height: 32px;
            border-radius: var(--radius);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            transition: all 0.2s ease;
        }

        .month-nav-btn:hover {
            background-color: hsl(var(--primary) / 0.9);
        }

        .month-nav-btn:disabled {
            background-color: hsl(var(--muted));
            color: hsl(var(--muted-foreground));
            cursor: not-allowed;
        }

        .selected-month {
            font-size: 1rem;
            font-weight: 600;
            color: hsl(var(--foreground));
            text-align: center;
            min-width: 120px;
        }
        
        .chart-period-selector {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-bottom: 20px;
            padding: 4px;
            background-color: hsl(var(--muted));
            border-radius: var(--radius);
        }

        .chart-period-btn {
            padding: 8px 16px;
            border: none;
            background: transparent;
            border-radius: calc(var(--radius) - 2px);
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            color: hsl(var(--muted-foreground));
            min-width: 60px;
        }

        .chart-period-btn.active {
            background-color: hsl(var(--background));
            color: hsl(var(--foreground));
            box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1);
        }

        .chart-period-btn:hover:not(.active) {
            background-color: hsl(var(--accent));
            color: hsl(var(--accent-foreground));
        }
        
        /* chart-container-wrapper uses .card class for styling */
        
        /* Enhanced Wealthsimple-style chart header */
        .chart-container-wrapper {
            position: relative;
            overflow: hidden; /* Prevent wrapper overflow */
        }
        
        /* Chart date display - visible when interacted with */
        .chart-date-display {
            margin-bottom: 8px;
            font-weight: 500;
            font-size: 1rem;
            color: hsl(var(--foreground));
            height: 1.2rem;
            opacity: 0;
            transition: opacity 0.15s ease;
        }
        
        .chart-date-display.visible {
            opacity: 1;
        }
        
        .chart-header {
            padding: 0 6px;
        }
        
        /* Chart row container for savings and spending */
        .chart-row {
            margin-bottom: 16px;
        }
        
        .chart-row:last-child {
            margin-bottom: 0;
        }

        .chart-date-display {
            display: flex;
            font-weight: 600;
            color: #6B7280; 
            margin-bottom: 15px;
        }
        
        /* Savings row styling (black) */
        .savings-row .chart-main-value {
            font-size: 2.5rem;
            font-weight: 700;
            color: hsl(var(--foreground));
            margin-bottom: 4px;
            line-height: 1;
            letter-spacing: -0.02em;
        }
        
        .savings-row .chart-subtitle {
            color: black; /* Gray color for spending */
           letter-spacing: 0.07rem;
            text-transform: uppercase;
            font-size: 0.9rem;
            margin-bottom: 8px;
            font-weight: 600;
        }
        
        .savings-row .chart-growth {
            font-size: 0.9rem;
            font-weight: 500;
            padding: 4px 0;
            margin-bottom: 8px;
        }
        
        /* Spending row styling (gray) */
        .spending-row .chart-main-value {
            font-size: 1.7rem;
            font-weight: 600;
            color: #6B7280; /* Gray color for spending */
            margin-bottom: 4px;
            line-height: 1;
            letter-spacing: -0.02em;
        }
        
        .spending-row .chart-subtitle {
            color: black; /* Gray color for spending */
            letter-spacing: 0.07rem;
            text-transform: uppercase;
            font-size: 0.9rem;
            margin-bottom: 8px;
            font-weight: 600;
        }
        
        .spending-row .chart-growth {
            font-size: 0.85rem;
            font-weight: 500;
            padding: 4px 0;
            margin-bottom: 8px;
            color: #6B7280; /* Gray color for spending growth */
        }
        
        /* Legacy styles for backward compatibility */
        .chart-main-value {
            font-size: 2.5rem;
            font-weight: 700;
            color: hsl(var(--foreground));
            margin-bottom: 4px;
            line-height: 1;
            letter-spacing: -0.02em;
        }
        
        .chart-subtitle {
            font-size: 1rem;
            color: hsl(var(--muted-foreground));
            margin-bottom: 8px;
            font-weight: 500;
        }
        
        .chart-growth {
            font-size: 0.95rem;
            font-weight: 500;
            padding: 4px 0;
        }
        
        .chart-growth.positive {
            color: hsl(var(--success)); /* Green for positive growth */
        }
        
        .chart-growth.negative {
            color: #EF4444; /* Red for negative growth */
        }
        
        .chart-container {
            position: relative;
            /* Removed fixed height to allow flexible canvas sizing */
            margin-top: 20px;
            transition: opacity 0.2s ease;
            /* Added gradient fade to transparent/white */
            mask-image: linear-gradient(to bottom, black 80%, transparent 100%);
            -webkit-mask-image: linear-gradient(to bottom, black 80%, transparent 100%);
        }
        
        .chart-container.loading::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.7);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 5;
        }
        
        .chart-container.loading::before {
            content: '';
            position: absolute;
            width: 30px;
            height: 30px;
            border: 3px solid rgba(16, 185, 129, 0.2);
            border-radius: 50%;
            border-top-color: hsl(var(--success));
            animation: spin 0.8s linear infinite;
            z-index: 6;
            top: 50%;
            left: 50%;
            margin-top: -15px;
            margin-left: -15px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        /* Bottom Period Selector for Chart (Wealthsimple Style) */
        .chart-period-selector-bottom {
            display: flex;
            justify-content: center;
            gap: 0;
            margin-top: 24px;
            background-color: hsl(var(--muted));
            border-radius: calc(var(--radius) * 2.5);
            padding: 4px;
            width: fit-content;
            margin-left: auto;
            margin-right: auto;
        }
        
        /* Enhanced Wealthsimple-style period selector buttons */
        .chart-period-btn-wealthsimple {
            padding: 8px 16px;
            border: none;
            background: transparent;
            border-radius: calc(var(--radius) * 2);
            font-size: 0.9rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
            color: hsl(var(--muted-foreground));
            min-width: 50px;
            letter-spacing: 0.02em;
            position: relative;
            z-index: 1;
            min-height: 0;
        }
        
        .chart-period-btn-wealthsimple.active {
            background-color: hsl(var(--background));
            color: hsl(var(--foreground));
            box-shadow: 0 2px 4px -1px rgba(0, 0, 0, 0.06);
            font-weight: 600;
        }
        
        .chart-period-btn-wealthsimple:hover:not(.active) {
            color: hsl(var(--foreground));
        }
        
        .chart-period-btn-wealthsimple:focus {
            outline: none;
            box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.2);
        }
        
        /* Animate period button transitions */
        .chart-period-selector-bottom {
            position: relative;
        }
        
        @media (prefers-reduced-motion: no-preference) {
            .chart-period-btn-wealthsimple.active {
                animation: scaleIn 0.2s ease forwards;
            }
            
            @keyframes scaleIn {
                0% { transform: scale(0.95); }
                100% { transform: scale(1); }
            }
        }
        
        /* Sticky Period Selector for Tracking Screen */
        .period-selector-sticky {
            position: sticky;
            top: 0;
            z-index: 100;
            background-color: #ffffffa1; /* Semi-transparent white */
            border-bottom: 1px solid hsl(var(--border));
            backdrop-filter: blur(10px);
            box-shadow: 0 1px 3px 0 rgb(0 0 0 / 0.1);
            border-radius: 0;
            margin-bottom: 20px;
            border-radius: 10px;
        }
        
        .period-selector-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        /* Compact Toggle - Full Width */
        .period-mode-toggle-compact {
            display: flex;
            background: hsl(210deg 33.58% 90.82% / 36%);
            backdrop-filter: blur(10px);
            border-radius: var(--radius);
            padding: 2px;
            gap: 0.5rem;
            width: 100%;
            justify-content: space-between;
            align-items: center;
        }
        
        .period-mode-btn-compact {
            padding: 0.375rem 0.75rem;
            border: none;
            background: transparent;
            border-radius: calc(var(--radius) - 2px);
            font-size: 0.875rem;
            font-weight: 500;
            color: hsl(var(--muted-foreground));
            cursor: pointer;
            transition: all 150ms ease;
            flex: 1;
            min-width: 0;
        }
        
        .period-mode-btn-compact.active {
            background-color: hsl(var(--background));
            color: hsl(var(--foreground));
            box-shadow: 0 1px 3px 0 rgb(0, 0, 0 / 0.1);
        }
        
        .period-mode-btn-compact:hover:not(.active) {
            background-color: hsl(var(--accent));
        }
        
        /* Spacer Icons - Evenly Distributed */
        .toggle-spacer-icons {
            display: flex;
            justify-content: space-evenly;
            align-items: center;
            flex: 1;
            gap: 0.5rem;
            padding: 0 0.5rem;
        }
        
        .toggle-spacer-icons i {
            color: hsl(var(--muted-foreground));
            opacity: 0.6;
            transition: all 150ms ease;
        }
        
        .toggle-spacer-icons i:hover {
            opacity: 1;
            color: hsl(var(--foreground));
        }
        
        /* Enhanced Wealthsimple-style chart overlay */
        .chart-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
            z-index: 10;
            opacity: 0;
            transition: opacity 0.15s ease;
        }
        
        .chart-container {
            position: relative;
            height: 250px; /* Minimum height instead of fixed height */
            margin: 0; /* Remove all margins */
            padding: 0; /* Remove all padding */
            border-radius: var(--radius);
            border-bottom: none; /* Remove bottom border */
            overflow: hidden; /* Prevent any overflow */
            touch-action: pan-y; /* Allow vertical scrolling */
            box-sizing: border-box; /* Include padding and border in element's width */
            /* Remove fade from container - we'll apply it just to the green area */
        }
        
        /* Full width styling for specific chart */
        .chart-container.full-width-chart {
            margin: 0 -1rem; /* Only horizontal negative margins */
            padding: 0; /* Remove all padding */
            width: calc(100% + 2rem);
            border-radius: 0;
            border: none; /* Remove all borders */
            overflow-x: hidden; /* Prevent horizontal overflow */
            max-width: 100vw; /* Ensure it doesn't exceed viewport width */
        }
        
        #spendingChart {
            touch-action: pan-y; /* Allow vertical scrolling */
            cursor: crosshair;
            padding: 0; /* Remove padding */
            margin: 0; /* Remove margin */
            min-height: 250px; /* Minimum height instead of fixed height */
            height: auto; /* Allow the canvas to grow as needed */
            width: 100%; /* Ensure full width */
            display: block; /* Remove any inline spacing */
        }
        
        #homeCashflowCanvas, #homeNetWorthCanvas, #accountsNetWorthCanvas {
            padding: 0;
            margin: 0;
            display: block;
            width: 100%;
            height: 100%;
        }
        
        /* Make chart more responsive to touch on mobile devices */
        @media (hover: none) and (pointer: coarse) {
            #spendingChart {
                cursor: default;
                padding: 15px 0; /* More padding on mobile for better touch area */
                touch-action: pan-y; /* Ensure vertical scrolling works on mobile */
                min-height: 280px; /* Slightly larger on mobile for better touch targets */
            }
        }
        
        .chart-crosshair {
            position: absolute;
            width: 2px;
            height: 100%;
            background: rgba(107, 114, 128, 0.7); /* Changed to gray color to match chart */
            opacity: 0;
            z-index: 20;
            pointer-events: none;
            /* Dashed line effect */
            background: repeating-linear-gradient(
                to bottom,
                rgba(107, 114, 128, 0.7) 0px,
                rgba(107, 114, 128, 0.7) 6px,
                transparent 6px,
                transparent 12px
            );
            transition: opacity 0.15s ease, left 0.05s linear;
        }
        .chart-overlay.visible {
            opacity: 1;
        }
        @media (hover: none) and (pointer: coarse) {
            .chart-crosshair {
                width: 3px;
                background: repeating-linear-gradient(
                    to bottom,
                    rgba(107, 114, 128, 0.8) 0px, /* Slightly more opaque for better visibility */
                    rgba(107, 114, 128, 0.8) 8px,  /* Larger segments for mobile visibility */
                    transparent 8px,
                    transparent 16px
                );
            }
        }
        
        .chart-overlay.visible .chart-tooltip {
            opacity: 1;
            transform: translateY(0);
        }
        
        .tooltip-date {
            font-size: 0.95rem;
            color: #111827;
            margin-bottom: 12px;
            font-weight: 600;
            border-bottom: 1px solid rgba(230, 230, 230, 0.5);
            padding-bottom: 10px;
        }
        
        .tooltip-values {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }
        
        .tooltip-value {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        
        .tooltip-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            flex-shrink: 0;
        }
        
        .tooltip-dot.savings {
            background: hsl(var(--success)); /* Match the green line color */
            box-shadow: 0 0 0 2px rgba(16, 185, 129, 0.2);
        }
        
        .tooltip-dot.spending {
            background: #6B7280; /* Match the gray line color */
            box-shadow: 0 0 0 2px rgba(107, 114, 128, 0.2);
        }
        
        .tooltip-label {
            font-size: 0.85rem;
            color: #666;
            flex: 1;
        }
        
        .tooltip-value:first-child .tooltip-amount {
            color: hsl(var(--success)); /* Green for savings */
            font-weight: 600;
        }
        
        .tooltip-value:last-child .tooltip-amount {
            color: #6B7280; /* Gray for spending */
            font-weight: 600;
        }
        
        .tooltip-amount {
            font-size: 0.9rem;
            font-weight: 600;
        }
        
        /* Savings/Account tracking styles */
        .savings-accounts-section {
            margin-bottom: 20px;
            margin-top: 20px;
        }
        
        .section-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
            flex: 1;
        }
        
        .manage-accounts-btn {
            background-color: hsl(var(--secondary));
            color: hsl(var(--secondary-foreground));
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            padding: 0.5rem 0.75rem;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 150ms ease;
            display: inline-flex;
            align-items: center;
            gap: 0.25rem;
        }
        
        .manage-accounts-btn:hover {
            background-color: hsl(var(--secondary) / 0.8);
        }
        
        /* Mobile responsive for section header */
        @media (max-width: 480px) {
            .section-header h3 {
                font-size: 1.1rem;
            }
            
            .manage-accounts-btn {
                padding: 10px 14px;
                font-size: 0.85rem;
                min-height: 44px; /* Better touch target */
            }
        }
        
        .account-balance-input {
            margin-bottom: 15px;
        }
        
        .account-balance-input h4 {
            margin-bottom: 15px;
            color: hsl(var(--foreground));
            font-size: 1.1rem;
        }
        
        .balance-input-row {
            display: flex;
            gap: 10px;
            align-items: flex-end;
            flex-wrap: wrap;
        }
        
        .balance-input-row .input-group {
            flex: 1;
            min-width: 120px;
        }
        
        .balance-input-row select {
            width: 100%;
            min-height: 44px; /* iOS recommended minimum touch target */
            padding: 14px 16px;
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            font-size: 1rem;
            background-color: hsl(var(--background));
            color: hsl(var(--foreground));
            transition: all 0.3s ease;
        }
        
        .balance-input-row select:focus {
            outline: 2px solid hsl(var(--ring));
            outline-offset: 2px;
            border-color: hsl(var(--ring));
        }
        
        .balance-add-btn {
            background: linear-gradient(135deg, hsl(260deg 58.02% 57.98%), hsl(260deg 54.55% 69.74%));
            border-radius: 1rem;
            color: #ffffff;
            border: none;
            padding: 10px 16px;
            font-size: 0.95rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            display: block;
        }
        
        .balance-add-btn:hover {
            background-color: hsl(220, 13%, 28%);
        }
        
        /* Mobile responsiveness for balance input */
        @media (max-width: 480px) {
            .balance-input-row {
                flex-direction: column;
                align-items: stretch;
                gap: 15px;
            }
            
            .balance-input-row .input-group {
                min-width: 100%;
            }
            
            .balance-add-btn {
                width: 100%;
                margin-top: 5px;
            }
        }
        
        .balance-add-btn:active {
            transform: translateY(1px);
        }
        
        .account-balance-display {
            border: 1px solid hsl(var(--border));
            padding: 15px;
            border-radius: var(--radius);
            margin-bottom: 15px;
            text-align: center;
        }
        
        .current-balance {
            font-size: 1.5rem;
            font-weight: 700;
            color: hsl(var(--success));
            margin-bottom: 5px;
        }
        
        /* Mobile responsiveness for balance display */
        @media (max-width: 480px) {
            .account-balance-display {
                padding: 12px;
            }
            
            .current-balance {
                font-size: 1.3rem;
            }
        }
        
        .balance-change {
            font-size: 0.9rem;
            font-weight: 500;
        }
        
        .balance-change.positive {
            color: #27ae60;
        }
        
        .balance-change.negative {
            color: #e74c3c;
        }
        
        .balance-change.neutral {
            color: #666;
        }
        
        .balance-history {
            max-height: none !important;
            overflow-y: visible !important;
        }
        
        .balance-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 12px;
            background-color: hsl(var(--card));
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
        }
        
        .balance-details {
            flex: 1;
        }
        
        .balance-date {
            font-weight: 600;
            color: hsl(var(--foreground));
            margin-bottom: 2px;
        }
        
        .balance-account {
            font-size: 0.8rem;
            color: hsl(var(--muted-foreground));
        }
        
        .balance-amount {
            font-size: 1.1rem;
            font-weight: 700;
            color: hsl(var(--foreground));
        }
        
        .delete-balance-btn {
            background-color: hsl(0deg 0% 95.88%);
    color: hsl(0deg 0% 24.54%);
            border: none;
            padding: 4px 8px;
            border-radius: var(--radius);
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 150ms ease;
        }
        
        .delete-account-btn:hover {
            background-color: hsl(var(--destructive) / 0.9);
        }
        
        .add-account-form {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
        }
        
        .add-account-form input {
            flex: 1;
            min-height: 44px; /* iOS recommended minimum touch target */
            padding: 10px;
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            font-size: 0.9rem;
            background-color: hsl(var(--background));
            color: hsl(var(--foreground));
        }
        
        .add-account-form input:focus {
            outline: 2px solid hsl(var(--ring));
            outline-offset: 2px;
            border-color: hsl(var(--ring));
        }
        
        .add-account-form button {
            background-color: hsl(var(--primary));
            color: hsl(var(--primary-foreground));
            border: none;
            padding: 10px 15px;
            border-radius: var(--radius);
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 150ms ease;
        }
        
        .add-account-form button:hover {
            background-color: hsl(var(--primary) / 0.9);
        }
        
        /* Modal styles */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
        }
        
        .modal-content {
            background-color: hsl(var(--card));
            color: hsl(var(--card-foreground));
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            padding: 24px;
            margin: 20px;
            max-width: 400px;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
            box-shadow: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);
        }
        
        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }
        
        .modal-title {
            font-size: 1.3rem;
            font-weight: 600;
            color: hsl(var(--foreground));
        }
        
        .modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: #666;
            padding: 0;
            width: 32px;
            height: 32px;
            display: flex;
            align-items: center;
            justify-content: center;
            border-radius: 50%;
            transition: all 0.2s ease;
        }
        
        .modal-close:hover {
            background: rgba(0,0,0,0.1);
        }
        
        .account-list-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: rgba(0,0,0,0.03);
            border-radius: 8px;
            margin-bottom: 8px;
        }
        
        .account-name {
            font-weight: 500;
            color: hsl(var(--foreground));
        }
        
        .delete-account-btn {
            background-color: hsl(0deg 0% 95.88%);
            color: hsl(0deg 0% 24.54%);
            border: none;
            padding: 6px 12px;
            border-radius: var(--radius);
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 150ms ease;
        }
        
        .delete-account-btn:hover {
            background-color: hsl(var(--destructive) / 0.9);
        }
        
        .add-account-form {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid hsl(var(--border));
        }
        
        .add-account-btn {
            background: #27ae60;
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 8px;
            font-weight: 600;
            cursor: pointer;
            width: 100%;
            margin-top: 10px;
            transition: all 0.2s ease;
        }
        
        .add-account-btn:hover {
            background: #219a52;
        }
        
        /* Slide-out overlays */
        .slide-out-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            z-index: 2000;
        }
        
        .slide-out-overlay.active {
            opacity: 1;
            visibility: visible;
        }
        
        .slide-out-content {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: white;
            border-radius: 20px 20px 0 0;
            padding: 20px 20px 40px;
            transform: translateY(100%);
            transition: transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .slide-out-overlay.active .slide-out-content {
            transform: translateY(0);
        }
        
        .slide-out-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            position: relative;
        }
        
        .slide-out-title {
            font-size: 1.3rem;
            font-weight: 600;
            color: #2c3e50;
        }
        
        .slide-out-close {
            background-color: hsl(var(--muted));
            border: none;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: hsl(var(--foreground));
            transition: all 150ms ease;
        }
        
        .slide-out-close:hover {
            background-color: hsl(var(--muted) / 0.8);
        }
        
        .slide-out-form {
            display: flex;
            flex-direction: column;
        }
        
        /* Handle bar for slide-out - removed */

        /* Account Management Slide-out Styles */
        .account-management-slide-out {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.5);
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s ease;
            z-index: 2000;
        }
        
        .account-management-slide-out.active {
            opacity: 1;
            visibility: visible;
        }
        
        .account-management-content {
            position: absolute;
            bottom: 0;
            left: 0;
            right: 0;
            background: hsl(var(--background));
            border-radius: 20px 20px 0 0;
            padding: 20px 20px 40px;
            transform: translateY(100%);
            transition: transform 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            max-height: 80vh;
            overflow-y: auto;
        }
        
        .account-management-slide-out.active .account-management-content {
            transform: translateY(0);
        }
        
        .account-management-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            position: relative;
        }
        
        .account-management-title {
            font-size: 1.3rem;
            font-weight: 600;
            color: hsl(var(--foreground));
        }
        
        .account-management-close {
            background-color: hsl(var(--muted));
            border: none;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: hsl(var(--foreground));
            transition: all 150ms ease;
        }
        
        .account-management-close:hover {
            background-color: hsl(var(--muted) / 0.8);
        }
        
        .account-management-handle {
            display: none;
        }
        
        .account-management-list {
            margin-bottom: 20px;
        }
        
        .account-management-list-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: hsl(var(--card));
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            margin-bottom: 8px;
        }
        
        .account-management-name {
            font-weight: 500;
            color: hsl(var(--foreground));
        }
        
        .account-management-delete-btn {
            background-color: hsl(var(--destructive));
            color: hsl(var(--destructive-foreground));
            border: none;
            padding: 6px 12px;
            border-radius: var(--radius);
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 150ms ease;
            min-height: 32px;
            min-width: 60px;
        }
        
        .account-management-delete-btn:hover {
            background-color: hsl(var(--destructive) / 0.9);
        }
        
        .account-management-add-form {
            border-top: 1px solid hsl(var(--border));
            padding-top: 20px;
        }
        
        .account-management-add-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: hsl(var(--foreground));
            margin-bottom: 15px;
        }
        
        .account-management-input-group {
            margin-bottom: 15px;
        }
        
        .account-management-input {
            width: 100%;
            min-height: 44px;
            padding: 12px 16px;
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            font-size: 1rem;
            background-color: hsl(var(--background));
            color: hsl(var(--foreground));
            transition: all 0.3s ease;
            box-sizing: border-box;
        }
        
        .account-management-input:focus {
            outline: 2px solid hsl(var(--ring));
            outline-offset: 2px;
            border-color: hsl(var(--ring));
        }
        
        .account-management-add-btn {
            background-color: hsl(220, 13%, 18%);
            color: #ffffff;
            border: none;
            padding: 12px 20px;
            border-radius: var(--radius);
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            width: 100%;
            min-height: 44px;
        }
        
        .account-management-add-btn:hover {
            background-color: hsl(220, 13%, 28%);
        }
        
        .account-management-add-btn:active {
            transform: translateY(1px);
        }
        
        /* Mobile responsive adjustments for account management */
        @media (max-width: 480px) {
            .account-management-content {
                padding: 16px 16px 32px;
            }
            
            .account-management-title {
                font-size: 1.2rem;
            }
            
            .account-management-list-item {
                padding: 10px 12px;
            }
            
            .account-management-delete-btn {
                padding: 8px 12px;
                font-size: 0.75rem;
                min-width: 50px;
            }
            
            .account-management-input {
                padding: 10px 14px;
                font-size: 0.95rem;
            }
            
            .account-management-add-btn {
                padding: 10px 16px;
                font-size: 0.95rem;
            }
        }

        /* Custom Datepicker Styles */
        .custom-datepicker {
            position: relative;
            width: 100%;
        }

        .datepicker-trigger {
            display: flex;
            align-items: center;
            justify-content: space-between;
            min-height: 44px; /* iOS recommended minimum touch target */
            padding: 8px 12px;
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            background-color: hsl(var(--background));
            cursor: pointer;
            transition: all 150ms ease;
            font-size: 0.875rem;
        }

        .datepicker-trigger:hover {
            border-color: hsl(var(--ring));
        }

        .datepicker-trigger:focus {
            outline: none;
            border-color: hsl(var(--ring));
            box-shadow: 0 0 0 2px hsl(var(--ring) / 0.2);
        }
        
        .datepicker-trigger:focus-visible {
            outline: 2px solid hsl(var(--ring));
            outline-offset: 2px;
        }

        .datepicker-value {
            color: hsl(var(--foreground));
            flex: 1;
        }

        .datepicker-trigger .w-4 {
            width: 16px;
            height: 16px;
            color: hsl(var(--muted-foreground));
        }

        .datepicker-popup {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            z-index: 1000;
            background-color: hsl(var(--popover));
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
            padding: 16px;
            margin-top: 4px;
            display: none;
            min-width: 280px;
        }

        .datepicker-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 16px;
        }

        .datepicker-nav {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 32px;
            height: 32px;
            border: none;
            background: none;
            cursor: pointer;
            border-radius: var(--radius);
            transition: all 150ms ease;
        }

        .datepicker-nav:hover {
            background-color: hsl(var(--muted));
        }

        .datepicker-nav .w-4 {
            width: 16px;
            height: 16px;
            color: hsl(var(--foreground));
        }

        .datepicker-month-year {
            font-weight: 600;
            color: hsl(var(--foreground));
            font-size: 0.875rem;
        }

        .datepicker-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            gap: 2px;
            margin-bottom: 16px;
        }

        .datepicker-day-header {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 32px;
            font-size: 0.75rem;
            font-weight: 500;
            color: hsl(var(--muted-foreground));
        }

        .datepicker-day {
            display: flex;
            align-items: center;
            justify-content: center;
            height: 32px;
            border-radius: var(--radius);
            cursor: pointer;
            transition: all 150ms ease;
            font-size: 0.875rem;
            color: hsl(var(--foreground));
        }

        .datepicker-day:hover {
            background-color: hsl(var(--muted));
        }

        .datepicker-day.empty {
            cursor: default;
        }

        .datepicker-day.empty:hover {
            background-color: transparent;
        }

        .datepicker-day.today {
            background-color: hsl(var(--muted));
            font-weight: 500;
        }

        .datepicker-day.selected {
            background-color: hsl(var(--primary));
            color: hsl(var(--primary-foreground));
        }

        .datepicker-day.selected:hover {
            background-color: hsl(var(--primary));
        }

        .datepicker-footer {
            display: flex;
            justify-content: space-between;
            gap: 8px;
        }

        .datepicker-btn {
            display: inline-flex;
            align-items: center;
            justify-content: center;
            padding: 8px 16px;
            border-radius: var(--radius);
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 150ms ease;
            border: 1px solid transparent;
            flex: 1;
        }

        .datepicker-btn-secondary {
            background-color: hsl(var(--secondary));
            color: hsl(var(--secondary-foreground));
            border-color: hsl(var(--border));
        }

        .datepicker-btn-secondary:hover {
            background-color: hsl(var(--secondary) / 0.8);
        }

        .datepicker-btn-primary {
            background-color: hsl(var(--primary));
            color: hsl(var(--primary-foreground));
        }

        .datepicker-btn-primary:hover {
            background-color: hsl(var(--primary) / 0.9);
        }

        /* Mobile responsive adjustments */
        @media (max-width: 480px) {
            .datepicker-popup {
                min-width: calc(100vw - 40px);
                left: 50%;
                transform: translateX(-50%);
            }
        }

        /* --- Slide-out form full-width fields --- */
        .slide-out-form .form-group {
            /* width: 100%; */
            box-sizing: border-box;
        }
        .slide-out-form .input-row {
            display: flex;
            flex-direction: row;
            gap: 0.5rem;
            /* width: 100%; */
            /* max-width: 100%; */
        }
        .slide-out-form .input-row .form-group,
        .slide-out-form .input-row .select-container {
            flex: 1 1 0;
            min-width: 0;
        }
        .slide-out-form input,
        .slide-out-form select,
        .slide-out-form .select-trigger {
            width: 100%;
            max-width: 100%;
            box-sizing: border-box;
        }
        .slide-out-form .select-trigger {
            display: flex;
        }
        .slide-out-form .select-content {
            min-width: 100%;
        }
        @media (max-width: 600px) {
            .slide-out-form .input-row {
                flex-direction: column;
                gap: 0.5rem;
            }
        }
        /* --- Slide-out form: Amount and Category side by side, override global input-group rules --- */
        .slide-out-form .input-row {
            display: flex;
            flex-direction: row;
            gap: 0.5rem;
        }
        .slide-out-form .input-row .form-group {
            flex: 1 1 0;
            min-width: 0;
            margin-bottom: 0;
        }
        .slide-out-form .input-row .form-group label,
        .slide-out-form .input-row .form-group input,
        .slide-out-form .input-row .form-group select,
        .slide-out-form .input-row .select-container {
            display: initial;
            width: 100%;
            margin-bottom: 0.5rem;
        }

        /* Floating Action Button (FAB) Styles */
        .fab-container {
            position: fixed;
            bottom: 80px; /* Above bottom nav */
            right: 20px;
            z-index: 1000;
        }

        .fab-primary {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            background: hsl(var(--primary));
            color: hsl(var(--primary-foreground));
            border: none;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .fab-primary:hover {
            transform: scale(1.05);
            box-shadow: 0 6px 16px rgba(0, 0, 0, 0.2);
        }

        .fab-menu {
            position: absolute;
            bottom: 70px;
            right: 0;
            display: none;
            flex-direction: column;
            gap: 12px;
            align-items: flex-end;
        }

        .fab-menu.active {
            display: flex;
        }

        .fab-option {
            display: flex;
            align-items: center;
            gap: 12px;
            padding: 12px 16px;
            background: hsl(var(--card));
            border: 1px solid hsl(var(--border));
            border-radius: 24px;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
            cursor: pointer;
            transition: all 0.2s ease;
            white-space: nowrap;
        }

        .fab-option:hover {
            background: hsl(var(--accent));
            transform: translateX(-4px);
        }

        .fab-option-icon {
            width: 20px;
            height: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .quick-action-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 2em;
            height: 2em;
            background: #ffffff48;
            border-radius: 50%;
            color: hsl(var(--primary));
            font-size: 1.1em;
        }
        .quick-action-title {
            font-size: 1.08rem;
            font-weight: 500;
            margin: 0;
            padding: 0;
            color: #fff;
        }

        /* Hide old action buttons - now using Quick Action Cards */
        .action-buttons {
            display: none !important;
        }

        /* Hide FAB - now using Quick Action Cards */
        .fab-container {
            display: none !important;
        }

        /* Better spacing between card sections */
        
        .expense-input {
            margin-bottom: 32px;
        }
        
        /* Quick actions spacing */
        .quick-actions {
            position: sticky;
            z-index: 100000;
            display: flex;
            justify-content: center;
            /* width: max-content; */
            /* right: auto; */
            bottom: 0;
            transform: translateY(0);
            transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }
        
        .quick-actions.hidden {
            transform: translateY(100%);
        }
        
        /* Savings section spacing */
        .savings-accounts-section {
            margin-top: 8px;
        }

        .quick-action-card {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 0.5em 1.4em;
            background: linear-gradient(135deg, hsl(260deg 58.02% 57.98%), hsl(260deg 54.55% 69.74%));
            color: #ffffff;
            border: 2px solid hsl(260deg 15.51% 46.37%);
            border-radius: 11rem;
            font-size: 1.08rem;
            font-weight: 500;
            cursor: pointer;
            transition: box-shadow 0.16s, background 0.16s, transform 0.12s;
            box-shadow: 0 2px 19px 11px rgb(100 48 141 / 12%);
            margin: 0;
            min-height: 44px;
            outline: none;
        }
        .quick-action-card:hover,
        .quick-action-card:focus {
            background: linear-gradient(135deg, hsl(260deg 58.02% 57.98%), hsl(260deg 54.55% 69.74%));
            box-shadow: 0 4px 12px 0 rgba(0,0,0,0.25);
        }
        .quick-action-card:active {
            background: linear-gradient(135deg, hsl(260, 46%, 38%), hsl(260, 39%, 40%));
            transform: scale(0.98);
            color: #ffffff;
        }
        .quick-action-icon {
            display: flex;
            align-items: center;
            justify-content: center;
            width: 1.7em;
            height: 1.7em;
            background: none;
            border-radius: 50%;
            color: #ffffff;
            font-size: 1.1em;
            margin: 0;
        }
        .quick-action-title {
            font-size: 1.08rem;
            font-weight: 500;
            margin: 0;
            padding: 0;
            color: #ffffff;
            letter-spacing: 0.01em;
        }

        .fab-option:active {
            transform: translateY(2px);
        }

        .chart-overlay.visible .chart-tooltip {
            opacity: 1;
            transform: translateY(0);
        }
        
        .chart-overlay.visible .chart-crosshair {
            opacity: 1;
        }

        .fab-option:active {
            transform: translateY(2px);
        }

        /* Make form containers use grid for full-width buttons */
        .slide-out-form,
        .form-group:has(.add-btn),
        .form-group:has(.balance-add-btn),
        .form-group:has(.account-management-add-btn) {
            display: grid;
            grid-template-columns: 1fr;
            gap: 0.5rem;
        }
        
        /* Ensure the button container takes full width */
        .slide-out-form > .add-btn,
        .slide-out-form > .balance-add-btn,
        .account-management-add-form > .account-management-add-btn {
            grid-column: 1 / -1;
            width: 100%;
            max-width: none;
        }
        
        /* Make main expense form use grid for full-width button */
        .expense-input {
            display: grid;
            grid-template-columns: 1fr;
            gap: 0.5rem;
        }
        
        .expense-input > .add-btn {
            grid-column: 1 / -1;
            width: 100%;
            max-width: none;
        }

        .expense-amount.positive {
          color: hsl(var(--foreground));
        }

        .header-title {
            font-size: 1.125rem;
            font-weight: 600;
            color: hsl(var(--foreground));
            flex: 1;
            text-align: center;
        }

        .header-actions {
            display: flex;
            align-items: center;
            gap: 18px;
        }

        .icon-btn {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0;
            display: flex;
            align-items: center;
        }

        /* Settings Screen Styles */
        .form-group {
            margin-bottom: 0.75rem; /* consistent spacing */
        }

        .form-label {
            display: block;
            font-size: 0.875rem;
            font-weight: 500;
            color: hsl(var(--foreground));
            margin-bottom: 0.5rem;
        }

        .form-input {
            width: 100%;
            padding: 0.75rem;
            border: 1px solid hsl(var(--border));
            border-radius: var(--radius);
            font-size: 0.875rem;
            background-color: hsl(var(--background));
            color: hsl(var(--foreground));
            transition: border-color 0.2s ease;
            min-height: 44px;
        }

        .form-input:focus {
            outline: none;
            border-color: hsl(var(--ring));
            box-shadow: 0 0 0 2px hsl(var(--ring) / 0.2);
        }

        .form-help {
            font-size: 0.75rem;
            color: hsl(var(--muted-foreground));
            margin-top: 0.25rem;
        }

        .budget-summary {
            display: grid;
            gap: 0.75rem; /* consistent spacing */
        }

        .budget-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.75rem;
            background-color: hsl(var(--muted));
            border-radius: var(--radius);
        }

        .budget-label {
            font-size: 0.875rem;
            color: hsl(var(--muted-foreground));
        }

        .budget-value {
            font-size: 1rem;
            font-weight: 600;
            color: hsl(var(--foreground));
        }

        .budget-value.positive {
            color: hsl(var(--success));
        }

        .budget-value.negative {
            color: hsl(var(--destructive));
        }

        .budget-value.warning {
            color: hsl(var(--warning));
        }

        /* Tax Calculator Styles */
        .tax-calculator-section {
            margin-bottom: 1rem;
        }

        .tax-calculator-header {
            margin-bottom: 0.75rem;
        }

        .tax-calculator-inputs {
            display: grid;
            gap: 0.75rem;
            margin-bottom: 0.75rem;
        }

        .tax-calculator-inputs .form-group {
            margin-bottom: 0;
        }

        .calculate-btn {
            background-color: hsl(var(--primary));
            color: hsl(var(--primary-foreground));
            border: none;
            padding: 0.75rem 1.5rem;
            border-radius: var(--radius);
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 150ms ease;
            width: 100%;
        }

        .calculate-btn:hover {
            background-color: hsl(var(--primary) / 0.9);
        }

        .tax-results {
            background-color: hsl(var(--muted));
            border-radius: var(--radius);
            padding: 1rem;
            margin-bottom: 1rem;
        }

        .tax-summary {
            display: grid;
            gap: 0.75rem;
        }

        .tax-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem 0;
            border-bottom: 1px solid hsl(var(--border));
        }

        .tax-item:last-child {
            border-bottom: none;
        }

        .tax-item.total {
            border-top: 2px solid hsl(var(--border));
            border-bottom: none;
            padding-top: 0.75rem;
            margin-top: 0.5rem;
            font-weight: 600;
        }

        .tax-label {
            font-size: 0.875rem;
            color: hsl(var(--muted-foreground));
        }

        .tax-value {
            font-size: 0.875rem;
            font-weight: 500;
            color: hsl(var(--foreground));
        }

        .tax-item.total .tax-label,
        .tax-item.total .tax-value {
            font-weight: 600;
            color: hsl(var(--foreground));
        }

        .form-divider {
            height: 1px;
            background-color: hsl(var(--border));
            margin: 1rem 0;
        }

        .manual-override-section {
            margin-top: 1rem;
        }

        /* Accordion Styles */
        .accordion-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1rem;
            background-color: hsl(var(--muted));
            border-radius: var(--radius);
            cursor: pointer;
            transition: all 150ms ease;
            user-select: none;
        }

        .accordion-header:hover {
            background-color: hsl(var(--muted) / 0.8);
        }

        .accordion-header h4 {
            margin: 0;
        }

        .accordion-icon {
            width: 1.25rem;
            height: 1.25rem;
            transition: transform 150ms ease;
            color: hsl(var(--muted-foreground));
        }

        .accordion-header.expanded .accordion-icon {
            transform: rotate(180deg);
        }

        .accordion-content {
            max-height: 0;
            overflow: hidden;
            transition: max-height 150ms ease;
        }

        .accordion-content.expanded {
            max-height: 1000px;
            padding-top: 1rem;
        }

        /* Settings Slide-out Panel */
        .settings-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: transparent;
            z-index: 1000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .settings-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .settings-panel {
            position: fixed;
            top: 0;
            right: -100%;
            width: 100%;
            height: 100%;
            background-color: hsl(var(--background));
            z-index: 1001;
            overflow-y: auto;
            transition: right 0.3s ease, transform 0.3s ease;
            box-sizing: border-box;
            box-shadow: -4px 0 20px rgba(0, 0, 0, 0.15);
        }

        .settings-panel.active {
            right: 0;
        }

        /* Budget panel transition */
        .budget-panel {
            position: fixed;
            top: 0;
            right: -100%;
            width: 100%;
            height: 100%;
            background-color: hsl(var(--background));
            z-index: 1002;
            overflow-y: auto;
            transition: right 0.3s ease;
            box-sizing: border-box;
            box-shadow: -4px 0 20px rgba(0, 0, 0, 0.15);
        }

        .budget-panel.active {
            right: 0;
        }

        /* Settings panel slide transition when budget is open */
        .settings-panel.budget-open {
            transform: translateX(-10px);
        }

        /* Main content slide transition */
        .app-container {
            transition: transform 0.3s ease;
        }

        .app-container.settings-open {
            transform: translateX(-10px);
        }

        /* Account Detail Screen */
        .account-detail-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: transparent;
            z-index: 1100;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.3s ease, visibility 0.3s ease;
        }

        .account-detail-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .account-detail-screen {
            position: fixed;
            top: 0;
            right: -100%;
            width: 100%;
            height: 100%;
            background-color: hsl(var(--background));
            transition: right 0.3s cubic-bezier(0.25, 0.46, 0.45, 0.94);
            overflow-y: auto;
            padding: 0;
            box-shadow: -4px 0 20px rgba(0, 0, 0, 0.15);
        }

        .account-detail-overlay.active .account-detail-screen {
            right: 0;
        }

        .account-detail-header {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 1rem;
            background-color: hsl(var(--background));
            border-bottom: 1px solid hsl(var(--border));
            position: sticky;
            top: 0;
            z-index: 10;
            position: relative;
        }

        .account-detail-back {
            background: none;
            border: none;
            padding: 0.5rem;
            border-radius: 50%;
            cursor: pointer;
            transition: background-color 0.2s ease;
            color: hsl(var(--foreground));
            position: absolute;
            left: 1rem;
            top: 50%;
            transform: translateY(-50%);
        }

        .account-detail-back:hover {
            background-color: hsl(var(--accent));
        }

        .account-detail-title-container {
            flex: 1;
            text-align: center;
        }

        .account-detail-title {
            font-size: 1.5rem;
            font-weight: 600;
            margin: 0;
            color: hsl(var(--foreground));
        }

        .account-detail-balance {
            font-size: 1.125rem;
            color: hsl(var(--muted-foreground));
            margin-top: 0.25rem;
        }

        .account-detail-chart-card {
            margin: 0;
            margin-bottom: 0.5rem;
            border-radius: 0;
            border-left: none;
            border-right: none;
        }

        .account-detail-activity {
            margin: 0.5rem 1rem;
        }

        .account-detail-transactions {
            margin: 0.5rem 1rem 1rem;
        }

        /* Canvas styling for account detail chart */
        #accountDetailCanvas {
            padding: 0;
            margin: 0;
            display: block;
            width: 100%;
            height: 100%;
        }

        .settings-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 1rem;
            border-bottom: 1px solid hsl(var(--border));
            background-color: hsl(var(--background));
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .settings-title {
            font-size: 1.125rem;
            font-weight: 600;
            color: hsl(var(--foreground));
            flex: 1;
            text-align: center;
        }

        .settings-back {
            background: none;
            border: none;
            color: hsl(var(--muted-foreground));
            cursor: pointer;
            padding: 0.5rem;
            border-radius: 0.5rem;
            transition: background-color 0.2s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .settings-back:hover {
            background-color: hsl(var(--muted));
        }

        .settings-content {
            padding: 1rem;
        }

        @media (min-width: 768px) {
            .settings-panel {
                width: 400px;
            }
            .budget-panel {
                width: 400px;
            }
        }

        .card-content > *:not(:last-child) {
            margin-bottom: 0.75rem; /* consistent spacing between groups in a card */
        }

        .card {
            margin-bottom: 0.85rem; /* consistent spacing between cards */
        }

        .settings-menu-list {
  list-style: none;
  padding: 0;
  margin: 0;
}
.settings-menu-item {
  display: flex;
  align-items: center;
  padding: 2rem 0.5rem;
  border-bottom: 1px solid #eee;
  cursor: pointer;
  color: #111;
  font-size: 1.08rem;
  font-weight: 500;
  background: none;
}
.settings-menu-item:last-child {
  border-bottom: none;
}
.settings-menu-icon {
  margin-right: 1rem;
  display: flex;
  align-items: center;
  color: #111;
}
.settings-menu-arrow {
  margin-left: auto;
  color: #111;
  display: flex;
  align-items: center;
}
.settings-menu-btn-item {
  padding: 1rem 0.5rem 0rem 0.5rem;
  border-bottom: none;
}
.settings-menu-btn {
  width: 100%;
  display: flex;
  align-items: center;
  justify-content: flex-start;
  gap: 1rem;
  font-size: 1.08rem;
  font-weight: 500;
  background: hsl(var(--primary));
  color: hsl(var(--primary-foreground));
  border: none;
  border-radius: var(--radius);
  padding: 0.75rem 1.5rem;
  cursor: pointer;
  margin: 0;
}
.settings-menu-btn .settings-menu-icon {
  color: #fff;
}

.account-accordion {
  border: 1px solid #e5e7eb;
  border-radius: 12px;
  margin-bottom: 1.2rem;
  background: #fff;
  box-shadow: 0 1px 2px rgba(0,0,0,0.02);
}
.account-accordion-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem 1.5rem;
  cursor: pointer;
  font-weight: bold;
  background: #fff;
  border-bottom: 1px solid #f3f4f6;
  border-radius: 12px 12px 0 0;
}
.account-accordion-title {
  font-size: 1.1rem;
  font-weight: 600;
}
.account-accordion-value {
  font-size: 1.1rem;
  font-weight: 700;
  color: hsl(var(--success));
  margin-left: auto;
}
.account-accordion-chevron {
  font-size: 1.2rem;
  margin-left: 0.5rem;
  color: #888;
}
.account-accordion-body {
  padding: 0.5rem 1.5rem 1rem 1.5rem;
  background: #fafbfc;
  border-radius: 0 0 12px 12px;
}
.account-accordion-updates {
  margin: 0;
  padding: 0;
}
.account-update-row {
  display: flex;
  align-items: flex-end;
  justify-content: space-between;
  padding: 0.5rem 0;
  border-bottom: 1px solid #eee;
  font-size: 1rem;
}
.account-update-row:last-child {
  border-bottom: none;
}
.account-update-date {
  font-size: 1rem;
  color: #333;
  font-weight: 500;
}
.account-update-diff {
  font-size: 1.1rem;
  font-weight: 600;
  margin-left: 1rem;
}
.account-update-percent {
  font-size: 0.95rem;
  margin-left: 1rem;
  margin-top: 0.1rem;
  color: #888;
}
.account-update-percent.positive {
  color: #27ae60;
}
.account-update-percent.negative {
  color: #e74c3c;
}
.account-update-percent.neutral {
  color: #888;
}

/* Modern Wealthsimple-style Account Accordion Styles */
.modern-account-accordion {
    background: transparent;
    box-shadow: none;
    transition: none;
    border-bottom: 1px solid #eeeeee;
    margin: 0 -1rem;
    padding: 0;
    width: calc(100% + 2rem);
}
.modern-account-accordion.expanded {
    border-bottom: none;
}
.account-type-section .modern-account-accordion:last-child {
    border-bottom: none;
    margin-bottom: 0;
}
.modern-account-accordion-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 1rem;
  cursor: pointer;
  border-radius: 18px 18px 0 0;
  background: transparent;
  transition: none;
  box-shadow: none;
  margin: 0 -1rem;
  width: calc(100% + 2rem);
}

.modern-account-header-left {
  flex: 1 1 auto;
  display: flex;
  flex-direction: column;
  justify-content: center;
}
.modern-account-title {
 font-size: 0.9rem;
text-transform: uppercase;
font-weight: 800;
color: #787878;
letter-spacing: 0.04em;
}
.modern-account-header-right {
  display: flex;
margin-right: 0.5rem;   
  flex-direction: column;
  align-items: flex-end;
  margin-left: 1.2rem;
  font-size: 0.98rem;
  transition: opacity 0.2s;
}
.modern-account-accordion-header.expanded .modern-account-header-right {
  display: none;
}
.modern-account-balance {
  font-size: 1rem;
  font-weight: 700;
  color: #222;
  line-height: 1.1;
}

.modern-account-change {
  font-size: 0.8rem;
  font-weight: 500;
  margin-top: 0.2rem;
  display: flex;
  align-items: center;
  gap: 0.25rem;
}

.modern-account-change.positive {
  color: #10b981;
}

.modern-account-change.negative {
  color: #ef4444;
}

.modern-account-change .change-arrow {
  width: 12px;
  height: 12px;
  transform: rotate(-45deg);
}

.modern-account-change.negative .change-arrow {
  transform: rotate(45deg);
}
.modern-account-balance.debt {
  color: hsl(var(--foreground));
}
.modern-update-diff.debt {
  color: hsl(var(--foreground));
}
.modern-account-percent {
  font-size: 1.02rem;
  font-weight: 600;
  margin-top: 0.18rem;
  color: #27ae60;
}
.modern-account-percent.negative {
  color: #e74c3c;
}
.account-chevron {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 30px;
    height: 30px;
    background: none;
    box-shadow: none;
}
.modern-account-chevron {
    font-size: 1.45rem;
    display: flex;
    color: #666;
    align-self: center;
    align-items: center;
    justify-content: center;
    transition: transform 0.3s cubic-bezier(0.4,0,0.2,1);
    background: none !important;
    border-radius: 0 !important;
    width: 18px;
    box-shadow: none;
}
.modern-account-accordion-header.expanded .modern-account-chevron {
  transform: rotate(180deg);
  background: none;
}

/* Account sections by type - using same styling as home sections */
.account-type-section {
  margin-bottom: 1rem;
  cursor: pointer;
  position: relative;
  background-color: hsl(var(--card)) !important;
  border: 2px solid hsl(var(--border) / 0.5) !important;
  border-radius: 12px;
  box-shadow: none !important;
  padding: 0rem 2rem;
  overflow: hidden;
}

.account-type-section.expanded {
  border-color: hsl(var(--primary) / 0.3) !important;
  box-shadow: 0 0 0 1px hsl(var(--primary) / 0.1) !important;
}
.account-type-section .card-header {
  background-color: transparent;
  border-bottom: none;
  display: flex;
  justify-content: space-between;
  align-items: center;
  cursor: pointer;
  margin: 0 -1rem;
  /* padding: 1rem; */
  width: calc(100% + 2rem);
}
.account-type-section .section-title {
  font-size: 1.25rem;
  font-weight: 600;
  margin: 0;
  color: hsl(var(--foreground));
}
.account-type-section .card-body {
  padding: 0;
  display: block;
  margin-top: 0.5rem;
}
.account-type-section.collapsed .card-body {
  display: none;
}
.account-type-section .account-chevron {
  transition: transform 0.2s ease;
}
.account-type-section .modern-account-chevron {
  width: 18px;
  height: 18px;
}
.modern-account-accordion-body {
  padding: 0;
  background: none;
  border-radius: 0 0 18px 18px;
  box-shadow: none;
  max-height: 0;
  overflow: hidden;
  opacity: 0;
  transition: max-height 0.35s cubic-bezier(0.4,0,0.2,1), opacity 0.25s cubic-bezier(0.4,0,0.2,1);
}
.modern-account-accordion-body.expanded {
  max-height: 1000px;
  opacity: 1;
  transition: max-height 0.45s cubic-bezier(0.4,0,0.2,1), opacity 0.25s cubic-bezier(0.4,0,0.2,1);
}
.modern-account-updates {
  margin: 0;
  padding: 0;
}
.modern-account-update-row {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 0.75rem 1rem;
  margin-bottom: 0;
  background: #fff;
  border-radius: 0;
  box-shadow: none;
  width: 100%;
  font-size: 0.875rem;
  width: 100%;
  border-bottom: none;
}
.modern-account-updates .swipe-container {
  margin: 0 -1rem 0 -1rem;
  border-radius: 0;
  width: calc(100% + 2rem);
}
.modern-account-updates .swipe-container:last-child {
  margin-bottom: 0;
}
.modern-account-updates .swipe-container:last-child .swipe-content {
  border-bottom: none !important;
}
.modern-update-date {
  font-size: 0.875rem;
  color: #444;
  font-weight: 500;
  flex: 1 1 40%;
  align-self: center;
}
.modern-update-amount-stack {
  display: flex;
  flex-direction: column;
  align-items: flex-end;
  flex: 0 0 auto;
  min-width: 0;
  gap: 0.125rem;
  text-align: right;
}
.modern-update-diff {
  font-size: 0.875rem;
  font-weight: 600;
  color: #222;
  margin-left: 0;
  margin-bottom: 0;
}
.modern-update-percent {
  font-size: 0.75rem;
  color: #27ae60;
  font-weight: 500;
  margin-left: 0;
}
.modern-update-percent.negative {
  color: #e74c3c;
}
.modern-update-percent.neutral {
  color: #888;
}

        

    
        /* Modern Balance Card Styling */
        .modern-balance-card {
            flex-direction: row;
            justify-content: space-between;
            /* align-items: center; */
            padding: 20px;
            /* background-color: white; */
            border-radius: 16px;
            /* box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05); */
            margin-bottom: 20px;
        }
        
        .balance-date-modern {
            font-size: 1rem;
            font-weight: 500;
            color: hsl(var(--muted-foreground));
        }
        
        .balance-right-stack {
            display: flex;
            flex-direction: column;
        }
        
        .current-balance-modern {
            font-size: 1.8rem;
            font-weight: 700;
            color: hsl(var(--foreground));
            margin-bottom: 2px;
        }
        
        .balance-change-modern {
            font-size: 0.9rem;
            font-weight: 500;
            color: hsl(var(--muted-foreground));
        }
        
        .balance-change-modern.positive {
            color: hsl(var(--success));
        }
        
        .balance-change-modern.negative {
            color: #e74c3c;
        }
        
        /* Mobile responsiveness for modern balance card */
        @media (max-width: 480px) {
            .modern-balance-card {
                padding: 15px;
            }
            
            .current-balance-modern {
                font-size: 1.5rem;
            }
            
            .balance-date-modern {
                font-size: 0.9rem;
            }
        }

      

         
        .swipe-content {
            position: relative;
            align-items: center;
            justify-content: space-between;
            display: flex;
            background-color: hsl(var(--card));
            border-bottom: 1px solid hsl(var(--border));
            box-shadow: none;
            transform: translateX(0);
            transition: transform 0.2s ease;
            z-index: 2;
            /* border-radius: var(--radius); */
            width: 100%;
            /* will-change: transform; */
            overflow: hidden;
            position: relative;
            width: 100%;
            border-bottom: 1px solid hsl(var(--border));
        }
        
       

        .swipe-container.swiped .swipe-content {
            transform: translateX(-80px);
        }

        .swipe-container.deleting {
            animation: slide-out 0.3s ease-out forwards;
            height: 0;
            margin: 0;
            padding: 0;
            opacity: 0;
            pointer-events: none;
            overflow: hidden;
            transition: all 0.3s ease-out;
        }
        .swipe-container.deleting .swipe-content {
            transform: translateX(-100%);
            transition: transform 0.3s ease-out;
            opacity: 0;
        }

        @keyframes slide-out {
            0% {
                transform: translateX(0);
                opacity: 1;
                max-height: 100px;
                margin-bottom: 8px;
            }
            75% {
                transform: translateX(-100%);
                opacity: 0;
                max-height: 100px;
            }
            100% {
                transform: translateX(-100%);
                opacity: 0;
                max-height: 0px;
                margin: 0;
                padding: 0;
            }
        }
        
        /* Make sure balance items have the same swipe styling as expense items */
        .swipe-container .balance-item,
        .swipe-container .modern-balance-history-item {
            /* border: none; */
            box-shadow: none;
            width: 100%;
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 12px 16px;
        }

        .modern-balance-history-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
        }

        .balance-history-date {
            font-weight: 600;
            color: hsl(var(--foreground));
        }

        .balance-history-right {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
        }

        .balance-history-amount {
            font-size: 1.1rem;
            font-weight: 700;
            color: hsl(var(--foreground));
        }

        .balance-history-percent {
            font-size: 0.8rem;
            display: flex;
            align-items: center;
        }

        .balance-history-percent.positive {
            color: hsl(var(--success));
        }

        .balance-history-percent.negative {
            color: #e74c3c;
        }

        .balance-history-percent.neutral {
            color: #888;
        }

        .balance-arrow {
            margin-right: 4px;
        }

        .last-updated-note {
            font-size: 0.8rem; 
            color: #a2a2a2; 
            margin-top: 0; 
            margin-bottom: 10px; 
            text-align: left;  
            display: block; /* Always visible */
        }

    
    </style>
</head>
<body>
    <div id="app" class="app-container">
       

        <!-- Add this just above the screens wrapper -->
        <div class="app-header">
            <div id="user-avatar"></div>
            <div class="header-title" id="headerTitle">Home</div>
            <div class="header-actions">
                <button class="icon-btn" id="settingsButton" onclick="openSettings()" aria-label="Settings">
                    <i data-lucide="settings" class="w-6 h-6"></i>
                </button>
            </div>
        </div>
        
        <div class="content-container">
            <div class="screens-wrapper" id="screensWrapper">
                <!-- Screen 0: Home -->
                <div class="screen">
                    <!-- Transactions Section -->
                    <div class="card home-section" onclick="goToScreen(1); scrollToTransactions()">
                        <div class="card-header home-section-header">
                            <div class="section-header-left">
                                <h3 class="section-title">Transactions</h3>
                                <div class="section-subtitle">Most recent</div>
                            </div>
                            <div class="section-header-right">
                                <div class="section-subtitle">View all <i data-lucide="chevron-right" class="w-4 h-4 inline"></i></div>
                            </div>
                        </div>
                        <div class="card-content">
                            <div id="homeTransactionsList">Loading...</div>
                        </div>
                    </div>
                    
                    <!-- Cashflow Section -->
                    <div class="card home-section">
                        <div class="card-header">
                            <div class="home-section-header">
                                <h3 class="section-title">Spending</h3>
                                <div class="section-subtitle" id="cashflowSubtitle">This month vs. average month</div>
                            </div>
                            <div class="cashflow-menu-container">
                                <button class="dot-menu-btn" onclick="toggleCashflowDropdown()" id="cashflowMenuBtn">
                                    <i data-lucide="more-horizontal" class="w-5 h-5"></i>
                                </button>
                                <div class="dropdown-menu dropdown-right" id="cashflowDropdown">
                                    <div class="dropdown-header">Select date range</div>
                                    <div class="dropdown-item" onclick="updateCashflowRange('week')">This week vs. last week</div>
                                    <div class="dropdown-item" onclick="updateCashflowRange('month')">This month vs. last month</div>
                                    <div class="dropdown-item" onclick="updateCashflowRange('year')">This month vs. last year</div>
                                    <div class="dropdown-item active" onclick="updateCashflowRange('average')">This month vs. average month</div>
                                    <div class="dropdown-item" onclick="updateCashflowRange('ytd')">This year vs. last year</div>
                                </div>
                            </div>
                        </div>
                        <div class="card-content">
                            <div class="chart-container full-width-chart">
                                <canvas id="homeCashflowCanvas"></canvas>
                                <div class="chart-overlay" id="homeCashflowOverlay">
                                    <div class="chart-crosshair" id="homeCashflowCrosshair"></div>
                                </div>
                            </div>
                            
                            <!-- Chart Legend -->
                            <div class="chart-legend" id="cashflowLegend">
                                <div class="legend-item">
                                    <div class="legend-color" style="background: linear-gradient(to bottom, #8b5cf6, #7c3aed);"></div>
                                    <span class="legend-label">This month</span>
                                </div>
                                <div class="legend-item">
                                    <div class="legend-color" style="background: #d1d5db;"></div>
                                    <span class="legend-label">Last month</span>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Net Worth Section -->
                    <div class="card home-section" onclick="handleNetWorthCardClick(event)">
                        <div class="card-header home-section-header">
                            <div class="section-header-left">
                                <h3 class="section-title" id="netWorthTitle">$68,502 net worth</h3>
                                <div class="section-change" id="netWorthChange">
                                    <i data-lucide="arrow-up" class="w-4 h-4 inline"></i>
                                    <span>$210.32 (0.3%)</span>
                                </div>
                                <div class="section-subtitle" id="netWorthSubtitle">All time</div>
                            </div>
                            <div class="section-header-right">
                                <div class="cashflow-menu-container">
                                    <button class="dot-menu-btn" onclick="toggleNetWorthDropdown()" id="netWorthMenuBtn">
                                        <i data-lucide="more-horizontal" class="w-5 h-5"></i>
                                    </button>
                                    <div class="dropdown-menu dropdown-right" id="netWorthDropdown">
                                        <div class="dropdown-header">Select date range</div>
                                        <div class="dropdown-item" onclick="updateNetWorthRange('1m')">1 month</div>
                                        <div class="dropdown-item" onclick="updateNetWorthRange('3m')">3 months</div>
                                        <div class="dropdown-item" onclick="updateNetWorthRange('6m')">6 months</div>
                                        <div class="dropdown-item" onclick="updateNetWorthRange('ytd')">Year to date</div>
                                        <div class="dropdown-item" onclick="updateNetWorthRange('1y')">1 year</div>
                                        <div class="dropdown-item active" onclick="updateNetWorthRange('all')">All time</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="card-content">
                            <div class="chart-container full-width-chart">
                                <canvas id="homeNetWorthCanvas"></canvas>
                                <div class="chart-overlay" id="homeNetWorthOverlay">
                                    <div class="chart-crosshair" id="homeNetWorthCrosshair"></div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Screen 1: Cashflow (formerly Tracking) -->
                <div class="screen">
                    <!-- Budget Display Section -->
                    <div class="card home-section" id="budgetDisplay">
                        <div class="card-header">
                            <div class="home-section-header">
                                <div class="section-subtitle" style="margin-top: 0.7rem; margin-bottom: 0.7rem; text-align: center;">Monthly Overview</div>
                            </div>
                        </div>
                        <div class="card-content">
                            <div class="chart-carousel" id="chartCarousel">
                                <div class="chart-slide active" id="monthlyChartSlide">
                                    <div class="monthly-spending-chart" id="monthlySpendingChart">
                                        <!-- Monthly bars will be generated dynamically -->
                                    </div>
                                    <div id="selectedMonthTotal" class="selected-month-total">
                                        <!-- Total for selected month will be displayed here -->
                                    </div>
                                </div>
                                <div class="chart-slide" id="categoryChartSlide">
                                    <div class="category-spending-chart" id="categorySpendingChart">
                                        <!-- Category bars will be generated dynamically -->
                                    </div>
                                    <div id="selectedCategoryTotal" class="selected-month-total">
                                        <!-- Total for selected category will be displayed here -->
                                    </div>
                                </div>
                            </div>
                            <div class="chart-dots" id="chartDots">
                                <div class="dot active" onclick="switchToChart(0)"></div>
                                <div class="dot" onclick="switchToChart(1)"></div>
                            </div>
                        </div>
                    </div>
                    

                    
                    <!-- Add Expense -->
                    <div class="card expense-input" id="expenseInput" style="display: none;">
                        <h3 class="card-title mb-4" id="expenseInputTitle">Add Expense</h3>
                        
                        <!-- Date picker for month mode -->
                        <div class="form-group" id="datePickerGroup" style="display: none;">
                            <label class="form-label" for="expenseDate">Date</label>
                            <input type="date" id="expenseDate" class="form-input">
                        </div>
                        <div class="input-row">
                            <div class="form-group">
                                <label class="form-label" for="expenseAmount">Amount ($)</label>
                                <input type="number" id="expenseAmount" class="form-input" placeholder="0.00" step="0.01">
                            </div>
                            <div class="form-group">
                                <label class="form-label" for="expenseCategory">Category</label>
                                <select id="expenseCategory" class="form-input">
                                    <option value="groceries">Groceries</option>
                                    <option value="transportation">Transportation</option>
                                    <option value="dining">Dining Out</option>
                                    <option value="entertainment">Entertainment</option>
                                    <option value="personal">Personal Care</option>
                                    <option value="clothing">Clothing</option>
                                    <option value="health">Health/Fitness</option>
                                    <option value="subscriptions">Subscriptions</option>
                                    <option value="other">Other</option>
                                </select>
                            </div>
                        </div>
                        
                        <div class="form-group">
                            <label class="form-label" for="expenseDescription">Description (optional)</label>
                            <input type="text" id="expenseDescription" class="form-input" placeholder="What did you buy?">
                        </div>
                        
                        <button class="add-btn" onclick="addExpense()">Add Expense</button>
                    </div>
                    
                    <!-- Sticky Container -->
                    <div class="sticky-container">
                        <!-- Sticky Controls Section -->
                        <div class="sticky-controls-section" id="stickyControlsSection">
                            <div class="sticky-controls-content">
                                <div class="section-header-left">
                                    <h3 class="section-title" id="expensesListTitle">Transactions</h3>
                                    <div id="budgetTitleContainer"></div>
                                </div>
                                <div class="section-header-right">
                                    <div id="timeRangeContextMenu"></div>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Period Expenses -->
                        <div class="expenses-list-card">
                            <div class="expenses-list" id="expensesList">
                                <div style="text-align: center; color: #7f8c8d; padding: 20px;">
                                    No transactions recorded this week
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Savings Accounts Section - Moved to Save Screen -->
                    <!-- <div class="card savings-accounts-section" id="savingsSection" style="display: none;">
                        <div class="section-header">
                            <h3 class="text-lg font-semibold">Account Balances</h3>
                            <button class="btn btn-outline btn-sm" onclick="showAccountManagementModal()">
                                <i data-lucide="settings" class="w-4 h-4 mr-2"></i>
                                Accounts
                            </button>
                        </div>
                        
                        <div class="account-balance-display stat-card">
                            <div class="current-balance" id="totalAccountBalance">$0.00</div>
                            <div class="balance-change" id="totalBalanceChange">Total across all accounts this month</div>
                        </div>
                        
                        <div class="balance-history" id="balanceHistory">
                            <div style="text-align: center; color: #7f8c8d; padding: 20px;">
                                No balance records this month
                            </div>
                        </div>
                    </div> -->
                    
                    <!-- Quick Action Cards -->
                    <div class="quick-actions">
                        <!-- Add Expense moved to header next to time range dropdown -->
                    </div>
                </div>
                
                <!-- Screen 2: Accounts (formerly Save) -->
                <div class="screen">
                    
                    
                    <!-- Sticky Period Selector for Save Screen -->
                    <div class="period-selector-sticky" id="savePeriodSelectorSticky" style="display: none;">
                        <!-- Period Selector Header with Toggle on Left, Dropdowns on Right -->
                        <div class="period-selector-header">
                            <div class="card-header" style="flex-direction: row; align-items: center; justify-content: space-between; padding-bottom: 0;">
                                <div class="period-title">July 2025</div>
                                
                                <!-- Icon-only Today/Month Toggle - Only this is included -->
                                <div class="period-icon-toggle">
                                    <button onclick="setSavePeriodMode('today')" class="period-icon-btn active" id="saveTodayBtnIcon" title="Today View">
                                        <i data-lucide="sun" class="w-4 h-4"></i>
                                    </button>
                                    <button onclick="setSavePeriodMode('month')" class="period-icon-btn" id="saveMonthBtnIcon" title="Month View">
                                        <i data-lucide="calendar" class="w-4 h-4"></i>
                                    </button>
                                </div>
                            </div>
                            
                            <!-- Original Toggle (Hidden) -->
                            <div class="period-mode-toggle-compact" style="display: none;">
                                <button onclick="setSavePeriodMode('today')" class="btn btn-ghost btn-sm period-mode-btn-compact active" id="saveTodayBtnCompact" title="Today View">
                                    <i data-lucide="sun" class="w-4 h-4 mr-2"></i>
                                    <span>Today</span>
                                </button>
                                <button onclick="setSavePeriodMode('month')" class="btn btn-ghost btn-sm period-mode-btn-compact" id="saveMonthBtnCompact" title="Month View">
                                    <i data-lucide="calendar" class="w-4 h-4 mr-2"></i>
                                    <span>Month</span>
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Daily/Monthly Saving Target Display -->
                    <div class="card" id="saveTargetDisplay" style="display: none;">
                        <div class="card-header" style="text-align:center;">
                            <div id="saveTargetTitleContainer" style="text-align:left;"></div>
                        </div>
                        <div class="card-content">
                            <div class="stat-card saving-target-card">
                                <div>
                                    <div class="text-sm text-muted-foreground">Saving Target</div>
                                    <div class="text-2xl font-semibold" id="saveTargetAmount">$144.43</div>
                                    <div class="change-indicator" id="saveTargetChange">
                                        <span class="change-arrow"></span>
                                        <span class="change-amount">Monthly</span>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="stat-card save-progress-card">
                                <div>
                                    <div class="text-sm text-muted-foreground" id="saveProgressLabel">Progress This Month</div>
                                    <div class="text-2xl font-semibold" id="saveProgressAmount">$0.00</div>
                                    <div class="change-indicator" id="saveProgressChange">
                                        <span class="change-arrow"></span>
                                        <span class="change-amount">On Track</span>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>

                    
                    <!-- Savings Accounts Section -->
                    <div class="savings-accounts-section" id="saveSavingsSection">
                        <!-- Net Worth Chart -->
                        <div class="card home-section" onclick="handleAccountsNetWorthCardClick(event)">
                            <div class="card-header home-section-header">
                                <div class="section-header-left">
                                    <h3 class="section-title" id="accountsNetWorthTitle">$85,000 total assets</h3>
                                    <div class="section-change" id="accountsNetWorthChange">
                                        <i data-lucide="arrow-up" class="w-4 h-4 inline"></i>
                                        <span>$210.32 (0.3%)</span>
                                    </div>
                                    <div class="section-subtitle" id="accountsNetWorthSubtitle">All time</div>
                                </div>
                                <div class="section-header-right">
                                    <div class="cashflow-menu-container">
                                        <button class="dot-menu-btn" onclick="toggleAccountsNetWorthDropdown()" id="accountsNetWorthMenuBtn">
                                            <i data-lucide="more-horizontal" class="w-5 h-5"></i>
                                        </button>
                                        <div class="dropdown-menu dropdown-right" id="accountsNetWorthDropdown">
                                            <div class="dropdown-header">Select date range</div>
                                            <div class="dropdown-item" onclick="updateAccountsNetWorthRange('1m', event)">1 month</div>
                                            <div class="dropdown-item" onclick="updateAccountsNetWorthRange('3m', event)">3 months</div>
                                            <div class="dropdown-item" onclick="updateAccountsNetWorthRange('6m', event)">6 months</div>
                                            <div class="dropdown-item" onclick="updateAccountsNetWorthRange('ytd', event)">Year to date</div>
                                            <div class="dropdown-item" onclick="updateAccountsNetWorthRange('1y', event)">1 year</div>
                                            <div class="dropdown-item active" onclick="updateAccountsNetWorthRange('all', event)">All time</div>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            <div class="card-content">
                                <div class="chart-container" style="position: relative; height: 200px;">
                                    <canvas id="accountsNetWorthCanvas"></canvas>
                                    <div class="chart-overlay" id="accountsNetWorthOverlay">
                                        <div class="chart-crosshair" id="accountsNetWorthCrosshair"></div>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <!-- Accounts Header -->
                        <div class="account-header-section">
                            <div class="account-title-info">
                                <h3 class="section-title" style="margin-bottom: 0.25rem;">Accounts</h3>
                            </div>
                            <div class="cashflow-menu-container">
                                <button class="dot-menu-btn" onclick="toggleAccountsDropdown()" id="accountsMenuBtn">
                                    <i data-lucide="more-horizontal" class="w-5 h-5"></i>
                                </button>
                                <div class="dropdown-menu dropdown-right" id="accountsDropdown">
                                    <div class="dropdown-item" onclick="showAccountManagementModal()">
                                        <i data-lucide="settings" class="w-4 h-4 mr-2"></i>
                                        Manage Accounts
                                    </div>
                                    <div class="dropdown-item" onclick="connectPlaidAccount()">
                                        <i data-lucide="plus" class="w-4 h-4 mr-2"></i>
                                        Connect Account
                                    </div>
                                    <div class="dropdown-item" onclick="showBalanceSlideOut()">
                                        <i data-lucide="wallet" class="w-4 h-4 mr-2"></i>
                                        Add Balance
                                    </div>
                                </div>
                            </div>
                        </div>
                        <!-- New Accounts List -->
                        <div class="accounts-list" id="accountsList">
                            <!-- Account groups will be dynamically populated here -->
                        </div>
                    </div>
                    
                    <!-- Quick Action Cards for Save Screen -->
                    <div class="quick-actions">
                        <div class="quick-action-card" onclick="showBalanceSlideOut()" id="saveBalanceActionCard">
                            <div class="quick-action-title">Add Balance</div>
                            <div class="quick-action-icon">
                                <i data-lucide="arrow-right" class="w-6 h-6"></i>
                            </div>
                        </div>
                    </div>
                </div>
                
                <!-- Screen 3: Dashboard (formerly Reports) -->
                <div class="screen">
                    <!-- Weekly Summary -->
                    <div class="card weekly-summary">
                        <h3>This Week's Financial Health</h3>
                        <div class="combined-stats">
                            <div class="combined-stat">
                                <div class="combined-stat-value" id="weeklySpent">$0</div>
                                <div class="combined-stat-label">Spent</div>
                            </div>
                            <div class="stat-separator"></div>
                            <div class="combined-stat">
                                <div class="combined-stat-value" id="weeklyRemaining">$286</div>
                                <div class="combined-stat-label">Remaining</div>
                            </div>
                        </div>
                        <div class="weekly-stats" style="margin-top: 20px;">
                            <div class="weekly-stat">
                                <div class="weekly-stat-value" id="projectedMonthlySavings">$0</div>
                                <div class="weekly-stat-label">Projected Savings</div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Monthly Stats -->
                    <div class="stats-grid">
                        <div class="card stat-card">
                            <div class="stat-label" id="monthSpentLabel">July Spent</div>
                            <div class="stat-value" id="monthlySpent">$0</div>
                            <div class="stat-subtitle" id="monthSpentSubtitle">of $1,239 budget</div>
                        </div>
                        <div class="card stat-card">
                            <div class="stat-label">Daily Burn Rate</div>
                            <div class="stat-value" id="dailyBurnRate">$0</div>
                            <div class="stat-subtitle" id="burnRateStatus">vs $41.30 target</div>
                        </div>
                        <div class="card stat-card">
                            <div class="stat-label">Days Left in Budget</div>
                            <div class="stat-value" id="daysRemaining">--</div>
                            <div class="stat-subtitle" id="daysRemainingSubtitle">at current pace</div>
                        </div>
                        <div class="card stat-card">
                            <div class="stat-label">Savings Rate</div>
                            <div class="stat-value positive" id="savingsRate">--%</div>
                            <div class="stat-subtitle" id="savingsRateSubtitle">of income saved</div>
                        </div>
                    </div>
                    
                    <!-- Wealthsimple-Style Chart -->
                    <div class="chart-container-wrapper">
                        <!-- Chart Header with Two Rows: Savings and Spending -->
                        <div class="chart-header">
                             <!-- Date display that shows when chart is interacted with -->
                            <div class="chart-date-display" id="chartDateDisplay">
                                <span class="chart-selected-date">July 6, 2025</span>
                            </div>
                            <!-- Savings Row (Black) -->
                            <div class="chart-row savings-row">
                                <div class="chart-subtitle" id="chartSubtitle">Saved</div>
                                <div class="chart-main-value" id="chartMainValue">$0.00</div>
                                <div class="chart-growth" id="chartGrowth">+$0.00 (+0%)</div>
                            </div>
                            
                            <!-- Spending Row (Gray) -->
                            <div class="chart-row spending-row">
                                <div class="chart-subtitle spending" id="chartSpendingSubtitle">Spent</div>
                                <div class="chart-main-value spending" id="chartSpendingValue">$0.00</div>
                            </div>
                        </div>
                        
                        <!-- Chart Carousel Container -->
                        <div class="chart-carousel-container">
                            <div class="chart-carousel" id="chartCarousel">
                                <!-- Chart with Overlay -->
                                <div class="chart-slide active" id="spendingChartSlide">
                                    <div class="card chart-container full-width-chart">
                                        <canvas id="spendingChart"></canvas>
                                        <div class="chart-overlay" id="chartOverlay">
                                            <div class="chart-crosshair" id="chartCrosshair"></div>
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- Category Spending Chart -->
                                <div class="chart-slide" id="categoryChartSlide">
                                    <div class="card chart-container chart-with-header full-width-chart">
                                        <div class="chart-header">
                                            <h3>Top Categories</h3>
                                            <div class="chart-time-range" id="categoryChartTimeRange"></div>
                                        </div>
                                        <div class="chart-canvas-wrapper">
                                            <canvas id="categoryChart"></canvas>
                                        </div>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Chart Navigation Dots -->
                            <div class="chart-dots" id="chartDots">
                                <div class="dot active" onclick="console.log('Dot 0 clicked!'); showChart(0)"></div>
                                <div class="dot" onclick="console.log('Dot 1 clicked!'); showChart(1)"></div>
                            </div>
                        </div>
                        
                        <!-- Chart Period Selector at Bottom -->
                        <div class="chart-period-selector-bottom">
                            <button class="chart-period-btn-wealthsimple" onclick="setChartPeriod('1M')" id="period1M">1M</button>
                            <button class="chart-period-btn-wealthsimple" onclick="setChartPeriod('3M')" id="period3M">3M</button>
                            <button class="chart-period-btn-wealthsimple" onclick="setChartPeriod('6M')" id="period6M">6M</button>
                            <button class="chart-period-btn-wealthsimple active" onclick="setChartPeriod('YTD')" id="periodYTD">YTD</button>
                            <button class="chart-period-btn-wealthsimple" onclick="setChartPeriod('1Y')" id="period1Y">1Y</button>
                            <button class="chart-period-btn-wealthsimple" onclick="setChartPeriod('ALL')" id="periodALL">ALL</button>
                        </div>
                    </div>
                </div>
                

            </div>
        </div>
        
        
        <div class="bottom-nav">
            <div class="nav-item active" onclick="goToScreen(0)">
                <div class="icon">
                    <i data-lucide="home" class="w-6 h-6"></i>
                </div>
                <div class="label">Home</div>
            </div>
            <div class="nav-item" onclick="goToScreen(1)">
                <div class="icon">
                    <i data-lucide="trending-up" class="w-6 h-6"></i>
                </div>
                <div class="label">Cashflow</div>
            </div>
            <div class="nav-item" onclick="goToScreen(2)">
                <div class="icon">
                    <i data-lucide="wallet" class="w-6 h-6"></i>
                </div>
                <div class="label">Accounts</div>
            </div>
            <div class="nav-item" onclick="goToScreen(3)">
                <div class="icon">
                    <i data-lucide="bar-chart-3" class="w-6 h-6"></i>
                </div>
                <div class="label">Dashboard</div>
            </div>
        </div>
    </div>

    <!-- Account Detail Screen -->
    <div class="account-detail-overlay" id="accountDetailOverlay">
        <div class="account-detail-screen" id="accountDetailScreen">
            <!-- Header with back button -->
            <div class="account-detail-header">
                <button class="account-detail-back" onclick="closeAccountDetail()" aria-label="Back">
                    <i data-lucide="arrow-left" class="w-6 h-6"></i>
                </button>
                <div class="account-detail-title-container">
                    <h2 class="account-detail-title" id="accountDetailTitle">Account Name</h2>
                    <div class="account-detail-balance" id="accountDetailBalance">$0.00</div>
                </div>
            </div>

            <!-- Account Balance Chart -->
            <div class="card account-detail-chart-card">
                <div class="card-content">
                    <div class="chart-container" style="position: relative; height: 200px;">
                        <canvas id="accountDetailCanvas"></canvas>
                        <div class="chart-overlay" id="accountDetailChartOverlay">
                            <div class="chart-crosshair" id="accountDetailCrosshair"></div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Activity Section -->
            <div class="account-detail-activity">
                <div class="card-header">
                    <div class="section-header">
                        <div class="section-header-left">
                            <h3 class="section-title">Activity</h3>
                            <div class="section-subtitle" id="accountDetailActivitySubtitle">This month</div>
                        </div>
                        <div class="section-header-right">
                            <div class="cashflow-menu-container">
                                <button class="dot-menu-btn" onclick="toggleAccountDetailTimeRange()" id="accountDetailTimeRangeBtn">
                                    <i data-lucide="more-horizontal" class="w-5 h-5"></i>
                                </button>
                                <div class="dropdown-menu dropdown-right" id="accountDetailTimeRangeDropdown">
                                    <div class="dropdown-header">Select time range</div>
                                    <div class="dropdown-item" onclick="updateAccountDetailTimeRange('week', event)">This week</div>
                                    <div class="dropdown-item active" onclick="updateAccountDetailTimeRange('month', event)">This month</div>
                                    <div class="dropdown-item" onclick="updateAccountDetailTimeRange('quarter', event)">This quarter</div>
                                    <div class="dropdown-item" onclick="updateAccountDetailTimeRange('year', event)">This year</div>
                                    <div class="dropdown-item" onclick="updateAccountDetailTimeRange('all', event)">All time</div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Transaction List -->
            <div class="account-detail-transactions">
                <div class="expenses-list" id="accountDetailTransactionsList">
                    <div style="text-align: center; color: #7f8c8d; padding: 20px;">
                        No transactions found
                    </div>
                </div>
            </div>
        </div>
    </div>

     <!-- Settings Slide-out Panel -->
     <div class="settings-overlay" id="settingsOverlay">
        <div class="settings-panel" id="settingsPanel">
            <div class="settings-header">
                <button class="settings-back" onclick="closeSettings()" aria-label="Back">
                    <i data-lucide="arrow-left" class="w-6 h-6"></i>
                </button>
                <h2 class="settings-title">Settings</h2>
                <div style="width: 40px;"></div> <!-- Spacer for centering -->
            </div>

            <div class="settings-content" id="settingsMenu">
                <ul class="settings-menu-list">
                    <li class="settings-menu-item" onclick="openBudgetSetup()">
                      <span class="settings-menu-icon"><i data-lucide="wallet" class="w-5 h-5"></i></span>
                      <span class="settings-menu-label">Setup Budget</span>
                      <span class="settings-menu-arrow"><i data-lucide="chevron-right" class="w-5 h-5"></i></span>
                    </li>
                    <li class="settings-menu-item" onclick="openSupport()">
                        <span class="settings-menu-icon"><i data-lucide="headphones" class="w-5 h-5"></i></span>
                        <span class="settings-menu-label">Support</span>
                        <span class="settings-menu-arrow"><i data-lucide="chevron-right" class="w-5 h-5"></i></span>
                    </li>
                    <li class="settings-menu-item settings-menu-btn-item">
                      <div class="quick-action-card" style="width:100%;box-sizing:border-box;" onclick="loadSampleBudget()">
                        <span class="quick-action-icon"><i data-lucide="database" class="w-5 h-5"></i></span>
                        <span class="quick-action-title">Load Sample Budget</span>
                      </div>
                    </li>
                    <li class="settings-menu-item settings-menu-btn-item">
                      <div class="quick-action-card" style="width:100%;box-sizing:border-box;" onclick="clearAllData()">
                        <span class="quick-action-icon"><i data-lucide="trash-2" class="w-5 h-5"></i></span>
                        <span class="quick-action-title">Clear All Data</span>
                      </div>
                    </li>
                  </ul>
            </div>
            <div class="settings-content" id="settingsForm" style="display:none;">
                <p class="text-center text-muted-foreground">Budget setup has been moved to its own page. Click "Setup Budget" to access it.</p>
            </div>

        </div>
    </div>
    
    <!-- Budget Setup Slide-out -->
    <div class="settings-overlay" id="budgetOverlay">
        <div class="budget-panel" id="budgetPanel">
            <div class="settings-header">
                <button class="settings-back" onclick="closeBudgetSetup()" aria-label="Back">
                    <i data-lucide="arrow-left" class="w-6 h-6"></i>
                </button>
                <h2 class="settings-title">Budget Setup</h2>
                <div style="width: 40px;"></div> <!-- Spacer for centering -->
            </div>

            <div class="settings-content">
                <div class="card">
                    <div class="card-header">
                        <h3 class="text-xl font-semibold">Income & Taxes</h3>
                    </div>
                    <div class="card-content">
                        <!-- Tax Calculator Section -->
                        <div class="tax-calculator-section">
                            <div class="tax-calculator-header">
                                <h4 class="text-md font-semibold mb-3">Tax Calculator</h4>
                                <p class="text-sm text-muted-foreground mb-4">Enter your gross yearly income and province to auto-calculate taxes (2024 rates)</p>
                            </div>
                            
                            <div class="tax-calculator-inputs">
                                <div class="form-group">
                                    <label class="form-label" for="budgetGrossYearlyIncome">Gross Yearly Income</label>
                                    <input type="number" class="form-input" id="budgetGrossYearlyIncome" placeholder="140000" min="0" step="1000">
                                </div>
                                
                                <div class="form-group">
                                    <label class="form-label" for="budgetProvinceSelect">Province/Territory</label>
                                    <div class="select-container">
                                        <div class="select-trigger" onclick="toggleSlideOutSelect('budgetProvince')" id="budgetProvinceTrigger">
                                            <span id="budgetProvinceValue">Ontario</span>
                                            <i data-lucide="chevron-down" class="w-4 h-4"></i>
                                        </div>
                                        <div class="select-content" id="budgetProvinceContent">
                                            <div class="select-item selected" data-value="ON">Ontario</div>
                                            <div class="select-item" data-value="BC">British Columbia</div>
                                            <div class="select-item" data-value="AB">Alberta</div>
                                            <div class="select-item" data-value="SK">Saskatchewan</div>
                                            <div class="select-item" data-value="MB">Manitoba</div>
                                            <div class="select-item" data-value="QC">Quebec</div>
                                            <div class="select-item" data-value="NB">New Brunswick</div>
                                            <div class="select-item" data-value="NS">Nova Scotia</div>
                                            <div class="select-item" data-value="PE">Prince Edward Island</div>
                                            <div class="select-item" data-value="NL">Newfoundland and Labrador</div>
                                            <div class="select-item" data-value="NT">Northwest Territories</div>
                                            <div class="select-item" data-value="NU">Nunavut</div>
                                            <div class="select-item" data-value="YT">Yukon</div>
                                        </div>
                                    </div>
                                </div>
                                
                                <button type="button" class="calculate-btn" onclick="calculateBudgetTaxes()">Calculate Taxes</button>
                            </div>
                            
                            <!-- Manual Override Section -->
                            <div class="manual-override-section">
                                <div class="accordion-header" onclick="toggleAccordion('budgetManualOverride')">
                                    <h4 class="text-md font-semibold">Manual Override (Optional)</h4>
                                    <i data-lucide="chevron-down" class="accordion-icon" id="budgetManualOverrideIcon"></i>
                                </div>
                                <div class="accordion-content" id="budgetManualOverrideContent">
                                    <p class="text-sm text-muted-foreground mb-4">You can manually adjust the calculated values below if needed</p>
                                    
                                    <div class="form-group">
                                        <label class="form-label" for="budgetGrossIncome">Gross Monthly Income</label>
                                        <input type="number" class="form-input" id="budgetGrossIncome" placeholder="11667" min="0" step="0.01">
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label" for="budgetFederalTax">Federal Tax</label>
                                        <input type="number" class="form-input" id="budgetFederalTax" placeholder="2500" min="0" step="0.01">
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label" for="budgetProvincialTax">Provincial Tax</label>
                                        <input type="number" class="form-input" id="budgetProvincialTax" placeholder="750" min="0" step="0.01">
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label" for="budgetCppEi">CPP/EI</label>
                                        <input type="number" class="form-input" id="budgetCppEi" placeholder="333" min="0" step="0.01">
                                    </div>
                                    <div class="form-group">
                                        <label class="form-label" for="budgetNetIncome">Net Monthly Income</label>
                                        <input type="number" class="form-input" id="budgetNetIncome" placeholder="8084" min="0" step="0.01">
                                        <div class="form-help">Auto-calculated, but you can override if needed.</div>
                                    </div>
                                </div>
                            </div>
                            
                            <div class="form-divider"></div>
                            
                            <div class="tax-results" id="budgetTaxResults" style="display: none;">
                                <div class="tax-summary">
                                    <div class="tax-item">
                                        <div class="tax-label">Monthly Gross Income</div>
                                        <div class="tax-value" id="budgetMonthlyGrossResult">$0.00</div>
                                    </div>
                                    <div class="tax-item">
                                        <div class="tax-label">Federal Tax (Monthly)</div>
                                        <div class="tax-value" id="budgetFederalTaxResult">$0.00</div>
                                    </div>
                                    <div class="tax-item">
                                        <div class="tax-label">Provincial Tax (Monthly)</div>
                                        <div class="tax-value" id="budgetProvincialTaxResult">$0.00</div>
                                    </div>
                                    <div class="tax-item">
                                        <div class="tax-label">CPP/EI (Monthly)</div>
                                        <div class="tax-value" id="budgetCppEiResult">$0.00</div>
                                    </div>
                                    <div class="tax-item total">
                                        <div class="tax-label">Net Monthly Income</div>
                                        <div class="tax-value" id="budgetNetIncomeResult">$0.00</div>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <div class="card">
                    <div class="card-header">
                        <h3 class="text-xl font-semibold">Savings Goal</h3>
                    </div>
                    <div class="card-content">
                        <div class="form-group">
                            <label class="form-label" for="budgetAnnualSavingsGoal">Annual Savings Goal</label>
                            <input type="number" class="form-input" id="budgetAnnualSavingsGoal" placeholder="52000" min="0" step="0.01">
                        </div>
                        <div class="form-group">
                            <label class="form-label" for="budgetMonthlySavingsTarget">Monthly Savings Target</label>
                            <input type="number" class="form-input" id="budgetMonthlySavingsTarget" placeholder="4333" min="0" step="0.01" readonly>
                            <div class="form-help">Auto-calculated from annual savings goal.</div>
                        </div>
                    </div>
                </div>
                
                <div class="card">
                    <div class="card-header">
                        <h3 class="text-xl font-semibold">Expenses</h3>
                    </div>
                    <div class="card-content">
                        <div class="form-group">
                            <label class="form-label" for="budgetFixedExpenses">Monthly Fixed Expenses</label>
                            <input type="number" class="form-input" id="budgetFixedExpenses" placeholder="2450" min="0" step="0.01">
                        </div>
                        <div class="form-group">
                            <label class="form-label" for="budgetEssentialExpenses">Monthly Essential Expenses</label>
                            <input type="number" class="form-input" id="budgetEssentialExpenses" placeholder="750" min="0" step="0.01">
                        </div>
                        <div class="form-group">
                            <label class="form-label" for="budgetDiscretionaryExpenses">Monthly Discretionary Expenses</label>
                            <input type="number" class="form-input" id="budgetDiscretionaryExpenses" placeholder="501" min="0" step="0.01">
                        </div>
                    </div>
                </div>
                
                <div class="card">
                    <div class="card-header">
                        <h3 class="text-xl font-semibold">Budget Summary</h3>
                    </div>
                    <div class="card-content">
                        <div class="budget-summary">
                            <div class="budget-item">
                                <div class="budget-label">Remaining Budget</div>
                                <div class="budget-value" id="budgetRemainingBudgetSummary">$0.00</div>
                            </div>
                            <div class="budget-item">
                                <div class="budget-label">Savings Rate</div>
                                <div class="budget-value" id="budgetSavingsRateSummary">0%</div>
                            </div>
                            <div class="budget-item">
                                <div class="budget-label">Validation</div>
                                <div class="budget-value" id="budgetValidationSummary">-</div>
                            </div>
                        </div>
                    </div>
                </div>
                
                <button type="button" class="add-btn" onclick="saveBudgetSettings()">Save Budget</button>
            </div>
        </div>
    </div>
    
    <!-- Support Page Slide-out -->
    <div class="settings-overlay" id="supportOverlay">
        <div class="budget-panel" id="supportPanel">
            <div class="settings-header">
                <button class="settings-back" onclick="closeSupport()" aria-label="Back">
                    <i data-lucide="arrow-left" class="w-6 h-6"></i>
                </button>
                <h2 class="settings-title">Support</h2>
                <div style="width: 40px;"></div> <!-- Spacer for centering -->
            </div>

            <div class="settings-content">
                <div class="card">
                    <div class="card-header">
                        <h3 class="text-lg font-semibold">Contact Us</h3>
                    </div>
                    <div class="card-content">
                        <p class="text-sm text-muted-foreground mb-4">Need help? Send us a message and we'll get back to you as soon as possible.</p>
                        
                        <div class="form-group">
                            <label class="form-label" for="supportTitle">Subject</label>
                            <input type="text" class="form-input" id="supportTitle" placeholder="Brief description of your issue">
                        </div>
                        
                        <div class="form-group">
                            <label class="form-label" for="supportDescription">Message</label>
                            <textarea class="form-input" id="supportDescription" rows="6" placeholder="Please describe your issue or question in detail..."></textarea>
                        </div>
                        
                        <button type="button" class="add-btn" onclick="sendSupportEmail()">Send Message</button>
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <!-- Expense Slide-out -->
    <div class="slide-out-overlay" id="expenseSlideOut">
        <div class="slide-out-content">
            <div class="slide-out-header">
                <h3 class="slide-out-title">Add Expense</h3>
                <button class="slide-out-close" onclick="hideExpenseSlideOut()">
                    <i data-lucide="x" class="w-5 h-5"></i>
                </button>
            </div>
            
            <div class="slide-out-form">
                <!-- Date picker for month mode -->
                <div class="form-group" id="slideOutDatePickerGroup" style="display: none;">
                    <label class="form-label" for="slideOutExpenseDate">Date</label>
                    <div class="custom-datepicker" id="expenseCustomDatepicker">
                        <div class="datepicker-trigger" onclick="toggleDatepicker('expenseCustomDatepicker')" 
                             role="button" tabindex="0" aria-label="Select date" aria-expanded="false">
                            <span class="datepicker-value" id="expenseCustomDatepickerValue">Select date</span>
                            <i data-lucide="calendar" class="w-4 h-4"></i>
                        </div>
                        <div class="datepicker-popup" id="expenseCustomDatepickerPopup">
                            <div class="datepicker-header">
                                <button type="button" class="datepicker-nav" onclick="navigateMonth('expenseCustomDatepicker', -1)">
                                    <i data-lucide="chevron-left" class="w-4 h-4"></i>
                                </button>
                                <div class="datepicker-month-year" id="expenseCustomDatepickerMonthYear">
                                    December 2024
                                </div>
                                <button type="button" class="datepicker-nav" onclick="navigateMonth('expenseCustomDatepicker', 1)">
                                    <i data-lucide="chevron-right" class="w-4 h-4"></i>
                                </button>
                            </div>
                            <div class="datepicker-grid" id="expenseCustomDatepickerGrid">
                                <!-- Calendar grid will be populated by JavaScript -->
                            </div>
                            <div class="datepicker-footer">
                                <button type="button" class="datepicker-btn datepicker-btn-secondary" onclick="clearDate('expenseCustomDatepicker')">
                                    Clear
                                </button>
                                <button type="button" class="datepicker-btn datepicker-btn-primary" onclick="selectToday('expenseCustomDatepicker')">
                                    Today
                                </button>
                            </div>
                        </div>
                        <input type="hidden" id="slideOutExpenseDate" name="slideOutExpenseDate">
                    </div>
                </div>
                
                <!-- Amount and Category side by side -->
                <div class="input-row">
                  <div class="form-group">
                    <label class="form-label" for="slideOutExpenseAmount">Amount ($)</label>
                    <input type="number" class="form-input" id="slideOutExpenseAmount" placeholder="0.00" step="0.01">
                  </div>
                  <div class="form-group">
                    <label class="form-label" for="slideOutExpenseCategory">Category</label>
                    <div class="select-container">
                      <div class="select-trigger" onclick="toggleSlideOutSelect('expenseCategory')" id="expenseCategoryTrigger">
                        <span id="expenseCategoryValue"><i data-lucide="shopping-cart" class="w-4 h-4 inline mr-2"></i>Groceries</span>
                        <i data-lucide="chevron-down" class="w-4 h-4"></i>
                      </div>
                      <div class="select-content" id="expenseCategoryContent">
                        <div class="select-item selected" data-value="groceries"><i data-lucide="shopping-cart" class="w-4 h-4 inline mr-2"></i>Groceries</div>
                        <div class="select-item" data-value="transportation"><i data-lucide="car" class="w-4 h-4 inline mr-2"></i>Transportation</div>
                        <div class="select-item" data-value="dining"><i data-lucide="utensils" class="w-4 h-4 inline mr-2"></i>Dining Out</div>
                        <div class="select-item" data-value="entertainment"><i data-lucide="film" class="w-4 h-4 inline mr-2"></i>Entertainment</div>
                        <div class="select-item" data-value="personal"><i data-lucide="user" class="w-4 h-4 inline mr-2"></i>Personal Care</div>
                        <div class="select-item" data-value="clothing"><i data-lucide="shirt" class="w-4 h-4 inline mr-2"></i>Clothing</div>
                        <div class="select-item" data-value="health"><i data-lucide="heart-pulse" class="w-4 h-4 inline mr-2"></i>Health/Fitness</div>
                        <div class="select-item" data-value="subscriptions"><i data-lucide="tv" class="w-4 h-4 inline mr-2"></i>Subscriptions</div>
                        <div class="select-item" data-value="mortgage"><i data-lucide="home" class="w-4 h-4 inline mr-2"></i>Mortgage</div>
                        <div class="select-item" data-value="loan"><i data-lucide="dollar-sign" class="w-4 h-4 inline mr-2"></i>Loan Repayment</div>
                        <div class="select-item" data-value="garbage"><i data-lucide="trash-2" class="w-4 h-4 inline mr-2"></i>Garbage</div>
                        <div class="select-item" data-value="home improvement"><i data-lucide="hammer" class="w-4 h-4 inline mr-2"></i>Home Improvement</div>
                        <div class="select-item" data-value="insurance"><i data-lucide="umbrella" class="w-4 h-4 inline mr-2"></i>Insurance</div>
                        <div class="select-item" data-value="pets"><i data-lucide="dog" class="w-4 h-4 inline mr-2"></i>Pets</div>
                        <div class="select-item" data-value="phone"><i data-lucide="smartphone" class="w-4 h-4 inline mr-2"></i>Phone</div>
                        <div class="select-item" data-value="internet"><i data-lucide="globe" class="w-4 h-4 inline mr-2"></i>Internet & Cable</div>
                        <div class="select-item" data-value="utilities"><i data-lucide="zap" class="w-4 h-4 inline mr-2"></i>Utilities</div>
                        <div class="select-item" data-value="other"><i data-lucide="more-horizontal" class="w-4 h-4 inline mr-2"></i>Other</div>
                      </div>
                    </div>
                    <!-- Hidden native select for compatibility -->
                    <select id="slideOutExpenseCategory" style="display: none;">
                      <option value="groceries">Groceries</option>
                      <option value="transportation">Transportation</option>
                      <option value="dining">Dining Out</option>
                      <option value="entertainment">Entertainment</option>
                      <option value="personal">Personal Care</option>
                      <option value="clothing">Clothing</option>
                      <option value="health">Health/Fitness</option>
                      <option value="subscriptions">Subscriptions</option>
                      <option value="mortgage">Mortgage</option>
                      <option value="loan">Loan Repayment</option>
                      <option value="garbage">Garbage</option>
                      <option value="home improvement">Home Improvement</option>
                      <option value="insurance">Insurance</option>
                      <option value="pets">Pets</option>
                      <option value="phone">Phone</option>
                      <option value="internet">Internet & Cable</option>
                      <option value="utilities">Utilities</option>
                      <option value="other">Other</option>
                    </select>
                  </div>
                </div>
                
                <div class="form-group">
                    <label class="form-label" for="slideOutExpenseDescription">Description (optional)</label>
                    <input type="text" class="form-input" id="slideOutExpenseDescription" placeholder="What did you buy?">
                </div>
                
                <button type="button" class="add-btn" onclick="addExpenseFromSlideOut()">Add Expense</button>
            </div>
        </div>
    </div>
    
    <!-- Balance Slide-out -->
    <div class="slide-out-overlay" id="balanceSlideOut">
        <div class="slide-out-content">
            <div class="slide-out-header">
                <h3 class="slide-out-title">Record Balance</h3>
                <button class="slide-out-close" onclick="hideBalanceSlideOut()">
                    <i data-lucide="x" class="w-5 h-5"></i>
                </button>
            </div>
            
            <div class="slide-out-form">
                <!-- Date field above -->
                <div class="form-group">
                  <label class="form-label" for="slideOutBalanceDate">Date</label>
                  <div class="custom-datepicker" id="balanceCustomDatepicker">
                    <div class="datepicker-trigger" onclick="toggleDatepicker('balanceCustomDatepicker')"
                         role="button" tabindex="0" aria-label="Select date" aria-expanded="false">
                      <span class="datepicker-value" id="balanceCustomDatepickerValue">Select date</span>
                      <i data-lucide="calendar" class="w-4 h-4"></i>
                    </div>
                    <div class="datepicker-popup" id="balanceCustomDatepickerPopup">
                      <div class="datepicker-header">
                        <button type="button" class="datepicker-nav" onclick="navigateMonth('balanceCustomDatepicker', -1)">
                          <i data-lucide="chevron-left" class="w-4 h-4"></i>
                        </button>
                        <div class="datepicker-month-year" id="balanceCustomDatepickerMonthYear">
                          December 2024
                        </div>
                        <button type="button" class="datepicker-nav" onclick="navigateMonth('balanceCustomDatepicker', 1)">
                          <i data-lucide="chevron-right" class="w-4 h-4"></i>
                        </button>
                      </div>
                      <div class="datepicker-grid" id="balanceCustomDatepickerGrid">
                        <!-- Calendar grid will be populated by JavaScript -->
                      </div>
                      <div class="datepicker-footer">
                        <button type="button" class="datepicker-btn datepicker-btn-secondary" onclick="clearDate('balanceCustomDatepicker')">
                          Clear
                        </button>
                        <button type="button" class="datepicker-btn datepicker-btn-primary" onclick="selectToday('balanceCustomDatepicker')">
                          Today
                        </button>
                      </div>
                    </div>
                    <input type="hidden" id="slideOutBalanceDate" name="slideOutBalanceDate">
                  </div>
                </div>
                <!-- Account and Balance side by side -->
                <div class="input-row">
                  <div class="form-group">
                    <label class="form-label" for="slideOutBalanceAccount">Account</label>
                    <div class="select-container">
                      <div class="select-trigger" onclick="toggleSlideOutSelect('balanceAccount')" id="balanceAccountTrigger">
                        <span id="balanceAccountValue">Checking</span>
                        <i data-lucide="chevron-down" class="w-4 h-4"></i>
                      </div>
                      <div class="select-content" id="balanceAccountContent">
                        <!-- Options will be populated by JavaScript -->
                      </div>
                    </div>
                    <!-- Hidden native select for compatibility -->
                    <select id="slideOutBalanceAccount" style="display: none;">
                      <!-- Options will be populated by JavaScript -->
                    </select>
                  </div>
                  <div class="form-group">
                    <label class="form-label" for="slideOutBalanceAmount">Balance ($)</label>
                    <input type="number" class="form-input" id="slideOutBalanceAmount" placeholder="0.00" step="0.01">
                  </div>
                </div>
                
                <button type="button" class="balance-add-btn" onclick="addBalanceFromSlideOut()">Add Balance</button>
            </div>
        </div>
    </div>
    
    <!-- Account Management Slide-out -->
    <div class="account-management-slide-out" id="accountManagementSlideOut">
        <div class="account-management-content">
            <div class="account-management-header">
                <h3 class="account-management-title">Manage Accounts</h3>
                <button class="account-management-close" onclick="hideAccountManagementSlideOut()">
                    <i data-lucide="x" class="w-5 h-5"></i>
                </button>
            </div>
            
            <div class="account-management-list" id="accountManagementList">
                <!-- Account list will be populated by JavaScript -->
            </div>
            
            <div class="account-management-add-form">
                <h4 class="account-management-add-title">Add New Account</h4>
                <div class="account-management-input-group">
                    <input type="text" class="account-management-input" id="newAccountNameSlideOut" placeholder="e.g., Emergency Fund">
                </div>
                <button class="account-management-add-btn" onclick="addNewAccountFromSlideOut()">Add Account</button>
            </div>
        </div>
    </div>
    
    <!-- Legacy Account Management Modal (hidden for backwards compatibility) -->
    <div class="modal-overlay" id="accountManagementModal" style="display: none !important;">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">Manage Accounts</h3>
                <button class="modal-close" onclick="hideAccountManagementModal()"></button>
            </div>
            
            <div class="account-list" id="accountList">
                <!-- Account list will be populated by JavaScript -->
            </div>
            
            <div class="add-account-form">
                <h4 class="text-lg font-semibold mb-4">Add New Account</h4>
                <div class="form-group">
                    <label class="form-label" for="newAccountName">Account Name</label>
                    <input type="text" id="newAccountName" class="form-input" placeholder="e.g., Emergency Fund">
                </div>
                <button class="add-account-btn" onclick="addNewAccount()">Add Account</button>
            </div>
        </div>
    </div>
    
    <!-- Month/Year Slide-out -->
    <div class="slide-out-overlay" id="monthYearSlideOut">
        <div class="slide-out-content">
            <div class="slide-out-handle"></div>
            <div class="slide-out-header">
                <h3 class="slide-out-title">Select Month & Year</h3>
                <button class="slide-out-close" onclick="hideMonthYearSlideOut()"></button>
            </div>
            <div class="slide-out-form">
                <div class="form-group">
                    <label class="form-label" for="monthInput">Month</label>
                    <div class="select-container">
                        <div class="select-trigger" onclick="toggleSlideOutSelect('monthSelect')" id="monthSelectTrigger">
                            <span id="monthSelectValue">January</span>
                            <i data-lucide="chevron-down" class="w-4 h-4"></i>
                        </div>
                        <div class="select-content" id="monthSelectContent">
                            <div class="select-item" data-value="0">January</div>
                            <div class="select-item" data-value="1">February</div>
                            <div class="select-item" data-value="2">March</div>
                            <div class="select-item" data-value="3">April</div>
                            <div class="select-item" data-value="4">May</div>
                            <div class="select-item" data-value="5">June</div>
                            <div class="select-item" data-value="6">July</div>
                            <div class="select-item" data-value="7">August</div>
                            <div class="select-item" data-value="8">September</div>
                            <div class="select-item" data-value="9">October</div>
                            <div class="select-item" data-value="10">November</div>
                            <div class="select-item" data-value="11">December</div>
                        </div>
                    </div>
                    <!-- Hidden native select for compatibility -->
                    <select class="form-input" id="monthInput" style="display: none;">
                        <option value="0">January</option>
                        <option value="1">February</option>
                        <option value="2">March</option>
                        <option value="3">April</option>
                        <option value="4">May</option>
                        <option value="5">June</option>
                        <option value="6">July</option>
                        <option value="7">August</option>
                        <option value="8">September</option>
                        <option value="9">October</option>
                        <option value="10">November</div>
                        <option value="11">December</option>
                    </select>
                </div>
                <div class="form-group">
                    <label class="form-label" for="yearInput">Year</label>
                    <div class="select-container">
                        <div class="select-trigger" onclick="toggleSlideOutSelect('monthYear')" id="monthYearTrigger">
                            <span id="monthYearValue">2024</span>
                            <i data-lucide="chevron-down" class="w-4 h-4"></i>
                        </div>
                        <div class="select-content" id="monthYearContent">
                            <!-- Year options will be populated by JavaScript -->
                        </div>
                    </div>
                    <!-- Hidden native select for compatibility -->
                    <select id="yearInput" style="display: none;">
                        <!-- Options will be populated by JavaScript -->
                    </select>
                </div>
                <button type="button" class="add-btn" id="applyMonthYearBtn" style="margin-top:1rem;">Apply</button>
            </div>
        </div>
    </div>
    
      <!-- Clerk -->
  <script>
  window.addEventListener('load', async function () {
    await Clerk.load()

    if (Clerk.user) {
      
      const userButton = document.createElement('div');
      userButton.setAttribute('id', 'user-button');
      const app = document.querySelector('#user-avatar');
      if (!app) {
        console.error('App element not found');
        return;
      } else {
        app.appendChild(userButton);
      }
        
      const userButtonDiv = document.getElementById('user-button')

      Clerk.mountUserButton(userButtonDiv)
    } else {
      document.getElementById('app').innerHTML = `
        <div id="sign-in"></div>
      `

      const signInDiv = document.getElementById('sign-in')

      Clerk.mountSignIn(signInDiv)
    }
  })
</script>

    <script>
        // Firebase configuration (add your actual config)
        const firebaseConfig = {
            // Replace with your Firebase config
            apiKey: "your-api-key",
            authDomain: "your-project.firebaseapp.com",
            projectId: "your-project-id",
            storageBucket: "your-project.appspot.com",
            messagingSenderId: "123456789",
            appId: "your-app-id"
        };

        // Initialize Firebase (uncomment when you have real config)
        // firebase.initializeApp(firebaseConfig);
        // const db = firebase.firestore();

        // Period tracking variables
        let currentPeriodMode = 'month'; // 'today' or 'month'
        let currentSavePeriodMode = 'month'; // 'today' or 'month' for save screen
        let selectedMonthDate = new Date(2025, 6, 7); // Hard-coded to July 7, 2025
        let selectedSaveMonthDate = new Date(2025, 6, 7); // Separate month date for save screen, July 7, 2025
        let currentChartPeriod = 'ALL'; // '1M', '3M', '6M', 'YTD', '1Y', 'ALL' - Changed from YTD to ALL to show all balance data
        
        let currentScreen = 0;
        let spendingChart;
        let categoryChart;
        
        // Storage keys
        const EXPENSES_KEY = 'dailyExpenses';
        const MONTHLY_DATA_KEY = 'monthlyData';
        const SAVINGS_ACCOUNTS_KEY = 'savingsAccounts';
        const ACCOUNT_BALANCES_KEY = 'accountBalances';
        
        // Budget functions that get values from settings
        function getDailyBudget() {
            const settings = getSimpleBudgetSettings();
            const discretionaryBudget = settings.discretionaryExpenses || 501;
            const dailyBudget = discretionaryBudget / 30; // Daily discretionary budget
            console.log('Daily budget calculated:', dailyBudget, 'from discretionary:', discretionaryBudget);
            return dailyBudget;
        }
        
        function getWeeklyBudget() {
            return getDailyBudget() * 7;
        }
        
        function getMonthlyBudget() {
            const settings = getSimpleBudgetSettings();
            const budget = (settings.essentialExpenses || 750) + (settings.discretionaryExpenses || 501);
            console.log('Monthly budget calculated:', budget, 'from settings:', settings);
            return budget;
        }
        
        function getMonthlySavingsTarget() {
            const settings = getSimpleBudgetSettings();
            return settings.monthlySavingsTarget || 4333;
        }
        
        function getSimpleBudgetSettings() {
            const savedSettings = localStorage.getItem('simpleBudgetSettings');
            if (savedSettings) {
                return JSON.parse(savedSettings);
            }
            // Return default values if no settings saved
            return {
                grossIncome: 11667,
                federalTax: 2500,
                provincialTax: 750,
                cppEi: 333,
                netIncome: 8084,
                annualSavingsGoal: 52000,
                monthlySavingsTarget: 4333,
                fixedExpenses: 2450,
                essentialExpenses: 750,
                discretionaryExpenses: 501
            };
        }
        
        // Savings tracking variables
        savingsAccounts = [];
        
        // Default accounts
        const defaultAccounts = [
            { id: 'checking', name: 'Checking', type: 'cash' },
            { id: 'savings', name: 'Savings', type: 'cash' },
            { id: 'investment', name: 'Investment', type: 'investment' }
        ];
        
        function goToScreen(screenIndex) {
            currentScreen = screenIndex;
            const wrapper = document.getElementById('screensWrapper');
            wrapper.style.transform = `translateX(-${screenIndex * 100}vw)`;
            
            // Update nav items
            document.querySelectorAll('.nav-item').forEach((item, index) => {
                item.classList.toggle('active', index === screenIndex);
            });
            
            // Update header title
            updateHeaderTitle();
            
            if (screenIndex === 0) {
                // Home screen
                updateHomeScreen();
            } else if (screenIndex === 1) {
                // Cashflow screen (formerly Spend)
                setPeriodMode('month');
                // Ensure monthly chart is generated
                setTimeout(() => {
                    generateMonthlyChart();
                    // Re-initialize swipe functionality after chart render
                    if (typeof initializeChartSwipe === 'function') {
                        initializeChartSwipe();
                    }
                }, 100);
                updateCashflowPeriodDisplay();
                updateBudgetDisplay();
                updateExpensesList();
            } else if (screenIndex === 2) {
                // Accounts screen (formerly Save)
                setSavePeriodMode('month');
                updateSaveScreen();
            } else if (screenIndex === 3) {
                // Dashboard screen (formerly Reports)
                updateReports();
                setTimeout(updateChart, 300);
            }
        }
        
        
        function getCurrentDate() {
            const now = new Date();
            const year = now.getFullYear();
            const month = String(now.getMonth() + 1).padStart(2, '0');
            const day = String(now.getDate()).padStart(2, '0');
            return `${year}-${month}-${day}`;
        }
        
        function loadAccountBalances() {
            const balances = localStorage.getItem('accountBalances');
            return balances ? JSON.parse(balances) : {};
        }
        
        function saveAccountBalances(balances) {
            localStorage.setItem('accountBalances', JSON.stringify(balances));
        }
        
        function updatePeriodView() {
            updateBudgetDisplay();
            updateExpensesList();
            updateTotalSavingsDisplay(); // Always update, regardless of mode
            updateSaveScreen(); // Update save screen as well
        }
        
        function updateBudgetDisplay() {
            const expenses = loadExpenses();
            const settings = getSimpleBudgetSettings();
            let totalSpent = 0;
            let monthlyIncome = settings.netIncome || 8084;
            
            if (currentPeriodMode === 'today') {
                // Calculate this week's spending
                const weekDates = getCurrentWeekDates();
                console.log('Week dates:', weekDates);
                weekDates.forEach(date => {
                    const dayExpenses = expenses[date] || [];
                    console.log(`Date ${date}: ${dayExpenses.length} expenses, total: $${dayExpenses.reduce((sum, expense) => sum + expense.amount, 0)}`);
                    totalSpent += dayExpenses.reduce((sum, expense) => sum + expense.amount, 0);
                });
                
                // Calculate weekly income (monthly income / ~4.33 weeks)
                monthlyIncome = monthlyIncome / 4.33;
                console.log(`Weekly: spent $${totalSpent}, income $${monthlyIncome.toFixed(2)}`);
            } else {
                // Monthly calculation
                const monthKey = getCurrentPeriodKey();
                Object.keys(expenses).forEach(date => {
                    if (date.startsWith(monthKey)) {
                        const dayExpenses = expenses[date] || [];
                        totalSpent += dayExpenses.reduce((sum, expense) => sum + expense.amount, 0);
                    }
                });
                
                console.log(`Monthly: spent $${totalSpent}, income $${monthlyIncome.toFixed(2)}`);
            }
            
            // Generate monthly spending chart instead of income/spending bars
            generateMonthlyChart();
            
            // Update change indicators (calculate monthly status once)
            updateMonthlyStatus();
        }
        
        let lastMonthlyStatusUpdate = null;
        
        function updateMonthlyStatus() {
            const expenses = loadExpenses();
            const monthlyBudget = getMonthlyBudget();
            let monthlySpent = 0;
            const monthKey = getCurrentPeriodKey();
            
            Object.keys(expenses).forEach(date => {
                if (date.startsWith(monthKey)) {
                    const dayExpenses = expenses[date] || [];
                    monthlySpent += dayExpenses.reduce((sum, expense) => sum + expense.amount, 0);
                }
            });
            
            // Only update if values actually changed
            const currentValues = { monthlySpent, monthlyBudget, monthKey };
            if (!lastMonthlyStatusUpdate || JSON.stringify(lastMonthlyStatusUpdate) !== JSON.stringify(currentValues)) {
                lastMonthlyStatusUpdate = currentValues;
                updateChangeIndicators(monthlySpent, monthlyBudget - monthlySpent, monthlyBudget);
            }
        }
        
        function getCurrentWeekDates() {
            const today = new Date();
            const currentDay = today.getDay(); // 0 = Sunday, 1 = Monday, etc.
            const mondayOffset = currentDay === 0 ? -6 : 1 - currentDay; // Calculate days to Monday
            
            const weekDates = [];
            for (let i = 0; i < 7; i++) {
                const date = new Date(today);
                date.setDate(today.getDate() + mondayOffset + i);
                weekDates.push(date.toISOString().split('T')[0]); // YYYY-MM-DD format
            }
            return weekDates;
        }
        
        function updateBudgetLabels() {
            const spentLabel = document.querySelector('.spending-card .text-muted-foreground');
            const remainingLabel = document.querySelector('.remaining-card .text-muted-foreground');
            
            if (currentPeriodMode === 'today') {
                if (spentLabel) spentLabel.textContent = 'Spent This Week';
                if (remainingLabel) remainingLabel.textContent = 'Remaining This Week';
            } else {
                if (spentLabel) spentLabel.textContent = 'Spent This Month';
                if (remainingLabel) remainingLabel.textContent = 'Remaining This Month';
            }
        }
        
        function calculateMonthOverMonthChange(currentMonthSpent) {
            const expenses = loadExpenses();
            const currentDate = new Date(selectedMonthDate);
            
            // Get previous month
            const previousMonth = new Date(currentDate);
            previousMonth.setMonth(previousMonth.getMonth() - 1);
            const previousMonthKey = previousMonth.toISOString().substring(0, 7); // YYYY-MM format
            
            // Calculate previous month spending
            let previousMonthSpent = 0;
            Object.keys(expenses).forEach(date => {
                if (date.startsWith(previousMonthKey)) {
                    const dayExpenses = expenses[date] || [];
                    previousMonthSpent += dayExpenses.reduce((sum, expense) => sum + expense.amount, 0);
                }
            });
            
            // Calculate percentage change
            if (previousMonthSpent === 0) {
                return currentMonthSpent > 0 ? 100 : null; // 100% increase from 0, or null if both are 0
            }
            
            return ((currentMonthSpent - previousMonthSpent) / previousMonthSpent) * 100;
        }
        
        function updateChangeIndicators(monthlySpent, monthlyRemaining, monthlyBudget) {
            console.log('updateChangeIndicators called with:', { monthlySpent, monthlyRemaining, monthlyBudget });
            const spentChange = document.getElementById('spentChange');
            const remainingChange = document.getElementById('remainingChange');
            
            // Calculate monthly percentage used
            const monthlyPercentUsed = (monthlySpent / monthlyBudget) * 100;
            
            // Calculate month-over-month change for spending
            const monthOverMonthChange = calculateMonthOverMonthChange(monthlySpent);
            
            // Update spent change indicator with month-over-month percentage
            if (spentChange) {
                const spentArrow = spentChange.querySelector('.change-arrow');
                const spentAmount = spentChange.querySelector('.change-amount');
                
                if (monthOverMonthChange === null) {
                    if (spentArrow) spentArrow.textContent = '';
                    if (spentAmount) spentAmount.textContent = 'No data';
                } else {
                    const isIncrease = monthOverMonthChange > 0;
                    if (spentArrow) spentArrow.textContent = isIncrease ? '' : '';
                    if (spentAmount) spentAmount.textContent = `${Math.abs(monthOverMonthChange).toFixed(1)}%`;
                    
                    // Update color based on increase/decrease
                    const changeIndicator = spentChange;
                    if (changeIndicator) {
                        changeIndicator.style.color = isIncrease ? '#ef4444' : '#5fa42e'; // red for increase, green for decrease
                    }
                }
            }
            
            // Update remaining change indicator based on MONTHLY budget status
            if (remainingChange) {
                const remainingArrow = remainingChange.querySelector('.change-arrow');
                const remainingStatus = remainingChange.querySelector('.change-amount');
                const remainingCard = document.querySelector('.remaining-card .change-indicator');
                
                // Debug log
                console.log(`Monthly spent: ${monthlySpent}, Monthly budget: ${monthlyBudget}, Percent used: ${monthlyPercentUsed.toFixed(1)}%`);
                
                if (monthlyPercentUsed >= 100) {
                    if (remainingArrow) remainingArrow.textContent = '';
                    if (remainingStatus) remainingStatus.textContent = 'Over Budget';
                    if (remainingCard) remainingCard.classList.add('over-budget');
                } else if (monthlyPercentUsed >= 75) {
                    if (remainingArrow) remainingArrow.textContent = '';
                    if (remainingStatus) remainingStatus.textContent = 'Warning';
                    if (remainingCard) remainingCard.classList.remove('over-budget');
                } else {
                    if (remainingArrow) remainingArrow.textContent = '';
                    if (remainingStatus) remainingStatus.textContent = 'On Track';
                    if (remainingCard) remainingCard.classList.remove('over-budget');
                }
            }
        }
        
        function updateExpensesList() {
            const expenses = loadExpenses();
            const listContainer = document.getElementById('expensesList');
            const titleElement = document.getElementById('expensesListTitle');
            
            if (!listContainer) return;
            
            let periodExpenses = [];
            
            if (currentPeriodMode === 'today') {
                // Show this week's transactions
                const weekDates = getCurrentWeekDates();
                weekDates.forEach(date => {
                    const dayExpenses = expenses[date] || [];
                    dayExpenses.forEach(expense => {
                        periodExpenses.push({
                            ...expense,
                            date: date
                        });
                    });
                });
                
                // Sort by timestamp, newest first
                periodExpenses.sort((a, b) => {
                    return b.timestamp - a.timestamp;
                });
                
                if (titleElement) titleElement.textContent = "Transactions";
            } else {
                // Month mode: gather all expenses for the selected month
                const monthKey = getCurrentPeriodKey();
                Object.keys(expenses).forEach(date => {
                    if (date.startsWith(monthKey)) {
                        const dayExpenses = expenses[date] || [];
                        dayExpenses.forEach(expense => {
                            periodExpenses.push({
                                ...expense,
                                date: date
                            });
                        });
                    }
                });
                
                // Sort: by date (desc), then by created (asc), then by timestamp for stability
                periodExpenses.sort((a, b) => {
                    if (a.date !== b.date) {
                        return new Date(b.date) - new Date(a.date); // latest date first
                    }
                    // If same date, sort by created descending (newest first)
                    const createdA = a.created || a.timestamp;
                    const createdB = b.created || b.timestamp;
                    if (createdA !== createdB) {
                        return createdB - createdA; // Reversed order
                    }
                    // If created timestamps are the same, use timestamp for stable ordering
                    return b.timestamp - a.timestamp; // Reversed order
                });
                
                const monthName = selectedMonthDate.toLocaleDateString('en-US', { month: 'long' });
                if (titleElement) titleElement.textContent = "Transactions";
            }
            
            if (periodExpenses.length === 0) {
                const noExpensesText = currentPeriodMode === 'today' ? 'No transactions recorded this week' : 'No transactions recorded this month';
                listContainer.innerHTML = `<div style="text-align: center; color: #7f8c8d; padding: 20px;">${noExpensesText}</div>`;
            } else {
                // Group expenses by date
                const expensesByDate = {};
                periodExpenses.forEach(expense => {
                    if (!expensesByDate[expense.date]) {
                        expensesByDate[expense.date] = [];
                    }
                    expensesByDate[expense.date].push(expense);
                });
                
                // Generate HTML with date grouping
                let html = '';
                Object.keys(expensesByDate).sort((a, b) => new Date(b) - new Date(a)).forEach(date => {
                    const expenses = expensesByDate[date];
                    const dateParts = date.split('-').map(Number);
                    const dateObj = new Date(dateParts[0], dateParts[1] - 1, dateParts[2]);
                    const dateTitle = dateObj.toLocaleDateString('en-US', { 
                        month: 'long', 
                        day: 'numeric', 
                        year: 'numeric' 
                    });
                    
                    // Calculate daily total
                    const dayTotal = expenses.reduce((sum, expense) => sum + parseFloat(expense.amount), 0);
                    
                    html += `
                        <div class="date-group">
                            <div class="date-header">
                                <span class="date-title">${dateTitle}</span>
                                <span class="date-total">$${dayTotal.toFixed(2)}</span>
                            </div>
                            <div class="date-transactions">
                    `;
                    
                    expenses.forEach(expense => {
                        html += `
                            <div class="swipe-container" data-type="expense" data-date="${expense.date}" data-timestamp="${expense.timestamp}">
                                <div class="swipe-content">
                                    <div class="expense-item">
                                        <div class="expense-icon">${getCategoryEmoji(expense.category)}</div>
                                        <div class="expense-details">
                                            <div class="expense-description">${expense.description ? expense.description : `${expense.category} expense`}</div>
                                        </div>
                                        <div class="expense-amount">$${parseFloat(expense.amount).toFixed(2)}</div>
                                    </div>
                                </div>
                                <div class="swipe-action" onclick="handleExpenseDelete(this); event.stopPropagation(); return false;"><i data-lucide="x" class="w-5 h-5"></i></div>
                            </div>
                        `;
                    });
                    
                    html += `
                            </div>
                        </div>
                    `;
                });
                
                listContainer.innerHTML = html;
            }
        }
        
        function deleteExpense(date, timestamp) {
            console.log('deleteExpense function called with date:', date, 'and timestamp:', timestamp);
            timestamp = parseInt(timestamp, 10); // Ensure timestamp is a number
            
            if (!date || isNaN(timestamp)) {
                console.error('Invalid date or timestamp:', { date, timestamp });
                alert('Invalid date or timestamp. Cannot delete expense.');
                return;
            }
            
            try {
                const expenses = loadExpenses();
                console.log('Current expenses for date:', date, expenses[date]);
                
                // Handle the case where date might be undefined for today mode
                const targetDate = date || getCurrentDate();
                console.log('Target date for deletion:', targetDate);
                
                if (expenses[targetDate]) {
                    console.log('Found expenses for target date:', expenses[targetDate].length);
                    console.log('Expense timestamps:', expenses[targetDate].map(e => e.timestamp));
                    
                    // Filter out the expense with the matching timestamp
                    const originalLength = expenses[targetDate].length;
                    expenses[targetDate] = expenses[targetDate].filter(expense => {
                        const match = expense.timestamp !== timestamp;
                        console.log(`Comparing ${expense.timestamp} with ${timestamp}: ${match ? 'keep' : 'remove'}`);
                        return expense.timestamp !== timestamp;
                    });
                    
                    // Check if the expense was actually removed
                    if (expenses[targetDate].length === originalLength) {
                        console.error('Expense not found with timestamp:', timestamp);
                        alert('Could not find expense to delete. Please refresh and try again.');
                        
                        // Remove the 'deleting' class from the element to restore it
                        const swipeContainer = document.querySelector(`.swipe-container[data-timestamp="${timestamp}"]`);
                        if (swipeContainer) {
                            swipeContainer.classList.remove('deleting');
                        }
                        
                        return;
                    }
                    
                    console.log('After filtering, expenses length:', expenses[targetDate].length);
                    
                    // Remove the date entry if no expenses left for that date
                    if (expenses[targetDate].length === 0) {
                        console.log('No expenses left for date, removing date entry');
                        delete expenses[targetDate];
                    }
                    
                    // Save the updated expenses
                    console.log('Saving updated expenses');
                    saveExpenses(expenses);
                    
                    // Force refresh UI
                    const listContainer = document.getElementById('expensesList');
                    if (listContainer) {
                        console.log('Forcing expense list refresh');
                        updateExpensesList();
                    }
                    
                    // Update the rest of the display
                    console.log('Updating UI after deletion');
                    updatePeriodView();
                    updateChart();
                    
                    console.log(' Expense deleted successfully');
             
                } else {
                    console.error('No expenses found for date:', targetDate);
                    alert('Could not find expenses for this date. Please refresh and try again.');
                    
                    // Remove the 'deleting' class from the element to restore it
                    const swipeContainer = document.querySelector(`.swipe-container[data-timestamp="${timestamp}"]`);
                    if (swipeContainer) {
                        swipeContainer.classList.remove('deleting');
                    }
                }
            } catch (error) {
                console.error('Error in deleteExpense function:', error);
                alert('An error occurred while deleting the expense. Please try again.');
                
                // Remove the 'deleting' class from the element to restore it
                const swipeContainer = document.querySelector(`.swipe-container[data-timestamp="${timestamp}"]`);
                if (swipeContainer) {
                    swipeContainer.classList.remove('deleting');
                }
            }
        }
        
        function updateReports() {
            // Update weekly and monthly stats
            const expenses = loadExpenses();
            const today = new Date(2025, 6, 7); // Hard-coded to July 7, 2025
            const dayOfMonth = today.getDate();
            const daysInMonth = new Date(today.getFullYear(), today.getMonth() + 1, 0).getDate();
            const remainingDaysInMonth = daysInMonth - dayOfMonth;

            // Calculate weekly spending
            let weeklySpent = 0;
            let monthlySpent = 0; // <-- Add this missing declaration
            for (let i = 0; i < 7; i++) {
                const date = new Date(today);
                date.setDate(today.getDate() - i);
                const dateKey = `${date.getFullYear()}-${String(date.getMonth() + 1).padStart(2, '0')}-${String(date.getDate()).padStart(2, '0')}`;
                const dayExpenses = expenses[dateKey] || [];
                weeklySpent += dayExpenses.reduce((sum, expense) => sum + expense.amount, 0);
            }

            // Calculate monthly spending
            Object.keys(expenses).forEach(date => {
                if (date.startsWith(getCurrentMonth())) {
                    const dayExpenses = expenses[date] || [];
                    monthlySpent += dayExpenses.reduce((sum, expense) => sum + expense.amount, 0);
                }
            });

            // Calculate daily burn rate (average spent per day)
            const dailyBurnRate = monthlySpent / dayOfMonth;
            
            // Calculate projected spending for the rest of the month
            const projectedAdditionalSpending = dailyBurnRate * remainingDaysInMonth;
            const projectedTotalSpending = monthlySpent + projectedAdditionalSpending;
            
            // Calculate projected monthly savings
            const projectedMonthlySavings = Math.max(0, getMonthlyBudget() - projectedTotalSpending);
            
            // Calculate days left in budget (at current burn rate)
            const remainingBudget = getMonthlyBudget() - monthlySpent;
            const daysLeftInBudget = dailyBurnRate > 0 ? Math.floor(remainingBudget / dailyBurnRate) : remainingDaysInMonth;
            
            // Calculate savings rate (assuming budget = income - required savings)
            // This is an approximation - in reality, we'd need income data
            const assumedIncome = getMonthlyBudget() + getMonthlySavingsTarget();
            const projectedSavings = assumedIncome - projectedTotalSpending;
            const savingsRate = (projectedSavings / assumedIncome) * 100;
            
            // Update weekly metrics
            const weeklySpentEl = document.getElementById('weeklySpent');
            const weeklyRemainingEl = document.getElementById('weeklyRemaining');
            const projectedMonthlySavingsEl = document.getElementById('projectedMonthlySavings');
            
            if (weeklySpentEl) weeklySpentEl.textContent = formatCurrencyWhole(weeklySpent);
            if (weeklyRemainingEl) weeklyRemainingEl.textContent = formatCurrencyWhole(Math.max(0, getWeeklyBudget() - weeklySpent));
            if (projectedMonthlySavingsEl) projectedMonthlySavingsEl.textContent = formatCurrencyWhole(projectedMonthlySavings);
            
            // Update monthly stats
            const monthlySpentEl = document.getElementById('monthlySpent');
            const monthSpentSubtitleEl = document.getElementById('monthSpentSubtitle');
            const dailyBurnRateEl = document.getElementById('dailyBurnRate');
            const burnRateStatusEl = document.getElementById('burnRateStatus');
            const daysRemainingEl = document.getElementById('daysRemaining');
            const daysRemainingSubtitleEl = document.getElementById('daysRemainingSubtitle');
            const savingsRateEl = document.getElementById('savingsRate');
            const savingsRateSubtitleEl = document.getElementById('savingsRateSubtitle');
            
            // Update month spent with percentage indicator
            if (monthlySpentEl) monthlySpentEl.textContent = formatCurrencyWhole(monthlySpent);
            if (monthSpentSubtitleEl) {
                            const percentUsed = (monthlySpent / getMonthlyBudget()) * 100;
            monthSpentSubtitleEl.textContent = `${percentUsed.toFixed(0)}% of ${formatCurrency(getMonthlyBudget())} budget`;
            }
            
            // Update daily burn rate with status
            if (dailyBurnRateEl) dailyBurnRateEl.textContent = formatCurrencyWhole(dailyBurnRate);
            if (burnRateStatusEl) {
                const dailyTarget = getMonthlyBudget() / daysInMonth;
                const difference = dailyTarget - dailyBurnRate;
                let burnRateStatus = '';
                
                if (difference > 0) {
                    burnRateStatus = `${formatCurrencyWhole(difference)} under target`;
                    burnRateStatusEl.className = 'stat-subtitle positive';
                } else if (difference < 0) {
                    burnRateStatus = `${formatCurrencyWhole(Math.abs(difference))} over target`;
                    burnRateStatusEl.className = 'stat-subtitle negative';
                } else {
                    burnRateStatus = 'right on target';
                    burnRateStatusEl.className = 'stat-subtitle';
                }
                
                burnRateStatusEl.textContent = burnRateStatus;
            }
            
            // Update days left in budget
            if (daysRemainingEl) {
                if (daysLeftInBudget >= remainingDaysInMonth) {
                    daysRemainingEl.textContent = remainingDaysInMonth;
                    daysRemainingEl.className = 'stat-value positive';
                } else if (daysLeftInBudget <= 0) {
                    daysRemainingEl.textContent = '0';
                    daysRemainingEl.className = 'stat-value negative';
                } else {
                    daysRemainingEl.textContent = daysLeftInBudget;
                    if (daysLeftInBudget < 7) {
                        daysRemainingEl.className = 'stat-value warning';
                    } else {
                        daysRemainingEl.className = 'stat-value';
                    }
                }
            }
            
            if (daysRemainingSubtitleEl) {
                const daysMessage = daysLeftInBudget >= remainingDaysInMonth ? 
                    'on track' : `${remainingDaysInMonth - daysLeftInBudget} days short`;
                daysRemainingSubtitleEl.textContent = daysMessage;
            }
            
            // Update savings rate
            if (savingsRateEl) {
                savingsRateEl.textContent = `${Math.max(0, savingsRate).toFixed(0)}%`;
                
                // Styling based on savings goal
                const targetSavingsRate = (getMonthlySavingsTarget() / assumedIncome) * 100;
                if (savingsRate >= targetSavingsRate) {
                    savingsRateEl.className = 'stat-value positive';
                } else if (savingsRate >= targetSavingsRate * 0.7) {
                    savingsRateEl.className = 'stat-value warning';
                } else {
                    savingsRateEl.className = 'stat-value negative';
                }
            }
            
            if (savingsRateSubtitleEl) {
                savingsRateSubtitleEl.textContent = `vs ${(getMonthlySavingsTarget() / assumedIncome * 100).toFixed(0)}% target`;
            }
            
            // Update month name in labels
            updateMonthLabel();
        }
        
        function updateMonthLabel() {
            // Hard-coded date for consistency: July 7, 2025
            const monthName = new Date(2025, 6, 7).toLocaleDateString('en-US', { month: 'long' });
            const monthSpentLabelEl = document.getElementById('monthSpentLabel');
            
            if (monthSpentLabelEl) {
                monthSpentLabelEl.textContent = `${monthName} Spent`;
            }
        }
        
        function setChartPeriod(period) {
            // If it's the same period, don't do anything
            if (currentChartPeriod === period) return;
            
            // Store the previous period for animation
            const previousPeriod = currentChartPeriod;
            currentChartPeriod = period;
            
            // Update button states with smooth transition
            document.querySelectorAll('.chart-period-btn-wealthsimple').forEach(btn => {
                btn.classList.remove('active');
            });
            
            const periodBtn = document.getElementById('period' + period);
            if (periodBtn) {
                // Small delay for visual feedback
                setTimeout(() => {
                    periodBtn.classList.add('active');
                }, 10);
            }
            
            // Add loading indicator if needed for longer data sets
            const chartContainer = document.querySelector('.chart-container');
            if (period === 'ALL') {
                chartContainer.classList.add('loading');
            }
            
            // Slight delay for animation
            setTimeout(() => {
                updateChart();
                chartContainer.classList.remove('loading');
            }, 100);
        }
        
        function updateChart() {
            // Get expenses and balances
            const expenses = loadExpenses();
            const balances = loadAccountBalances();
            
            // Get chart canvas
            const ctx = document.getElementById('spendingChart').getContext('2d');
            
            // Calculate date range based on selected time range
            const dateRange = getDateRangeForTimeRange(currentTimeRange);
            const startDate = dateRange.startDate;
            const endDate = dateRange.endDate;

             // Helper to find the nearest data index from x coordinate
            function getNearestIndex(x) {
                const chartArea = spendingChart.chartArea;
                if (!chartArea) return savingsData.length - 1;
                const xScale = spendingChart.scales.x;
                let minDist = Infinity;
                let nearest = 0;
                for (let i = 0; i < labels.length; i++) {
                    const px = xScale.getPixelForValue(i);
                    const dist = Math.abs(px - x);
                    if (dist < minDist) {
                        minDist = dist;
                        nearest = i;
                    }
                }
                return nearest;
            }
            
            // Generate dates between start and end date
            const dates = [];
            const currentDate = new Date(startDate);
            while (currentDate <= endDate) {
                dates.push(new Date(currentDate));
                currentDate.setDate(currentDate.getDate() + 1);
            }
            
            // Format dates for labels and lookup
            const labels = dates.map(date => {
                return date.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
            });
            
            const dateKeys = dates.map(date => {
                const year = date.getFullYear();
                const month = String(date.getMonth() + 1).padStart(2, '0');
                const day = String(date.getDate()).padStart(2, '0');
                return `${year}-${month}-${day}`;
            });
            
            // Calculate cumulative spending
            const spendingData = [];
            let cumulativeSpending = 0;
            
            dateKeys.forEach(dateKey => {
                const dayExpenses = expenses[dateKey] || [];
                const dayTotal = dayExpenses.reduce((sum, expense) => sum + expense.amount, 0);
                cumulativeSpending += dayTotal;
                spendingData.push(cumulativeSpending);
            });
            
            // Calculate account balances over time
            const savingsData = new Array(dates.length).fill(null);
            
            // Get all balance records and sort by date
            const balanceRecords = [];
            console.log('=== CHART BALANCE DEBUGGING ===');
            console.log('Chart period:', currentChartPeriod);
            console.log('Date range:', dateKeys[0], 'to', dateKeys[dateKeys.length - 1]);
            console.log('All balances from localStorage:', balances);
            
            // Create a map to sum up all account balances for each date
            const dateBalanceMap = new Map();
            
            Object.keys(balances).forEach(accountId => {
                const accountBalances = balances[accountId] || {};
                console.log(`Account ${accountId} balances:`, accountBalances);
                Object.keys(accountBalances).forEach(date => {
                    console.log(`Checking balance date: ${date} (in range: ${date >= dateKeys[0] && date <= dateKeys[dateKeys.length - 1]})`);
                    if (date >= dateKeys[0] && date <= dateKeys[dateKeys.length - 1]) {
                        const currentBalance = dateBalanceMap.get(date) || 0;
                        const accountBalance = accountBalances[date];
                        const newTotal = currentBalance + accountBalance;
                        dateBalanceMap.set(date, newTotal);
                        console.log(` Added balance for ${date}: $${accountBalance} (account: ${accountId})  Total: $${newTotal}`);
                    } else {
                        console.log(` Skipped balance record: ${date} = $${accountBalances[date]} (outside date range)`);
                    }
                });
            });
            
            // Convert the map to balance records array
            dateBalanceMap.forEach((totalAmount, date) => {
                balanceRecords.push({
                    date: date,
                    amount: totalAmount
                });
            });
            
            console.log('Final balance records for chart (summed by date):', balanceRecords);
            console.log('=== END CHART BALANCE DEBUGGING ===');
            
            // Sort balance records by date
            balanceRecords.sort((a, b) => a.date.localeCompare(b.date));
            
            // Calculate total balance for each date
            let lastKnownBalance = 0;
            balanceRecords.forEach(record => {
                const dateIndex = dateKeys.indexOf(record.date);
                if (dateIndex !== -1) {
                    lastKnownBalance = record.amount;
                    savingsData[dateIndex] = lastKnownBalance;
                }
            });
            
            // Fill in missing balance data using last known balance
            for (let i = 0; i < savingsData.length; i++) {
                if (savingsData[i] === null) {
                    if (i > 0 && savingsData[i-1] !== null) {
                        savingsData[i] = savingsData[i-1];
                    } else {
                        savingsData[i] = 0; // Default if no previous balance
                    }
                }
            }
            
            // Calculate total savings and growth
            const initialSavings = savingsData[0] || 0;
            const finalSavings = savingsData[savingsData.length - 1] || 0;
            const savingsGrowth = finalSavings - initialSavings;
            const savingsGrowthPercent = initialSavings > 0 ? (savingsGrowth / initialSavings) * 100 : 0;

            // Calculate total spending and growth
            const initialSpending = spendingData[0] || 0;
            const finalSpending = spendingData[spendingData.length - 1] || 0;
            const spendingGrowth = finalSpending - initialSpending;
            const spendingGrowthPercent = initialSpending > 0 ? (spendingGrowth / initialSpending) * 100 : 0;

            // Chart header DOM elements for both rows
            const chartMainValue = document.getElementById('chartMainValue');
            const chartSubtitle = document.getElementById('chartSubtitle');
            const chartGrowth = document.getElementById('chartGrowth');
            const chartSpendingValue = document.getElementById('chartSpendingValue');
            const chartSpendingSubtitle = document.getElementById('chartSpendingSubtitle');
            // chartSpendingGrowth removed - no longer displaying spending growth
            const chartDateDisplay = document.getElementById('chartDateDisplay');

            /**
             * Updates chart header for a given index showing both savings and spending values.
             * @param {number} index - The data index to display.
             */
            function updateChartHeader(index) {
                if (!chartMainValue || !chartSubtitle || !chartGrowth || 
                    !chartSpendingValue || !chartSpendingSubtitle) return;
                
                const saved = savingsData[index];
                const spent = spendingData[index];
                const dateLabel = labels[index];
                
                // Update date display at the top
                if (chartDateDisplay) {
                    chartDateDisplay.innerHTML = `<span class="chart-selected-date">${dateLabel}</span>`;
                    chartDateDisplay.classList.add('visible');
                }
                
                // Update savings row
                chartMainValue.textContent = formatCurrency(saved);
                chartSubtitle.textContent = `Saved`;
                
                // Calculate savings growth from start to this point
                const savingsGrowthToDate = saved - initialSavings;
                const savingsGrowthPercentToDate = initialSavings > 0 ? (savingsGrowthToDate / initialSavings) * 100 : 0;
                const savingsGrowthPrefix = savingsGrowthToDate >= 0 ? '+' : '';
                
                // Add period context for interactive view as well
                let periodText = '';
                switch (currentChartPeriod) {
                    case '1M': periodText = 'since last month'; break;
                    case '3M': periodText = 'past 3 months'; break;
                    case '6M': periodText = 'past 6 months'; break;
                    case 'YTD': periodText = 'year to date'; break;
                    case '1Y': periodText = 'past year'; break;
                    case 'ALL': periodText = 'all time'; break;
                    default: periodText = 'all time';
                }
                
                chartGrowth.textContent = `${savingsGrowthPrefix}${formatCurrency(savingsGrowthToDate)} (${savingsGrowthPrefix}${savingsGrowthPercentToDate.toFixed(1)}%) ${periodText}`;
                chartGrowth.className = 'chart-growth ' + (savingsGrowthToDate >= 0 ? 'positive' : 'negative');
                
                // Update spending row - just show current value
                chartSpendingValue.textContent = formatCurrency(spent);
                chartSpendingSubtitle.textContent = `Spent`;
            }

            /**
             * Resets chart header to show latest total values for both savings and spending.
             */
            function resetChartHeader() {
                if (!chartMainValue || !chartSubtitle || !chartGrowth || 
                    !chartSpendingValue || !chartSpendingSubtitle) return;
                
                // Hide date display
                if (chartDateDisplay) {
                    chartDateDisplay.classList.remove('visible');
                }
                
                // Update savings row with final values
                chartMainValue.textContent = formatCurrency(finalSavings);
                chartSubtitle.textContent = 'Saved';
                const savingsGrowthPrefix = savingsGrowth >= 0 ? '+' : '';
                
                // Add period context to the savings growth text
                let savingsPeriodText = '';
                switch (currentChartPeriod) {
                    case '1M': savingsPeriodText = 'past month'; break;
                    case '3M': savingsPeriodText = 'past 3 months'; break;
                    case '6M': savingsPeriodText = 'past 6 months'; break;
                    case 'YTD': savingsPeriodText = 'year to date'; break;
                    case '1Y': savingsPeriodText = 'past year'; break;
                    case 'ALL': savingsPeriodText = 'all time'; break;
                    default: savingsPeriodText = 'all time';
                }
                
                chartGrowth.textContent = `${savingsGrowthPrefix}${formatCurrency(savingsGrowth)} (${savingsGrowthPrefix}${savingsGrowthPercent.toFixed(1)}%) ${savingsPeriodText}`;
                chartGrowth.className = 'chart-growth ' + (savingsGrowth >= 0 ? 'positive' : 'negative');
                
                // Update spending row with final values - only showing the amount
                chartSpendingValue.textContent = formatCurrency(finalSpending);
                chartSpendingSubtitle.textContent = 'Spent';
            }

            // Set default header
            resetChartHeader();

            // Destroy previous chart instance if it exists
            if (spendingChart) {
                // Clean up any existing interaction state
                hideChartInteraction();
                spendingChart.destroy();
            }
            
            // Create enhanced gradient for savings (Wealthsimple style) with fade to transparent
            const savingsGradient = ctx.createLinearGradient(0, 0, 0, 400);
            savingsGradient.addColorStop(0, 'rgba(16, 185, 129, 0.25)'); // Green with transparency
            savingsGradient.addColorStop(0.6, 'rgba(16, 185, 129, 0.05)');
            savingsGradient.addColorStop(0.8, 'rgba(16, 185, 129, 0.02)');
            savingsGradient.addColorStop(1, 'rgba(16, 185, 129, 0)');
            
            
            spendingChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [
                        {
                            label: 'Saved',
                            data: savingsData,
                            borderColor: 'rgb(16, 185, 129)',
                            backgroundColor: savingsGradient,
                            tension: 0.6,
                            fill: true,
                            pointRadius: 0,
                            borderWidth: 3,
                            z: 10,
                            pointHitRadius: 20,
                            pointBackgroundColor: 'transparent',
                            pointBorderColor: 'transparent',
                            pointBorderWidth: 0
                        },
                        {
                            label: 'Spent',
                            data: spendingData,
                            borderColor: 'rgb(107, 114, 128)', // Gray
                            backgroundColor: 'transparent', // No fill
                            tension: 0.6,
                            fill: false, // No fill for spending
                            borderDash: [4, 4], // Dotted line
                            pointRadius: 0,
                            borderWidth: 2.5,
                            z: 5,
                            pointHitRadius: 15,
                            pointBackgroundColor: 'transparent',
                            pointBorderColor: 'transparent',
                            pointBorderWidth: 0
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false },
                        tooltip: { enabled: false }
                    },
                    scales: {
                        x: {
                            grid: { display: false },
                            ticks: {
                                display: false // Hide x-axis labels
                            },
                            border: { display: false }
                        },
                        y: {
                            grid: { display: false }, // Remove all horizontal grid lines
                            border: { display: false },
                            ticks: {
                                display: false // Hide y-axis labels
                            }
                        }
                    },
                    interaction: { intersect: false, mode: 'nearest' },
                    hover: { intersect: false, mode: 'nearest', enabled: false },
                    elements: {
                        point: {
                            hitRadius: 30,
                            hoverRadius: 0,
                            radius: 0,
                            hoverBackgroundColor: 'transparent',
                            hoverBorderColor: 'transparent',
                            hoverBorderWidth: 0
                        },
                        line: { tension: 0.6 }
                    }
                }
            });

            // --- INTERACTION: LONG PRESS THEN DRAG ---
            let interactionEnabled = false;
            let longPressTimeout = null;
            let lastActiveIndex = null;

            /**
             * Enables chart interaction and shows crosshair/tooltip at the given x position.
             * @param {number} x - The x coordinate relative to the chart canvas.
             */
            function enableChartInteraction(x) {
                interactionEnabled = true;
                const index = getNearestIndex(x);
                updateChartHeader(index);
                showChartInteraction(index);
                lastActiveIndex = index;
            }

            /**
             * Disables chart interaction and hides crosshair/tooltip.
             */
            function disableChartInteraction() {
                interactionEnabled = false;
                resetChartHeader();
                hideChartInteraction();
                lastActiveIndex = null;
            }

            const chartCanvas = ctx.canvas;

            // Remove all previous listeners (Chart.js re-creates canvas, so this is safe)
            chartCanvas.onmousedown = null;
            chartCanvas.onmousemove = null;
            chartCanvas.onmouseup = null;
            chartCanvas.onmouseleave = null;
            chartCanvas.onclick = null;
            chartCanvas.ontouchstart = null;
            chartCanvas.ontouchmove = null;
            chartCanvas.ontouchend = null;
            chartCanvas.ontouchcancel = null;

            // Mouse events: require 1-second long press before enabling drag
            chartCanvas.addEventListener('mousedown', function(e) {
                if (longPressTimeout) clearTimeout(longPressTimeout);
                longPressTimeout = setTimeout(() => {
                    const x = e.clientX - chartCanvas.getBoundingClientRect().left;
                    enableChartInteraction(x);
                }, 200); // 1 second long press required
            });
            chartCanvas.addEventListener('mousemove', function(e) {
                if (!interactionEnabled) return;
                const x = e.clientX - chartCanvas.getBoundingClientRect().left;
                const index = getNearestIndex(x);
                if (index !== lastActiveIndex) {
                    updateChartHeader(index);
                    showChartInteraction(index);
                    lastActiveIndex = index;
                }
            });
            chartCanvas.addEventListener('mouseup', function() {
                if (longPressTimeout) clearTimeout(longPressTimeout);
                if (interactionEnabled) disableChartInteraction();
            });
            chartCanvas.addEventListener('mouseleave', function() {
                if (longPressTimeout) clearTimeout(longPressTimeout);
                if (interactionEnabled) disableChartInteraction();
            });

            // Touch events: require 1-second long press before enabling drag
            // Use initial touch position to detect direction
            let initialTouchY = 0;
            let initialTouchX = 0;
            let touchDirection = null; // 'vertical' or 'horizontal'
            
            chartCanvas.addEventListener('touchstart', function(e) {
                if (longPressTimeout) clearTimeout(longPressTimeout);
                if (!e.touches || e.touches.length === 0) return;
                
                // Store initial touch position
                initialTouchX = e.touches[0].clientX;
                initialTouchY = e.touches[0].clientY;
                touchDirection = null; // Reset direction on new touch
                
                longPressTimeout = setTimeout(() => {
                    const x = e.touches[0].clientX - chartCanvas.getBoundingClientRect().left;
                    enableChartInteraction(x);
                }, 200); // 1 second long press required
            });
            
            chartCanvas.addEventListener('touchmove', function(e) {
                if (!e.touches || e.touches.length === 0) return;
                
                // If we haven't determined direction yet, do so based on movement
                if (touchDirection === null) {
                    const deltaX = Math.abs(e.touches[0].clientX - initialTouchX);
                    const deltaY = Math.abs(e.touches[0].clientY - initialTouchY);
                    
                    // If moving more vertically than horizontally, allow normal scroll
                    if (deltaY > deltaX && deltaY > 10) {
                        touchDirection = 'vertical';
                        if (longPressTimeout) clearTimeout(longPressTimeout);
                        return;
                    } else if (deltaX > 10) {
                        touchDirection = 'horizontal';
                    }
                }
                
                // If scrolling vertically, allow normal browser behavior
                if (touchDirection === 'vertical') return;
                
                // Only prevent default for horizontal movements when interaction is enabled
                if (interactionEnabled) {
                    e.preventDefault(); // Prevent scrolling when interacting with chart
                    const x = e.touches[0].clientX - chartCanvas.getBoundingClientRect().left;
                    const index = getNearestIndex(x);
                    if (index !== lastActiveIndex) {
                        updateChartHeader(index);
                        showChartInteraction(index);
                        // Enhanced haptic feedback - try multiple methods
                        // First try our utility
                        if (window.Haptics) {
                            window.Haptics.impact('medium');
                        }
                        // Also directly try Capacitor haptics
                        if (window.Capacitor && window.Capacitor.Plugins && window.Capacitor.Plugins.Haptics) {
                            window.Capacitor.Plugins.Haptics.impact({style: 'medium'});
                        }
                        // For iOS, make sure we trigger a click-like event that can engage haptics
                        const el = document.activeElement || document.body;
                        el.dispatchEvent(new CustomEvent('haptic', {bubbles: true}));
                        lastActiveIndex = index;
                    }
                }
            }, { passive: false }); // Need to set passive: false to call preventDefault
            chartCanvas.addEventListener('touchend', function() {
                if (longPressTimeout) clearTimeout(longPressTimeout);
                if (interactionEnabled) disableChartInteraction();
            });
            chartCanvas.addEventListener('touchcancel', function() {
                if (longPressTimeout) clearTimeout(longPressTimeout);
                if (interactionEnabled) disableChartInteraction();
            });

            // Helper functions to show/hide chart interaction effects
            function showChartInteraction(activeIndex) {
                if (!spendingChart || !spendingChart.data || !spendingChart.data.datasets) return;
                
                // Show only the active point with hollow shapes
                spendingChart.data.datasets.forEach((dataset, datasetIndex) => {
                    // Reset all point properties to ensure clean state
                    dataset.pointRadius = new Array(dataset.data.length).fill(0);
                    dataset.pointBackgroundColor = new Array(dataset.data.length).fill('transparent');
                    dataset.pointBorderColor = new Array(dataset.data.length).fill('transparent');
                    dataset.pointBorderWidth = new Array(dataset.data.length).fill(0);
                    dataset.pointStyle = new Array(dataset.data.length).fill('circle');
                    dataset.pointHoverRadius = new Array(dataset.data.length).fill(0);
                    dataset.pointHoverBackgroundColor = new Array(dataset.data.length).fill('transparent');
                    dataset.pointHoverBorderColor = new Array(dataset.data.length).fill('transparent');
                    dataset.pointHoverBorderWidth = new Array(dataset.data.length).fill(0);
                    
                    // Show only the active point with hollow shape
                    if (activeIndex >= 0 && activeIndex < dataset.data.length) {
                        if (datasetIndex === 0) {
                            // Savings dataset - hollow green circle
                            dataset.pointRadius[activeIndex] = 8;
                            dataset.pointBackgroundColor[activeIndex] = '#fff';
                            dataset.pointBorderColor[activeIndex] = 'rgb(16, 185, 129)';
                            dataset.pointBorderWidth[activeIndex] = 3;
                            dataset.pointStyle[activeIndex] = 'circle';
                            // Also set hover properties for the active point
                            dataset.pointHoverRadius[activeIndex] = 8;
                            dataset.pointHoverBackgroundColor[activeIndex] = '#fff';
                            dataset.pointHoverBorderColor[activeIndex] = 'rgb(16, 185, 129)';
                            dataset.pointHoverBorderWidth[activeIndex] = 3;
                        } else {
                            // Spending dataset - hollow gray square
                            dataset.pointRadius[activeIndex] = 7;
                            dataset.pointBackgroundColor[activeIndex] = '#fff';
                            dataset.pointBorderColor[activeIndex] = 'rgb(107, 114, 128)';
                            dataset.pointBorderWidth[activeIndex] = 2.5;
                            dataset.pointStyle[activeIndex] = 'rect';
                            // Also set hover properties for the active point
                            dataset.pointHoverRadius[activeIndex] = 7;
                            dataset.pointHoverBackgroundColor[activeIndex] = '#fff';
                            dataset.pointHoverBorderColor[activeIndex] = 'rgb(107, 114, 128)';
                            dataset.pointHoverBorderWidth[activeIndex] = 2.5;
                        }
                    }
                    // Keep normal line width
                    dataset.borderWidth = datasetIndex === 0 ? 3 : 2.5;
                });
                
                // Show and position the vertical crosshair line
                const chartOverlay = document.getElementById('chartOverlay');
                const chartCrosshair = document.getElementById('chartCrosshair');
                
                if (chartOverlay && chartCrosshair) {
                    const xScale = spendingChart.scales.x;
                    const pixelX = xScale.getPixelForValue(activeIndex);
                    
                    // Position the crosshair at the selected point
                    chartCrosshair.style.left = `${pixelX}px`;
                    // Ensure overlay is visible immediately on interaction
                    chartOverlay.classList.add('visible');
                }
                
                spendingChart.update('none'); // Update without animation for immediate response
            }

            /**
             * Hides chart interaction effects (crosshair, tooltip) with a delay for better UX.
             */
            function hideChartInteraction() {
                if (!spendingChart || !spendingChart.data || !spendingChart.data.datasets) return;
                
                // Hide date display
                if (chartDateDisplay) {
                    chartDateDisplay.classList.remove('visible');
                }
                
                // Completely reset all data points to ensure no sticky dots
                spendingChart.data.datasets.forEach((dataset, datasetIndex) => {
                    // Reset all point properties to clean state
                    dataset.pointRadius = 0; // Hide all points
                    dataset.pointBackgroundColor = 'transparent';
                    dataset.pointBorderColor = 'transparent';
                    dataset.pointBorderWidth = 0;
                    dataset.borderWidth = datasetIndex === 0 ? 3 : 2.5; // Keep normal line width
                });
                
                // Hide the vertical crosshair line with a delay
                const chartOverlay = document.getElementById('chartOverlay');
                if (chartOverlay) {
                    setTimeout(() => {
                        chartOverlay.classList.remove('visible');
                    }, 200); // 200ms delay for smoother UX
                }
                spendingChart.update('none'); // Update without animation for immediate response
            }
        }
        
        // Global variables
        currentPeriodMode = 'month'; // or 'month'
        savingsAccounts = [
            { id: 'checking', name: 'Checking' },
            { id: 'savings', name: 'Savings' },
            { id: 'emergency', name: 'Emergency Fund' }
        ];
        
        function updateCategoryChart() {
            // Get expenses and filter by time range
            const expenses = loadExpenses();
            const dateRange = getDateRangeForTimeRange(currentTimeRange);
            const startDate = dateRange.startDate;
            const endDate = dateRange.endDate;
            
            // Update time range label
            const timeRangeLabel = document.getElementById('categoryChartTimeRange');
            if (timeRangeLabel) {
                timeRangeLabel.textContent = getTimeRangeLabel(currentTimeRange);
            }
            
            // Filter expenses by date range
            const filteredExpenses = {};
            Object.keys(expenses).forEach(dateKey => {
                const date = new Date(dateKey);
                if (date >= startDate && date <= endDate) {
                    filteredExpenses[dateKey] = expenses[dateKey];
                }
            });
            
            // Calculate category totals
            const categoryTotals = {};
            Object.values(filteredExpenses).flat().forEach(expense => {
                const category = expense.category || 'Other';
                categoryTotals[category] = (categoryTotals[category] || 0) + expense.amount;
            });
            
            // Get top 6 categories
            const sortedCategories = Object.entries(categoryTotals)
                .sort(([,a], [,b]) => b - a)
                .slice(0, 6);
            
            // Prepare chart data
            const labels = sortedCategories.map(([category]) => category);
            const data = sortedCategories.map(([,total]) => total);
            const colors = [
                '#3b82f6', // blue
                '#ef4444', // red
                '#f59e0b', // amber
                '#10b981', // emerald
                '#8b5cf6', // violet
                '#f97316'  // orange
            ];
            
            // Get chart canvas
            const ctx = document.getElementById('categoryChart').getContext('2d');
            
            // Destroy existing chart if it exists
            if (categoryChart) {
                categoryChart.destroy();
            }
            
            // Create new chart
            categoryChart = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Spending',
                        data: data,
                        backgroundColor: colors.slice(0, labels.length),
                        borderColor: colors.slice(0, labels.length),
                        borderWidth: 1,
                        borderRadius: 8,
                        borderSkipped: false
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    resizeDelay: 0,
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `$${context.parsed.y.toFixed(2)}`;
                                }
                            }
                        }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            suggestedMax: data.length > 0 ? Math.max(...data) * 1.1 : 100, // Add 10% padding above highest value
                            ticks: {
                                callback: function(value) {
                                    return '$' + value.toFixed(0);
                                }
                            },
                            grid: {
                                color: 'rgba(0, 0, 0, 0.05)'
                            }
                        },
                        x: {
                            grid: {
                                display: false
                            },
                            ticks: {
                                maxRotation: 45,
                                minRotation: 0
                            }
                        }
                    }
                }
            });
            
            // Force resize after chart creation to ensure proper dimensions
            setTimeout(() => {
                if (categoryChart) {
                    categoryChart.resize();
                }
            }, 100);
        }
        
        let currentChartIndex = 0;
        let previousCategoryAmount = 0;
        
        function showChart(index) {
            console.log('showChart called with index:', index);
            const carousel = document.getElementById('chartCarousel');
            console.log('Carousel element:', carousel);
            if (!carousel) return;
            
            // Move carousel to show selected chart
            const translateX = index * -50; // Each slide is 50% width
            console.log('Setting translateX to:', translateX + '%');
            carousel.style.transform = `translateX(${translateX}%)`;
            
            // Update dots
            const dots = document.querySelectorAll('.chart-dots .dot');
            console.log('Found dots:', dots.length);
            dots.forEach((dot, i) => {
                if (i === index) {
                    dot.classList.add('active');
                } else {
                    dot.classList.remove('active');
                }
            });
            
            // Update slide active states
            const slides = document.querySelectorAll('.chart-slide');
            console.log('Found slides:', slides.length);
            slides.forEach((slide, i) => {
                if (i === index) {
                    slide.classList.add('active');
                } else {
                    slide.classList.remove('active');
                }
            });
            
            currentChartIndex = index;
            console.log('Updated currentChartIndex to:', currentChartIndex);
            
            // Initialize chart if needed
            if (index === 1 && typeof updateCategoryChart === 'function') {
                updateCategoryChart();
            }
        }
        
        function initializeChartSwipe() {
            console.log(' Initializing chart swipe functionality');
            // Look for the budgetDisplay chart carousel
            const budgetDisplay = document.getElementById('budgetDisplay');
            const carouselContainer = budgetDisplay ? budgetDisplay.querySelector('.chart-carousel') : null;
            if (!carouselContainer) {
                console.log(' No chart carousel found in budgetDisplay');
                return;
            }
            console.log(' Found chart carousel, setting up swipe events');
            
            let startX = 0;
            let startY = 0;
            let isScrolling = false;
            let hasSwiped = false;
            let isDragging = false;
            
            // Use document-level events to avoid interference from Chart.js
            function isInsideCarousel(x, y) {
                const rect = carouselContainer.getBoundingClientRect();
                return x >= rect.left && x <= rect.right && y >= rect.top && y <= rect.bottom;
            }
            
            document.addEventListener('mousedown', function(e) {
                if (isInsideCarousel(e.clientX, e.clientY)) {
                    isDragging = true;
                    startX = e.clientX;
                    startY = e.clientY;
                    isScrolling = false;
                    hasSwiped = false;
                    carouselContainer.style.cursor = 'grabbing';
                    e.preventDefault();
                }
            });
            
            document.addEventListener('mousemove', function(e) {
                if (!isDragging || !startX || !startY) return;
                
                const currentX = e.clientX;
                const currentY = e.clientY;
                const diffX = startX - currentX;
                const diffY = startY - currentY;
                
                if (Math.abs(diffY) > Math.abs(diffX)) {
                    isScrolling = true;
                    return;
                }
                
                if (!isScrolling && !hasSwiped && Math.abs(diffX) > 50) {
                    hasSwiped = true;
                    if (diffX > 0 && currentChartIndex < 1) {
                        switchToChart(currentChartIndex + 1);
                    } else if (diffX < 0 && currentChartIndex > 0) {
                        switchToChart(currentChartIndex - 1);
                    }
                }
            });
            
            document.addEventListener('mouseup', function() {
                if (isDragging) {
                    isDragging = false;
                    startX = 0;
                    startY = 0;
                    isScrolling = false;
                    hasSwiped = false;
                    carouselContainer.style.cursor = 'grab';
                }
            });
            
            // Touch events for mobile
            function handleTouchStart(e) {
                console.log(' Touch start detected');
                startX = e.touches[0].clientX;
                startY = e.touches[0].clientY;
                isScrolling = false;
                hasSwiped = false;
            }
            
            carouselContainer.addEventListener('touchstart', handleTouchStart);
            
            // Note: budgetDisplay uses bar charts, not a canvas, so we only need container events
            
            function handleTouchMove(e) {
                if (!startX || !startY) return;
                
                const currentX = e.touches[0].clientX;
                const currentY = e.touches[0].clientY;
                const diffX = startX - currentX;
                const diffY = startY - currentY;
                
                console.log(' Touch move - diffX:', diffX, 'diffY:', diffY, 'currentChartIndex:', currentChartIndex);
                
                // Determine scroll direction
                if (Math.abs(diffY) > Math.abs(diffX)) {
                    isScrolling = true;
                    return;
                }
                
                // Prevent default to stop scrolling during horizontal swipe
                if (!isScrolling && Math.abs(diffX) > 20) {
                    e.preventDefault();
                }
                
                // Trigger swipe on sufficient horizontal movement
                if (!isScrolling && !hasSwiped && Math.abs(diffX) > 50) {
                    console.log(' Swipe triggered! diffX:', diffX, 'currentChartIndex:', currentChartIndex);
                    hasSwiped = true;
                    if (diffX > 0 && currentChartIndex < 1) {
                        console.log(' Swiping to next chart (index ' + (currentChartIndex + 1) + ')');
                        switchToChart(currentChartIndex + 1);
                    } else if (diffX < 0 && currentChartIndex > 0) {
                        console.log(' Swiping to previous chart (index ' + (currentChartIndex - 1) + ')');
                        switchToChart(currentChartIndex - 1);
                    }
                }
            }
            
            carouselContainer.addEventListener('touchmove', handleTouchMove, { passive: false });
            
            function handleTouchEnd() {
                startX = 0;
                startY = 0;
                isScrolling = false;
                hasSwiped = false;
            }
            
            carouselContainer.addEventListener('touchend', handleTouchEnd);
            
            // Add document click listener to clear selections when clicking outside charts
            document.addEventListener('click', function(e) {
                // Check if click is outside both chart containers
                const monthlyChart = document.getElementById('monthlySpendingChart');
                const categoryChart = document.getElementById('categorySpendingChart');
                
                if (monthlyChart && categoryChart) {
                    const isInsideMonthly = monthlyChart.contains(e.target);
                    const isInsideCategory = categoryChart.contains(e.target);
                    
                    if (!isInsideMonthly && !isInsideCategory) {
                        clearChartSelections();
                    }
                }
            });
        }
        
        function getCurrentPeriodKey() {
            if (currentPeriodMode === 'today') {
                return getCurrentDate();
            } else {
                return `${selectedMonthDate.getFullYear()}-${String(selectedMonthDate.getMonth() + 1).padStart(2, '0')}`;
            }
        }
        
        function getCurrentMonth() {
            // Hard-coded date for consistency: July 7, 2025
            const now = new Date(2025, 6, 7); // Month is 0-indexed (6 = July)
            return `${now.getFullYear()}-${String(now.getMonth() + 1).padStart(2, '0')}`;
        }
        
        function getSelectedSaveMonthKey() {
            // Ensure the month is zero-padded (e.g., "01" for January, not "1")
            const month = String(selectedSaveMonthDate.getMonth() + 1).padStart(2, '0');
            const year = selectedSaveMonthDate.getFullYear();
            const key = `${year}-${month}`;
            console.log(`Generated month key: ${key} for date: ${selectedSaveMonthDate.toISOString()}`);
            return key;
        }
        
        function isCurrentMonth() {
            const now = new Date(2025, 6, 7); // Hard-coded to July 7, 2025
            return selectedMonthDate.getMonth() === now.getMonth() && 
                   selectedMonthDate.getFullYear() === now.getFullYear();
        }
        
        function loadExpenses() {
            const stored = localStorage.getItem(EXPENSES_KEY);
            if (stored) {
                try {
                    const parsed = JSON.parse(stored);
                    if (parsed && typeof parsed === 'object' && !Array.isArray(parsed)) {
                        return parsed;
                    }
                } catch (e) {
                    // Ignore parse errors and fall through to return empty object
                }
            }
            return {};
        }
        
        // Monthly spending chart functions
        function calculateMonthlySpending() {
            const expenses = loadExpenses();
            const monthlyTotals = {};
            
            // Initialize months from January to current month
            const currentDate = new Date();
            const currentYear = currentDate.getFullYear();
            const currentMonth = currentDate.getMonth();
            
            for (let month = 0; month <= currentMonth; month++) {
                const key = `${currentYear}-${month}`;
                monthlyTotals[key] = 0;
            }
            
            // Calculate totals for each month
            Object.keys(expenses).forEach(dateKey => {
                const date = new Date(dateKey);
                if (date.getFullYear() === currentYear && date.getMonth() <= currentMonth) {
                    const monthKey = `${date.getFullYear()}-${date.getMonth()}`;
                    const dayExpenses = expenses[dateKey];
                    const dayTotal = dayExpenses.reduce((sum, expense) => sum + (expense.amount || 0), 0);
                    monthlyTotals[monthKey] += dayTotal;
                }
            });
            
            return monthlyTotals;
        }
        
        function generateMonthlyChart() {
            console.log('generateMonthlyChart called');
            const chartContainer = document.getElementById('monthlySpendingChart');
            if (!chartContainer) {
                console.error('Monthly chart container not found!');
                return;
            }
            console.log('Chart container found:', chartContainer);
            
            const monthlyTotals = calculateMonthlySpending();
            console.log('Monthly totals:', monthlyTotals);
            const currentDate = new Date();
            const currentMonth = currentDate.getMonth();
            const currentYear = currentDate.getFullYear();
            
            // Clear existing content
            chartContainer.innerHTML = '';
            
            // Find max value for scaling
            const maxValue = Math.max(...Object.values(monthlyTotals), 1);
            console.log('Max value for scaling:', maxValue);
            
            // Month names
            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
            
            // Generate bars for each month
            console.log(`Generating bars for months 0 to ${currentMonth}`);
            for (let month = 0; month <= currentMonth; month++) {
                const monthKey = `${currentYear}-${month}`;
                const amount = monthlyTotals[monthKey] || 0;
                const height = Math.max((amount / maxValue) * 100, 10); // Min height 10px
                console.log(`Month ${month}: amount=${amount}, height=${height}px`);
                
                const chartBar = document.createElement('div');
                chartBar.className = 'chart-bar spending-bar';
                chartBar.dataset.month = month;
                chartBar.dataset.year = currentYear;
                
                // Add current month class (but don't auto-select)
                if (month === currentMonth) {
                    chartBar.classList.add('current-month');
                }
                // Only add selected class if month was manually selected
                if (selectedMonth !== null && month === selectedMonth && currentYear === selectedYear) {
                    chartBar.classList.add('selected');
                }
                
                // Month label
                const barAmount = document.createElement('div');
                barAmount.className = 'bar-amount';
                barAmount.textContent = monthNames[month];
                
                // Bar visual
                const barVisual = document.createElement('div');
                barVisual.className = 'bar-visual spending-visual';
                barVisual.style.height = `${height}px`;
                
                // Click handler for month selection
                chartBar.onclick = (event) => {
                    console.log('Bar clicked for month:', month);
                    event.preventDefault();
                    event.stopPropagation();
                    selectChartMonth(month, currentYear);
                };
                
                chartBar.appendChild(barVisual);
                chartBar.appendChild(barAmount);
                chartContainer.appendChild(chartBar);
            }
            
            // Show current month total by default (but don't select the bar)
            const currentMonthKey = `${currentYear}-${currentMonth}`;
            const currentMonthTotal = monthlyTotals[currentMonthKey] || 0;
            previousTotal = currentMonthTotal;
            
            // Update display to show current month amount
            const totalElement = document.getElementById('selectedMonthTotal');
            if (totalElement) {
                const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
                totalElement.innerHTML = `
                    <span class="month-name">${monthNames[currentMonth]} ${currentYear}</span>
                    <span class="month-amount">$${currentMonthTotal.toFixed(2)}</span>
                `;
            }
            
            // Scroll to current month
            scrollToCurrentMonth();
        }
        
        function selectChartMonth(month, year) {
            selectedMonth = month;
            selectedYear = year;
            
            const chartContainer = document.getElementById('monthlySpendingChart');
            const chartBars = document.querySelectorAll('#monthlySpendingChart .chart-bar');
            
            // Add has-selection class to container for fade effect
            chartContainer.classList.add('has-selection');
            
            // Update selected state
            chartBars.forEach(bar => {
                bar.classList.remove('selected');
                if (parseInt(bar.dataset.month) === month && parseInt(bar.dataset.year) === year) {
                    bar.classList.add('selected');
                }
            });
            
            // Update total display only (don't trigger other updates)
            updateSelectedMonthTotal();
        }
        
        function animateCountUp(element, startValue, endValue, duration = 300) {
            const startTime = performance.now();
            const difference = endValue - startValue;
            
            function updateCount(currentTime) {
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Use easeOutQuad for more subtle animation
                const easeProgress = 1 - Math.pow(1 - progress, 2);
                const currentValue = startValue + (difference * easeProgress);
                
                element.textContent = `$${currentValue.toFixed(2)}`;
                
                if (progress < 1) {
                    requestAnimationFrame(updateCount);
                }
            }
            
            requestAnimationFrame(updateCount);
        }
        
        function updateSelectedMonthTotal() {
            console.log('updateSelectedMonthTotal - selectedMonth:', selectedMonth, 'selectedYear:', selectedYear);
            const monthlyTotals = calculateMonthlySpending();
            const monthKey = `${selectedYear}-${selectedMonth}`;
            const total = monthlyTotals[monthKey] || 0;
            console.log('Updating total for:', monthKey, 'Total:', total);
            console.log('Available monthly totals:', Object.keys(monthlyTotals));
            
            const totalElement = document.getElementById('selectedMonthTotal');
            if (totalElement) {
                const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
                
                // Update the month name immediately
                totalElement.innerHTML = `
                    <span class="month-name">${monthNames[selectedMonth]} ${selectedYear}</span>
                    <span class="month-amount" id="animatedAmount">$${previousTotal.toFixed(2)}</span>
                `;
                
                // Animate the amount
                const amountElement = document.getElementById('animatedAmount');
                if (amountElement) {
                    animateCountUp(amountElement, previousTotal, total);
                }
                
                console.log('Updated total element with month:', monthNames[selectedMonth], 'animating from:', previousTotal, 'to:', total);
                
                // Update previous total for next animation
                previousTotal = total;
            } else {
                console.error('selectedMonthTotal element not found!');
            }
        }
        
        function scrollToCurrentMonth() {
            const chartContainer = document.getElementById('monthlySpendingChart');
            const currentMonthBar = chartContainer.querySelector('.chart-bar.current-month');
            
            if (currentMonthBar && chartContainer) {
                // Scroll to show current month in center
                const containerWidth = chartContainer.offsetWidth;
                const barOffsetLeft = currentMonthBar.offsetLeft;
                const barWidth = currentMonthBar.offsetWidth;
                const scrollPosition = barOffsetLeft - (containerWidth / 2) + (barWidth / 2);
                
                chartContainer.scrollLeft = Math.max(0, scrollPosition);
            }
        }
        
        function switchToChart(index) {
            currentChartIndex = index;
            
            // Find the budgetDisplay carousel specifically 
            const budgetDisplay = document.getElementById('budgetDisplay');
            const carousel = budgetDisplay ? budgetDisplay.querySelector('.chart-carousel') : null;
            
            if (carousel) {
                // Transform the carousel
                const translateX = index * -50; // Each slide is 50% width
                carousel.style.transform = `translateX(${translateX}%)`;
            }
            
            // Update subtitle based on current chart
            const subtitle = budgetDisplay ? budgetDisplay.querySelector('.section-subtitle') : null;
            if (subtitle) {
                subtitle.textContent = index === 0 ? 'Monthly Overview' : 'Category Spending';
            }
            
            // Update dots in budgetDisplay
            const dots = budgetDisplay ? budgetDisplay.querySelectorAll('.chart-dots .dot') : [];
            dots.forEach((dot, i) => {
                dot.classList.toggle('active', i === index);
            });
            
            // Update slide active states in budgetDisplay
            const slides = budgetDisplay ? budgetDisplay.querySelectorAll('.chart-slide') : [];
            slides.forEach((slide, i) => {
                slide.classList.toggle('active', i === index);
            });
            
            // Generate appropriate chart content
            if (index === 1) {
                generateCategoryChart();
            }
        }
        
        function generateCategoryChart() {
            const chartContainer = document.getElementById('categorySpendingChart');
            if (!chartContainer) return;
            
            const expenses = loadExpenses();
            const categoryTotals = {};
            
            // Calculate category totals for the selected time range
            const { startDate, endDate } = getDateRangeForTimeRange(currentTimeRange);
            const startDateStr = startDate.toISOString().split('T')[0];
            const endDateStr = endDate.toISOString().split('T')[0];
            
            Object.keys(expenses).forEach(dateKey => {
                if (dateKey >= startDateStr && dateKey <= endDateStr) {
                    const dayExpenses = expenses[dateKey];
                    dayExpenses.forEach(expense => {
                        const category = expense.category || 'other';
                        categoryTotals[category] = (categoryTotals[category] || 0) + (expense.amount || 0);
                    });
                }
            });
            
            // Get top 6 categories
            const sortedCategories = Object.entries(categoryTotals)
                .sort(([,a], [,b]) => b - a)
                .slice(0, 6);
            
            // Clear existing content
            chartContainer.innerHTML = '';
            
            if (sortedCategories.length === 0) {
                chartContainer.innerHTML = '<div style="text-align: center; color: hsl(var(--muted-foreground)); padding: 40px;">No spending data for this period</div>';
                return;
            }
            
            // Category CSS class mapping
            const categoryClasses = [
                'food',          // Orange
                'transportation', // Blue  
                'health',        // Green
                'entertainment', // Purple
                'shopping',      // Amber -> Red (swapped)
                'utilities',     // Red -> Orange (swapped)
                'other'          // Gray
            ];
            
            // Find max value for scaling
            const maxValue = Math.max(...sortedCategories.map(([,amount]) => amount), 1);
            
            // Generate bars for each category
            sortedCategories.forEach(([category, amount], index) => {
                const height = Math.max((amount / maxValue) * 100, 10);
                const categoryClass = categoryClasses[index % categoryClasses.length];
                
                const chartBar = document.createElement('div');
                chartBar.className = 'chart-bar category-bar';
                chartBar.dataset.category = category;
                
                // Category icon (using emoji for now)
                const barAmount = document.createElement('div');
                barAmount.className = 'bar-amount';
                barAmount.innerHTML = `<span class="bar-amount-icon">${getCategoryEmoji(category)}</span>`;
                
                // Bar visual
                const barVisual = document.createElement('div');
                barVisual.className = `bar-visual category-visual ${categoryClass}`;
                barVisual.style.height = `${height}px`;
                
                // Click handler for category selection
                chartBar.onclick = (event) => {
                    event.preventDefault();
                    event.stopPropagation();
                    selectCategory(category, amount);
                };
                
                chartBar.appendChild(barVisual);
                chartBar.appendChild(barAmount);
                chartContainer.appendChild(chartBar);
            });
            
            // Update category total display
            updateSelectedCategoryTotal();
            
            // Initialize Lucide icons for the new category icons
            if (window.lucide && typeof window.lucide.createIcons === 'function') {
                window.lucide.createIcons();
            }
        }
        
        function fadeChartUpdate(chartContainer, updateFunction) {
            if (!chartContainer) return;
            
            // Start fade out
            chartContainer.classList.add('chart-fade-transition');
            
            // After fade out, update content and fade back in
            setTimeout(() => {
                updateFunction();
                chartContainer.classList.add('chart-fade-in');
                
                // Remove classes after animation
                setTimeout(() => {
                    chartContainer.classList.remove('chart-fade-transition', 'chart-fade-in');
                }, 200);
            }, 100); // Half the transition time for smooth crossfade
        }

        function slideChartUpdate(chartContainer, updateFunction) {
            if (!chartContainer) return;
            
            // Start slide out to right
            chartContainer.classList.add('chart-fade-slide-out');
            
            // After slide out, update content and slide in from left
            setTimeout(() => {
                updateFunction();
                chartContainer.classList.remove('chart-fade-slide-out');
                chartContainer.classList.add('chart-fade-slide-in');
                
                // Remove classes after animation
                setTimeout(() => {
                    chartContainer.classList.remove('chart-fade-slide-in');
                }, 300);
            }, 300); // Wait for slide out animation to complete
        }

        function staggeredBarUpdate(chartContainer, updateFunction) {
            if (!chartContainer) return;
            
            // Update content immediately
            updateFunction();
            
            // Apply staggered animation to all chart bars
            const chartBars = chartContainer.querySelectorAll('.chart-bar');
            chartBars.forEach((bar, index) => {
                // Set initial state
                bar.style.opacity = '0';
                
                // Apply staggered animation with delay
                setTimeout(() => {
                    bar.classList.add('chart-bar-stagger-in');
                    
                    // Clean up class after animation
                    setTimeout(() => {
                        bar.classList.remove('chart-bar-stagger-in');
                        bar.style.opacity = '';
                    }, 300);
                }, index * 40); // 40ms delay between each bar
            });
        }

        function getCategoryColorFromBar(categoryBar) {
            // Get the category visual element to determine its CSS class
            const categoryVisual = categoryBar.querySelector('.category-visual');
            if (!categoryVisual) return '#6b7280';
            
            // Map CSS classes to their corresponding colors
            const classColorMap = {
                'food': '#f59e0b',
                'transportation': '#3b82f6', 
                'health': '#10b981',
                'entertainment': '#8b5cf6',
                'shopping': '#ef4444',
                'utilities': '#f97316',
                'other': '#6b7280'
            };
            
            // Check which category class this visual has
            for (const cssClass of Object.keys(classColorMap)) {
                if (categoryVisual.classList.contains(cssClass)) {
                    return classColorMap[cssClass];
                }
            }
            
            return '#6b7280'; // default color
        }

        function selectCategory(category, amount) {
            const chartContainer = document.getElementById('categorySpendingChart');
            const chartBars = document.querySelectorAll('#categorySpendingChart .chart-bar');
            
            // Add has-selection class to container for fade effect
            chartContainer.classList.add('has-selection');
            
            // Update selected state and icon colors
            chartBars.forEach(bar => {
                bar.classList.remove('selected');
                const barIcon = bar.querySelector('.bar-amount-icon svg');
                if (bar.dataset.category === category) {
                    bar.classList.add('selected');
                    // Change icon color to match the actual bar color
                    if (barIcon) {
                        const color = getCategoryColorFromBar(bar);
                        barIcon.style.setProperty('color', color, 'important');
                    }
                } else {
                    // Reset other icons to default color
                    if (barIcon) {
                        barIcon.style.color = '';
                    }
                }
            });
            
            // Update total display with animation
            const totalElement = document.getElementById('selectedCategoryTotal');
            if (totalElement) {
                const categoryName = category.charAt(0).toUpperCase() + category.slice(1).replace('_', ' ');
                totalElement.innerHTML = `
                    <span class="month-name">${categoryName}</span>
                    <span class="month-amount" id="animatedCategoryAmount">$${previousCategoryAmount.toFixed(2)}</span>
                `;
                
                // Animate the amount
                const amountElement = document.getElementById('animatedCategoryAmount');
                if (amountElement) {
                    animateCountUp(amountElement, previousCategoryAmount, amount);
                }
                
                previousCategoryAmount = amount;
            }
        }
        
        function calculateTotalSpending(expenses) {
            return expenses.reduce((total, expense) => total + parseFloat(expense.amount || 0), 0);
        }
        
        function clearChartSelections() {
            // Clear monthly chart selection
            const monthlyContainer = document.getElementById('monthlySpendingChart');
            const monthlyBars = document.querySelectorAll('#monthlySpendingChart .chart-bar');
            if (monthlyContainer) {
                monthlyContainer.classList.remove('has-selection');
                monthlyBars.forEach(bar => bar.classList.remove('selected'));
                
                // Reset selected month/year to null so next selection animates properly
                selectedMonth = null;
                selectedYear = null;
                
                // Show current month + year by default
                const totalElement = document.getElementById('selectedMonthTotal');
                if (totalElement) {
                    const currentDate = new Date();
                    const currentMonth = currentDate.getMonth();
                    const currentYear = currentDate.getFullYear();
                    const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'];
                    
                    const monthlyTotals = calculateMonthlySpending();
                    const currentMonthKey = `${currentYear}-${currentMonth}`;
                    const currentMonthTotal = monthlyTotals[currentMonthKey] || 0;
                    
                    totalElement.innerHTML = `
                        <span class="month-name">${monthNames[currentMonth]} ${currentYear}</span>
                        <span class="month-amount" id="animatedAmount">$${previousTotal.toFixed(2)}</span>
                    `;
                    
                    // Animate to current month total
                    const amountElement = document.getElementById('animatedAmount');
                    if (amountElement) {
                        animateCountUp(amountElement, previousTotal, currentMonthTotal);
                    }
                    
                    previousTotal = currentMonthTotal;
                }
            }
            
            // Clear category chart selection
            const categoryContainer = document.getElementById('categorySpendingChart');
            const categoryBars = document.querySelectorAll('#categorySpendingChart .chart-bar');
            if (categoryContainer) {
                categoryContainer.classList.remove('has-selection');
                categoryBars.forEach(bar => {
                    bar.classList.remove('selected');
                    // Reset icon color to default
                    const barIcon = bar.querySelector('.bar-amount-icon svg');
                    if (barIcon) {
                        barIcon.style.color = '';
                    }
                });
                
                // Show total spend for displayed categories with animation
                const totalElement = document.getElementById('selectedCategoryTotal');
                if (totalElement) {
                    // Calculate total for just the categories displayed in the chart
                    const expenses = loadExpenses();
                    const categoryTotals = {};
                    
                    // Calculate category totals for the selected time range (same logic as generateCategoryChart)
                    const { startDate, endDate } = getDateRangeForTimeRange(currentTimeRange);
                    const startDateStr = startDate.toISOString().split('T')[0];
                    const endDateStr = endDate.toISOString().split('T')[0];
                    
                    Object.keys(expenses).forEach(dateKey => {
                        if (dateKey >= startDateStr && dateKey <= endDateStr) {
                            const dayExpenses = expenses[dateKey];
                            dayExpenses.forEach(expense => {
                                const category = expense.category || 'other';
                                categoryTotals[category] = (categoryTotals[category] || 0) + (expense.amount || 0);
                            });
                        }
                    });
                    
                    // Sum ALL categories for the time range, not just the displayed ones
                    const totalCategorySpend = Object.values(categoryTotals).reduce((sum, amount) => sum + amount, 0);
                    
                    totalElement.innerHTML = `
                        <span class="month-name">Total Spend</span>
                        <span class="month-amount" id="animatedCategoryAmount">$${previousCategoryAmount.toFixed(2)}</span>
                    `;
                    
                    // Animate to total category spend
                    const amountElement = document.getElementById('animatedCategoryAmount');
                    if (amountElement) {
                        animateCountUp(amountElement, previousCategoryAmount, totalCategorySpend);
                    }
                    
                    previousCategoryAmount = totalCategorySpend;
                }
            }
        }
        
        function updateSelectedCategoryTotal() {
            // Show total spend for displayed categories by default
            const totalElement = document.getElementById('selectedCategoryTotal');
            if (totalElement) {
                // Calculate total for just the categories displayed in the chart (same logic as clearChartSelections)
                const expenses = loadExpenses();
                const categoryTotals = {};
                
                // Calculate category totals for the selected time range
                const { startDate, endDate } = getDateRangeForTimeRange(currentTimeRange);
                const startDateStr = startDate.toISOString().split('T')[0];
                const endDateStr = endDate.toISOString().split('T')[0];
                
                Object.keys(expenses).forEach(dateKey => {
                    if (dateKey >= startDateStr && dateKey <= endDateStr) {
                        const dayExpenses = expenses[dateKey];
                        dayExpenses.forEach(expense => {
                            const category = expense.category || 'other';
                            categoryTotals[category] = (categoryTotals[category] || 0) + (expense.amount || 0);
                        });
                    }
                });
                
                // Sum ALL categories for the time range, not just the displayed ones
                const totalCategorySpend = Object.values(categoryTotals).reduce((sum, amount) => sum + amount, 0);
                
                totalElement.innerHTML = `
                    <span class="month-name">Total Spend</span>
                    <span class="month-amount">$${totalCategorySpend.toFixed(2)}</span>
                `;
                
                // Initialize previous amount for animations
                previousCategoryAmount = totalCategorySpend;
            }
        }
        
        function updateSelectedCategoryTotalOld() {
            // Show total for first category by default
            const firstBar = document.querySelector('#categorySpendingChart .chart-bar');
            if (firstBar) {
                const category = firstBar.dataset.category;
                const expenses = loadExpenses();
                const categoryTotals = {};
                
                // Recalculate for selected time range
                const { startDate, endDate } = getDateRangeForTimeRange(currentTimeRange);
                const startDateStr = startDate.toISOString().split('T')[0];
                const endDateStr = endDate.toISOString().split('T')[0];
                
                Object.keys(expenses).forEach(dateKey => {
                    if (dateKey >= startDateStr && dateKey <= endDateStr) {
                        const dayExpenses = expenses[dateKey];
                        dayExpenses.forEach(expense => {
                            const expenseCategory = expense.category || 'other';
                            categoryTotals[expenseCategory] = (categoryTotals[expenseCategory] || 0) + (expense.amount || 0);
                        });
                    }
                });
                
                const amount = categoryTotals[category] || 0;
                selectCategory(category, amount);
            }
        }
        
        function initializeMonthPicker() {
            initializeDateDropdowns();
        }
        
        function initializeDateDropdowns() {
            const yearDropdown = document.getElementById('yearDropdown');
            if (!yearDropdown) return;
            
            yearDropdown.innerHTML = '';
            
            // Generate years (2 years back to current year)
            const currentYear = new Date(2025, 6, 7).getFullYear(); // Hard-coded to July 7, 2025
            for (let year = currentYear - 2; year <= currentYear; year++) {
                const option = document.createElement('option');
                option.value = year;
                option.textContent = year;
                if (year === selectedMonthDate.getFullYear()) {
                    option.selected = true;
                }
                yearDropdown.appendChild(option);
            }
            
            // Set month dropdown
            const monthDropdown = document.getElementById('monthDropdown');
            if (monthDropdown) {
                monthDropdown.value = selectedMonthDate.getMonth();
            }
            
            // Add event listeners
            yearDropdown.addEventListener('change', (e) => {
                selectedMonthDate.setFullYear(parseInt(e.target.value));
                updatePeriodView();
            });
            
            monthDropdown.addEventListener('change', (e) => {
                selectedMonthDate.setMonth(parseInt(e.target.value));
                updatePeriodView();
            });
        }
        
        function selectMonth(date) {
            selectedMonthDate = new Date(date);
            
            // Update dropdowns
            const monthDropdown = document.getElementById('monthDropdown');
            const yearDropdown = document.getElementById('yearDropdown');
            if (monthDropdown) monthDropdown.value = date.getMonth();
            if (yearDropdown) yearDropdown.value = date.getFullYear();
            
            setDefaultDatePicker();
            setDefaultBalanceDate();
            updatePeriodView();
        }
        
        function scrollToSelectedMonth() {
            // Not needed for compressed design
        }
        
        function updateAccountSelector() {
            const balanceAccountSelect = document.getElementById('balanceAccount');
            
            if (balanceAccountSelect) {
                balanceAccountSelect.innerHTML = '';
                
                // Add account options for balance input
                savingsAccounts.forEach(account => {
                    const option = document.createElement('option');
                    option.value = account.id;
                    option.textContent = account.name;
                    balanceAccountSelect.appendChild(option);
                });
            }
            
            // Also update slide-out dropdown
            updateSlideOutAccountDropdown();
            
            updateTotalSavingsDisplay();
        }
        
        function updateSlideOutAccountDropdown() {
            const balanceAccountContent = document.getElementById('balanceAccountContent');
            const slideOutBalanceAccount = document.getElementById('slideOutBalanceAccount');
            
            if (balanceAccountContent && slideOutBalanceAccount) {
                // Clear existing options
                balanceAccountContent.innerHTML = '';
                slideOutBalanceAccount.innerHTML = '';
                
                // Ensure we have at least one account
                if (savingsAccounts.length === 0) {
                    savingsAccounts = [
                        { id: 'checking', name: 'Checking', type: 'cash' },
                        { id: 'savings', name: 'Savings', type: 'cash' },
                        { id: 'emergency', name: 'Emergency Fund', type: 'cash' }
                    ];
                    saveSavingsAccounts(savingsAccounts);
                }
                
                // Add account options
                savingsAccounts.forEach((account, index) => {
                    // Add to custom dropdown
                    const item = document.createElement('div');
                    item.className = 'select-item';
                    if (index === 0) item.classList.add('selected');
                    item.setAttribute('data-value', account.id);
                    item.textContent = account.name;
                    
                    // Add click handler
                    item.addEventListener('click', function() {
                        selectSlideOutOption('balanceAccount', account.id, account.name);
                    });
                    
                    balanceAccountContent.appendChild(item);
                    
                    // Add to hidden select
                    const option = document.createElement('option');
                    option.value = account.id;
                    option.textContent = account.name;
                    if (index === 0) option.selected = true;
                    slideOutBalanceAccount.appendChild(option);
                });
                
                // Update displayed value
                const balanceAccountValue = document.getElementById('balanceAccountValue');
                if (balanceAccountValue && savingsAccounts.length > 0) {
                    balanceAccountValue.textContent = savingsAccounts[0].name;
                }
            }
        }

        
        function updateTotalSavingsDisplay() {
            const balances = loadAccountBalances();
            const periodKey = getCurrentPeriodKey();
            let totalBalance = 0;
            let accountsWithBalances = 0;
            
            console.log('updateTotalSavingsDisplay - currentPeriodMode:', currentPeriodMode);
            console.log('updateTotalSavingsDisplay - periodKey:', periodKey);
            
            // Calculate total balance across all accounts for current period
            Object.keys(balances).forEach(accountId => {
                const accountBalances = balances[accountId] || {};
                let periodBalances;
                
                if (currentPeriodMode === 'today') {
                    // For today mode, look for exact date match
                    periodBalances = Object.keys(accountBalances)
                        .filter(date => date === periodKey)
                        .sort()
                        .reverse();
                } else {
                    // For month mode, look for dates starting with month key
                    periodBalances = Object.keys(accountBalances)
                        .filter(date => date.startsWith(periodKey))
                        .sort()
                        .reverse();
                }
                
                console.log(`Account ${accountId} - periodBalances:`, periodBalances);
                
                if (periodBalances.length > 0) {
                    const accountBalance = accountBalances[periodBalances[0]];
                    totalBalance += accountBalance;
                    accountsWithBalances++;
                    console.log(`Account ${accountId} - balance: $${accountBalance}`);
                }
            });
            
            console.log('Total balance calculated:', totalBalance);
            console.log('Accounts with balances:', accountsWithBalances);
            
            // Update total balance display
            const totalBalanceElement = document.getElementById('totalAccountBalance');
            if (totalBalanceElement) {
                totalBalanceElement.textContent = formatCurrency(totalBalance);
            }
            
            const changeElement = document.getElementById('totalBalanceChange');
            if (changeElement) {
                const periodText = currentPeriodMode === 'today' ? 'today' : 'this month';
                changeElement.textContent = `Total across ${accountsWithBalances} account${accountsWithBalances !== 1 ? 's' : ''} ${periodText}`;
            }
            
            // Update balance history
            updateBalanceHistory();
        }
        
        function updateBalanceHistory() {
            const balances = loadAccountBalances();
            const periodKey = getCurrentPeriodKey();
            const periodBalances = [];
            // Get all balances for the selected period
            Object.keys(balances).forEach(accountId => {
                const accountBalances = balances[accountId] || {};
                Object.keys(accountBalances).forEach(date => {
                    let shouldInclude = false;
                    if (currentPeriodMode === 'today') {
                        // For today mode, include exact date match only
                        shouldInclude = date === periodKey;
                    } else {
                        // For month mode, include dates starting with month key
                        shouldInclude = date.startsWith(periodKey);
                    }
                    if (shouldInclude) {
                        periodBalances.push({
                            date: date,
                            accountId: accountId,
                            accountName: savingsAccounts.find(acc => acc.id === accountId)?.name || accountId,
                            balance: accountBalances[date]
                        });
                    }
                });
            });
            const historyContainer = document.getElementById('balanceHistory');
            if (!historyContainer) return;
            if (periodBalances.length === 0) {
                const periodText = currentPeriodMode === 'today' ? 'today' : 'this month';
                historyContainer.innerHTML = `<div style="text-align: center; color: #7f8c8d; padding: 20px;">No balance records ${periodText}</div>`;
            } else {
                if (currentPeriodMode === 'month') {
                    // ... existing month view code ...
                    const grouped = {};
                    periodBalances.forEach(item => {
                        if (!grouped[item.accountId]) grouped[item.accountId] = [];
                        grouped[item.accountId].push(item);
                    });
                    historyContainer.innerHTML = Object.keys(grouped).map(accountId => {
                        const accountName = grouped[accountId][0].accountName;
                        const balancesList = grouped[accountId]
                            .sort((a, b) => {
                                // Sort by date (desc), then by created (asc) for stability
                                const dateA = a.date.split('-').map(Number);
                                const dateB = b.date.split('-').map(Number);
                                const dateObjA = new Date(dateA[0], dateA[1] - 1, dateA[2]);
                                const dateObjB = new Date(dateB[0], dateB[1] - 1, dateB[2]);
                                
                                if (dateObjA.getTime() !== dateObjB.getTime()) {
                                    return dateObjB - dateObjA; // latest date first
                                }
                                
                                // If same date, sort by created timestamp for stability
                                const createdA = a.created || new Date(a.date).getTime();
                                const createdB = b.created || new Date(b.date).getTime();
                                return createdA - createdB;
                            })
                            .map((item, idx, arr) => {
                                const dateParts = item.date.split('-').map(Number);
                                const dateObj = new Date(dateParts[0], dateParts[1] - 1, dateParts[2]);
                                const formattedDate = dateObj.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                                // Calculate percent change vs previous entry in this month
                                let percentChange = null;
                                let arrow = '';
                                if (idx > 0) {
                                    const prev = arr[idx - 1];
                                    if (prev && prev.balance !== 0) {
                                        percentChange = ((item.balance - prev.balance) / prev.balance) * 100;
                                        if (percentChange > 0.01) {
                                            arrow = '<i data-lucide="arrow-up-right" class="balance-arrow positive"></i>';
                                        } else if (percentChange < -0.01) {
                                            arrow = '<i data-lucide="arrow-down-right" class="balance-arrow negative"></i>';
                                        } else {
                                            arrow = '<i data-lucide="arrow-right" class="balance-arrow neutral"></i>';
                                        }
                                    }
                                }
                                return `
                                    <div class="swipe-container" data-type="balance" data-account-id="${item.accountId}" data-date="${item.date}">
                                        <div class="swipe-content">
                                            <div class="modern-balance-history-item">
                                                <div class="balance-history-date">${formattedDate}</div>
                                                <div class="balance-history-right">
                                                    <div class="balance-history-amount">${formatCurrency(item.balance)}</div>
                                                    ${percentChange !== null ? `<div class="balance-history-percent ${percentChange > 0 ? 'positive' : percentChange < 0 ? 'negative' : 'neutral'}">${arrow}${percentChange > 0 ? '+' : ''}${percentChange.toFixed(2)}%</div>` : ''}
                                                </div>
                                                <button class="delete-balance-btn" onclick="handleBalanceDelete(this); return false;"><i data-lucide="x" class="w-4 h-4"></i></button>
                                            </div>
                                        </div>
                                        <div class="swipe-action" onclick="handleBalanceDelete(this); event.stopPropagation(); return false;"><i data-lucide="x" class="w-4 h-4"></i></div>
                                    </div>
                                `;
                            }).join('');
                        return `<div style="margin-bottom:1.5rem;"><div style="font-weight:600;font-size:1rem;margin-bottom:0.5rem;">${accountName}</div>${balancesList}</div>`;
                    }).join('');
                } else {
                    // Today view: only show today's records
                    historyContainer.innerHTML = periodBalances.map(item => {
                        const dateParts = item.date.split('-').map(Number);
                        const dateObj = new Date(dateParts[0], dateParts[1] - 1, dateParts[2]);
                        const formattedDate = dateObj.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                        return `
                            <div class="swipe-container" data-type="balance" data-account-id="${item.accountId}" data-date="${item.date}">
                                <div class="swipe-content">
                                    <div class="balance-item">
                                        <div class="balance-details">
                                            <div class="balance-date">${formattedDate}</div>
                                            <div class="balance-account">${item.accountName}</div>
                                        </div>
                                        <div class="balance-amount">${formatCurrency(item.balance)}</div>
                                        <button class="delete-balance-btn" onclick="handleBalanceDelete(this); return false;"><i data-lucide="x" class="w-4 h-4"></i></button>
                                    </div>
                                </div>
                                <div class="swipe-action" onclick="handleBalanceDelete(this); event.stopPropagation(); return false;"><i data-lucide="x" class="w-4 h-4"></i></div>
                            </div>
                        `;
                    }).join('');
                }
            }
        }
        
        function addBalance() {
            const amount = parseFloat(document.getElementById('balanceAmount').value);
            const targetDate = document.getElementById('balanceDate').value;
            const selectedAccount = document.getElementById('balanceAccount').value;
            
            if (!amount || amount < 0) {
                alert('Please enter a valid balance amount');
                return;
            }
            
            if (!targetDate) {
                alert('Please select a date');
                return;
            }
            
            if (!selectedAccount) {
                alert('Please select an account');
                return;
            }
            
            const balances = loadAccountBalances();
            
            if (!balances[selectedAccount]) {
                balances[selectedAccount] = {};
            }
            
            balances[selectedAccount][targetDate] = amount;
            saveAccountBalances(balances);
            
            // Update account type chart if on home page
            if (document.getElementById('accountTypeChart')) {
                generateAccountTypeChart();
            }
            
            // Clear form
            document.getElementById('balanceAmount').value = '';
            
            updateTotalSavingsDisplay();
            
            // Update chart if on reports screen
            if (currentScreen === 1) {
                updateChart();
            }
        }
        
        function deleteBalance(accountId, date) {
            console.log('Deleting balance:', accountId, date);
            const balances = loadAccountBalances();
            
            if (balances[accountId] && balances[accountId][date]) {
                // Find the swipe container that holds this balance
                const swipeContainer = document.querySelector(`.swipe-container[data-type="balance"][data-account-id="${accountId}"][data-date="${date}"]`);
                
                if (swipeContainer) {
                    // Save accordion state before deletion
                    const accordionId = `accordion-body-${accountId}`;
                    const accordionBody = document.getElementById(accordionId);
                    const wasExpanded = accordionBody ? accordionBody.classList.contains('expanded') : false;
                    
                    // Add deleting animation
                    swipeContainer.classList.add('deleting');
                    console.log('Adding deleting animation to container:', swipeContainer);
                    
                    // Wait for animation to complete before removing from storage
                    setTimeout(() => {
                        // Delete the balance entry
                        delete balances[accountId][date];
                        saveAccountBalances(balances);
                        updateTotalSavingsDisplay();
                        
                        // Update screens based on current view
                        if (document.getElementById('saveBalanceHistory')) {
                            updateSaveScreen();
                            
                            // Restore accordion state after update
                            setTimeout(() => {
                                const newAccordionBody = document.getElementById(accordionId);
                                if (newAccordionBody && wasExpanded && !newAccordionBody.classList.contains('expanded')) {
                                    toggleAccountAccordion(accountId);
                                }
                            }, 10);
                        } else {
                            updateBalanceHistory();
                        }
                        
                        // Update chart if on reports screen
                        if (currentScreen === 2) {
                            updateChart();
                        }
                    }, 300); // Match the CSS animation duration
                } else {
                    console.log('No swipe container found, deleting immediately');
                    // No swipe container found, just delete immediately
                    delete balances[accountId][date];
                    saveAccountBalances(balances);
                    updateTotalSavingsDisplay();
                    
                    // Update screens based on current view
                    if (document.getElementById('saveBalanceHistory')) {
                        updateSaveScreen();
                    } else {
                        updateBalanceHistory();
                    }
                    
                    // Update chart if on reports screen
                    if (currentScreen === 2) {
                        updateChart();
                    }
                }
            }
        }
        
        async function showAccountManagementModal() {
            await showAccountManagementSlideOut();
        }
        
        async function showAccountManagementSlideOut() {
            document.getElementById('accountManagementSlideOut').classList.add('active');
            await updateAccountManagementList();
        }
        
        function hideAccountManagementSlideOut() {
            document.getElementById('accountManagementSlideOut').classList.remove('active');
        }
        
        function hideAccountManagementModal() {
            hideAccountManagementSlideOut();
        }
        
        async function updateAccountList() {
            await updateAccountManagementList();
        }
        
        async function updateAccountManagementList() {
            const listContainer = document.getElementById('accountManagementList');
            if (!listContainer) return;
            
            // Load accounts with recent transactions from API
            await loadAccountsWithTransactions();
            
            listContainer.innerHTML = savingsAccounts.map(account => {
                const recentTransactionsHtml = account.recentTransactions && account.recentTransactions.length > 0 
                    ? renderAccountTransactions(account.recentTransactions)
                    : '<div style="text-align: center; color: #7f8c8d; padding: 0.5rem; font-size: 0.8rem;">No recent transactions</div>';
                
                const balanceDisplay = account.currentBalance !== undefined 
                    ? `<div style="font-size: 0.9rem; color: #666; margin-top: 0.25rem;">Balance: ${formatCurrency(account.currentBalance)}</div>`
                    : '';
                
                return `
                    <div class="account-management-list-item" style="flex-direction: column; align-items: flex-start; padding: 1rem;">
                        <div style="display: flex; justify-content: space-between; align-items: center; width: 100%; margin-bottom: 0.5rem;">
                            <div>
                                <div class="account-management-name" style="font-weight: 600;">${account.name}</div>
                                ${account.institutionName ? `<div style="font-size: 0.8rem; color: #666;">${account.institutionName}</div>` : ''}
                                ${balanceDisplay}
                            </div>
                            ${savingsAccounts.length > 1 ? `<button class="account-management-delete-btn" onclick="deleteAccountFromSlideOut('${account.id}')">Delete</button>` : ''}
                        </div>
                        <div style="width: 100%; border-top: 1px solid #eee; padding-top: 0.5rem;">
                            <div style="font-size: 0.8rem; color: #666; margin-bottom: 0.5rem; font-weight: 500;">Recent Transactions</div>
                            ${recentTransactionsHtml}
                        </div>
                    </div>
                `;
            }).join('');
        }
        
        function addNewAccount() {
            addNewAccountFromSlideOut();
        }
        
        async function addNewAccountFromSlideOut() {
            const name = document.getElementById('newAccountNameSlideOut').value.trim();
            
            if (!name) {
                alert('Please enter an account name');
                return;
            }
            
            const id = name.toLowerCase().replace(/\s+/g, '-');
            
            if (savingsAccounts.find(acc => acc.id === id)) {
                alert('Account with this name already exists');
                return;
            }
            
            savingsAccounts.push({
                id: id,
                name: name,
                type: 'custom'
            });
            
            saveSavingsAccounts(savingsAccounts);
            document.getElementById('newAccountNameSlideOut').value = '';
            await updateAccountManagementList();
            updateAccountSelector();
            updateSlideOutAccountDropdown();
        }
        
        function deleteAccount(accountId) {
            deleteAccountFromSlideOut(accountId);
        }
        
        async function deleteAccountFromSlideOut(accountId) {
            if (savingsAccounts.length <= 1) {
                alert('You must have at least one account');
                return;
            }
            
            if (confirm('Are you sure you want to delete this account? All balance history will be lost.')) {
                // Remove from accounts
                savingsAccounts = savingsAccounts.filter(acc => acc.id !== accountId);
                saveSavingsAccounts(savingsAccounts);
                
                // Remove all balances for this account
                const balances = loadAccountBalances();
                delete balances[accountId];
                saveAccountBalances(balances);
                
                await updateAccountManagementList();
                updateAccountSelector();
                updateSlideOutAccountDropdown();
            }
        }
        
        function setDefaultBalanceDate() {
            const dateInput = document.getElementById('balanceDate');
            if (dateInput) {
                const today = new Date();
                if (isCurrentMonth()) {
                    const year = today.getFullYear();
                    const month = String(today.getMonth() + 1).padStart(2, '0');
                    const day = String(today.getDate()).padStart(2, '0');
                    dateInput.value = `${year}-${month}-${day}`;
                } else {
                    const firstDay = new Date(selectedMonthDate.getFullYear(), selectedMonthDate.getMonth(), 1);
                    const year = firstDay.getFullYear();
                    const month = String(firstDay.getMonth() + 1).padStart(2, '0');
                    const day = String(firstDay.getDate()).padStart(2, '0');
                    dateInput.value = `${year}-${month}-${day}`;
                }
            }
        }
        
        function setDefaultDatePicker() {
            // For custom datepickers, set default date when in month mode
            if (currentPeriodMode === 'month') {
                const datepickerId = 'expenseCustomDatepicker';
                const state = datepickerStates[datepickerId];
                
                if (state) {
                    if (isCurrentMonth()) {
                        selectToday(datepickerId);
                    } else {
                        // Set to first day of selected month
                        const firstDay = new Date(selectedMonthDate.getFullYear(), selectedMonthDate.getMonth(), 1);
                        state.selectedDate = firstDay;
                        state.currentMonth = firstDay.getMonth();
                        state.currentYear = firstDay.getFullYear();
                        updateDatepickerValue(datepickerId);
                    }
                }
            }
        }
        
        // Period management functions
        function setPeriodMode(mode) {
            // Function kept for backward compatibility but simplified
            // since we no longer have day/range toggle
            
            // Update the budget title
            renderBudgetTitle();
            
            // Update transactions display
            updateTransactionsForTimeRange();
            
            // Initialize month/year dropdowns for backward compatibility
            updatePeriodDropdownValues();
            setupPeriodDropdownEventListeners();
            setDefaultDatePicker();
            setDefaultBalanceDate();
            
            updateBudgetDisplay();
            updateBalanceHistory();
            
            // Update chart
            if (typeof updateChart === 'function') {
                updateChart();
            }
        }
        
        function updatePeriodDropdownValues() {
            const monthNames = ['January','February','March','April','May','June','July','August','September','October','November','December'];
            const btnText = document.getElementById('monthYearSelectorText');
            if (btnText) {
                btnText.textContent = `${monthNames[selectedMonthDate.getMonth()]} ${selectedMonthDate.getFullYear()}`;
            }
            // Also update the card title if needed (legacy support)
            const budgetPeriodLabel = document.getElementById('budgetPeriodLabel');
            if (budgetPeriodLabel) {
                budgetPeriodLabel.textContent = `${monthNames[selectedMonthDate.getMonth()]} ${selectedMonthDate.getFullYear()}`;
            }
        }
        
        // Slide-out functions
        function showExpenseSlideOut() {
            const overlay = document.getElementById('expenseSlideOut');
            overlay.classList.add('active');
            // Update date picker visibility in slide-out
            const slideOutDateGroup = document.getElementById('slideOutDatePickerGroup');
            if (slideOutDateGroup) {
                slideOutDateGroup.style.display = currentPeriodMode === 'month' ? 'block' : 'none';
            }
            // Initialize and set default date for custom datepicker if in month mode
            if (currentPeriodMode === 'month') {
                const datepickerId = 'expenseCustomDatepicker';
                if (!datepickerStates[datepickerId]) {
                    initializeDatepicker(datepickerId);
                }
                const now = new Date(2025, 6, 7); // Hard-coded to July 7, 2025
                let defaultDate;
                if (
                    selectedMonthDate.getFullYear() === now.getFullYear() &&
                    selectedMonthDate.getMonth() === now.getMonth()
                ) {
                    defaultDate = now;
                } else {
                    defaultDate = new Date(selectedMonthDate.getFullYear(), selectedMonthDate.getMonth(), 1);
                }
                const state = datepickerStates[datepickerId];
                state.selectedDate = defaultDate;
                state.currentMonth = defaultDate.getMonth();
                state.currentYear = defaultDate.getFullYear();
                updateDatepickerValue(datepickerId);
                renderCalendar(datepickerId);
            }
        }
        
        function showBalanceSlideOut() {
            const overlay = document.getElementById('balanceSlideOut');
            overlay.classList.add('active');
            // Initialize datepicker if not already done
            const datepickerId = 'balanceCustomDatepicker';
            if (!datepickerStates[datepickerId]) {
                initializeDatepicker(datepickerId);
            }
            // Set default date to today
            const now = new Date(2025, 6, 7); // Hard-coded to July 7, 2025
            const state = datepickerStates[datepickerId];
            state.selectedDate = now;
            state.currentMonth = now.getMonth();
            state.currentYear = now.getFullYear();
            updateDatepickerValue(datepickerId);
            renderCalendar(datepickerId);
            
            // Update account dropdown
            updateSlideOutAccountDropdown();
            
            // Pre-fill with last balance for default account
            const defaultAccountId = getDefaultAccountId();
            if (defaultAccountId) {
                const lastBalance = getLastBalanceForAccount(defaultAccountId);
                const balanceAmountInput = document.getElementById('slideOutBalanceAmount');
                if (balanceAmountInput && lastBalance > 0) {
                    balanceAmountInput.value = lastBalance.toFixed(2);
                }
            }
        }
        
        function hideExpenseSlideOut() {
            const overlay = document.getElementById('expenseSlideOut');
            overlay.classList.remove('active');
        }
        
        function hideBalanceSlideOut() {
            const overlay = document.getElementById('balanceSlideOut');
            overlay.classList.remove('active');
        }
        
        // Custom Datepicker Functions
        let datepickerStates = {};
        
        function initializeDatepicker(datepickerId) {
            if (!datepickerStates[datepickerId]) {
                datepickerStates[datepickerId] = {
                    currentMonth: new Date().getMonth(),
                    currentYear: new Date().getFullYear(),
                    selectedDate: null,
                    isOpen: false
                };
            }
            
            // Set default to today
            selectToday(datepickerId);
            renderCalendar(datepickerId);
        }
        
        function toggleDatepicker(datepickerId) {
            const popup = document.getElementById(datepickerId + 'Popup');
            const trigger = document.querySelector(`#${datepickerId} .datepicker-trigger`);
            const state = datepickerStates[datepickerId];
            
            if (!state) {
                initializeDatepicker(datepickerId);
                return;
            }
            
            // Close all other datepickers
            Object.keys(datepickerStates).forEach(id => {
                if (id !== datepickerId) {
                    const otherPopup = document.getElementById(id + 'Popup');
                    const otherTrigger = document.querySelector(`#${id} .datepicker-trigger`);
                    if (otherPopup) {
                        otherPopup.style.display = 'none';
                        datepickerStates[id].isOpen = false;
                    }
                    if (otherTrigger) {
                        otherTrigger.setAttribute('aria-expanded', 'false');
                    }
                }
            });
            
            if (state.isOpen) {
                popup.style.display = 'none';
                state.isOpen = false;
                if (trigger) {
                    trigger.setAttribute('aria-expanded', 'false');
                }
            } else {
                renderCalendar(datepickerId);
                popup.style.display = 'block';
                state.isOpen = true;
                if (trigger) {
                    trigger.setAttribute('aria-expanded', 'true');
                }
            }
        }
        
        function renderCalendar(datepickerId) {
            const state = datepickerStates[datepickerId];
            if (!state) return;
            
            const monthYearElement = document.getElementById(datepickerId + 'MonthYear');
            const gridElement = document.getElementById(datepickerId + 'Grid');
            
            // Update month/year display
            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 
                               'July', 'August', 'September', 'October', 'November', 'December'];
            monthYearElement.textContent = `${monthNames[state.currentMonth]} ${state.currentYear}`;
            
            // Clear existing grid
            gridElement.innerHTML = '';
            
            // Add day headers
            const dayHeaders = ['Su', 'Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa'];
            dayHeaders.forEach(day => {
                const dayHeader = document.createElement('div');
                dayHeader.className = 'datepicker-day-header';
                dayHeader.textContent = day;
                gridElement.appendChild(dayHeader);
            });
            
            // Get first day of month and number of days
            const firstDay = new Date(state.currentYear, state.currentMonth, 1);
            const lastDay = new Date(state.currentYear, state.currentMonth + 1, 0);
            const daysInMonth = lastDay.getDate();
            const startingDayOfWeek = firstDay.getDay();
            
            // Add empty cells for days before first day of month
            for (let i = 0; i < startingDayOfWeek; i++) {
                const emptyCell = document.createElement('div');
                emptyCell.className = 'datepicker-day datepicker-day-empty';
                gridElement.appendChild(emptyCell);
            }
            
            // Add days of month
            for (let day = 1; day <= daysInMonth; day++) {
                const dayElement = document.createElement('div');
                dayElement.className = 'datepicker-day';
                dayElement.textContent = day;
                
                // Highlight selected date
                if (
                    state.selectedDate &&
                    state.selectedDate.getDate() === day &&
                    state.selectedDate.getMonth() === state.currentMonth &&
                    state.selectedDate.getFullYear() === state.currentYear
                ) {
                    dayElement.classList.add('selected');
                }
                
                // Check if this day is today
                const today = new Date();
                if (
                    today.getDate() === day &&
                    today.getMonth() === state.currentMonth &&
                    today.getFullYear() === state.currentYear
                ) {
                    dayElement.classList.add('datepicker-day-today');
                }
                
                dayElement.addEventListener('click', () => selectDate(datepickerId, day));
                gridElement.appendChild(dayElement);
            }
        }
        
        function selectDate(datepickerId, day) {
            const state = datepickerStates[datepickerId];
            if (!state) return;
            
            state.selectedDate = new Date(state.currentYear, state.currentMonth, day);
            updateDatepickerValue(datepickerId);
            closeDatepicker(datepickerId);
        }
        
        function updateDatepickerValue(datepickerId) {
            const state = datepickerStates[datepickerId];
            if (!state || !state.selectedDate) return;
            
            const valueElement = document.getElementById(datepickerId + 'Value');
            
            // More robust hidden input identification
            let hiddenInput;
            if (datepickerId.includes('expense')) {
                hiddenInput = document.getElementById('slideOutExpenseDate');
            } else if (datepickerId.includes('balance')) {
                hiddenInput = document.getElementById('slideOutBalanceDate');
            }
            
            // Create a new date to avoid timezone issues
            const selectedDate = new Date(state.selectedDate);
            
            // Format date as readable string for display (using local timezone)
            const displayDate = selectedDate.toLocaleDateString('en-US', {
                weekday: 'short',
                year: 'numeric',
                month: 'short',
                day: 'numeric'
            });
            
            // Format date as YYYY-MM-DD for form submission (avoid timezone offset)
            const year = selectedDate.getFullYear();
            const month = String(selectedDate.getMonth() + 1).padStart(2, '0');
            const day = String(selectedDate.getDate()).padStart(2, '0');
            const formattedDate = `${year}-${month}-${day}`;
            
            if (valueElement) {
                valueElement.textContent = displayDate;
            }
            if (hiddenInput) {
                hiddenInput.value = formattedDate;
            }
        }
        
        function closeDatepicker(datepickerId) {
            const popup = document.getElementById(datepickerId + 'Popup');
            const trigger = document.querySelector(`#${datepickerId} .datepicker-trigger`);
            const state = datepickerStates[datepickerId];
            
            if (popup) {
                popup.style.display = 'none';
            }
            if (state) {
                state.isOpen = false;
            }
            if (trigger) {
                trigger.setAttribute('aria-expanded', 'false');
            }
        }
        
        function navigateMonth(datepickerId, direction) {
            const state = datepickerStates[datepickerId];
            if (!state) return;
            
            state.currentMonth += direction;
            
            if (state.currentMonth < 0) {
                state.currentMonth = 11;
                state.currentYear--;
            } else if (state.currentMonth > 11) {
                state.currentMonth = 0;
                state.currentYear++;
            }
            
            renderCalendar(datepickerId);
        }
        
        function selectToday(datepickerId) {
            const state = datepickerStates[datepickerId];
            if (!state) {
                initializeDatepicker(datepickerId);
                return;
            }
            
            const today = new Date();
            state.selectedDate = today;
            state.currentMonth = today.getMonth();
            state.currentYear = today.getFullYear();
            
            updateDatepickerValue(datepickerId);
            if (state.isOpen) {
                renderCalendar(datepickerId);
            }
        }
        
        function clearDate(datepickerId) {
            const state = datepickerStates[datepickerId];
            if (!state) return;
            
            state.selectedDate = null;
            
            const valueElement = document.getElementById(datepickerId + 'Value');
            
            // More robust hidden input identification
            let hiddenInput;
            if (datepickerId.includes('expense')) {
                hiddenInput = document.getElementById('slideOutExpenseDate');
            } else if (datepickerId.includes('balance')) {
                hiddenInput = document.getElementById('slideOutBalanceDate');
            }
            
            if (valueElement) {
                valueElement.textContent = 'Select date';
            }
            if (hiddenInput) {
                hiddenInput.value = '';
            }
            
            closeDatepicker(datepickerId);
        }
        
        // Close datepickers when clicking outside
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.custom-datepicker')) {
                Object.keys(datepickerStates).forEach(datepickerId => {
                    closeDatepicker(datepickerId);
                });
            }
        });
        
        // Add keyboard support for datepickers
        document.addEventListener('keydown', function(e) {
            if (e.key === 'Escape') {
                // Close all open datepickers
                Object.keys(datepickerStates).forEach(datepickerId => {
                    closeDatepicker(datepickerId);
                });
            }
        });
        
        // Initialize datepickers when page loads
        document.addEventListener('DOMContentLoaded', function() {
            // Migrate old expense data if it exists
            const oldExpenses = localStorage.getItem('expenses');
            const newExpenses = localStorage.getItem('dailyExpenses');
            if (oldExpenses && !newExpenses) {
                localStorage.setItem('dailyExpenses', oldExpenses);
                console.log('Migrated expense data from old storage key');
            }
            
            // Initialize datepickers
            initializeDatepicker('expenseCustomDatepicker');
            initializeDatepicker('balanceCustomDatepicker');
            
            // Initialize savings accounts
            initializeSavingsAccounts();
            
            // Initialize dropdown event listeners
            setupDropdownEventListeners();
            setupPeriodDropdownEventListeners();
            
            // Initialize click-outside-to-close functionality for slide-out menus
            initializeSlideOutClickOutside();
            
            // Initialize period mode
            setPeriodMode('month');
            
            // Set chart period to ALL by default to show all balance data
            currentChartPeriod = 'ALL';
            
            // Initialize slide-out account dropdown
            updateSlideOutAccountDropdown();
            
            // Force initialize Lucide icons with multiple attempts
            function initializeLucideIcons() {
                if (typeof lucide !== 'undefined') {
                    try {
                        lucide.createIcons();
                        console.log('Lucide icons initialized successfully');
                    } catch (error) {
                        console.error('Error initializing Lucide icons:', error);
                    }
                } else {
                    console.warn('Lucide not loaded yet, retrying...');
                }
            }
            
            // Try immediately
            initializeLucideIcons();
            
            // Try again after short delays
            setTimeout(initializeLucideIcons, 100);
            setTimeout(initializeLucideIcons, 500);
            setTimeout(initializeLucideIcons, 1000);
            
            // Update current date display
            updateCurrentDateDisplay();
            
            // Initial update of displays
            updatePeriodView();
            updateSaveScreen(); // Initialize save screen
            
            // Initialize the chart with empty data
            if (document.getElementById('spendingChart')) {
                // Set default period
                currentChartPeriod = 'YTD';
                document.querySelectorAll('.chart-period-btn-wealthsimple').forEach(btn => {
                    btn.classList.toggle('active', btn.id === 'periodYTD');
                });
            }
            
            // Default to month view (no today-view class needed)
            const screen = document.querySelector('.screen');
            if (screen) {
                // Month view is the default when today-view class is not present
                screen.classList.remove('today-view');
            }
            
        });
        
        function setupDropdownEventListeners() {
            // Setup expense category dropdown
            const expenseCategoryItems = document.querySelectorAll('#expenseCategoryContent .select-item');
            expenseCategoryItems.forEach(item => {
                item.addEventListener('click', function() {
                    const value = this.getAttribute('data-value');
                    const text = this.textContent;
                    selectSlideOutOption('expenseCategory', value, text);
                });
            });
            
            // Balance account dropdown will be set up when accounts are loaded
        }
        
        function setupPeriodDropdownEventListeners() {
            // Setup month selector
            const monthSelectItems = document.querySelectorAll('#monthSelectContent .period-select-item');
            monthSelectItems.forEach(item => {
                item.addEventListener('click', function() {
                    const monthIndex = parseInt(this.getAttribute('data-value'));
                    selectedMonthDate.setMonth(monthIndex);
                    
                    // Update display
                    document.getElementById('monthSelectValue').textContent = this.textContent;
                    
                    // Update selected state
                    document.querySelectorAll('#monthSelectContent .period-select-item').forEach(i => {
                        i.classList.remove('selected');
                    });
                    this.classList.add('selected');
                    
                    // Close dropdown
                    document.getElementById('monthSelectContent').classList.remove('open');
                    document.getElementById('monthSelectTrigger').removeAttribute('aria-expanded');
                    
                    updatePeriodView();
                });
            });
            
            // Setup year selector
            const yearSelectItems = document.querySelectorAll('#yearSelectContent .period-select-item');
            yearSelectItems.forEach(item => {
                item.addEventListener('click', function() {
                    const year = parseInt(this.getAttribute('data-value'));
                    selectedMonthDate.setFullYear(year);
                    
                    // Update display
                    document.getElementById('yearSelectValue').textContent = this.textContent;
                    
                    // Update selected state
                    document.querySelectorAll('#yearSelectContent .period-select-item').forEach(i => {
                        i.classList.remove('selected');
                    });
                    this.classList.add('selected');
                    
                    // Close dropdown
                    document.getElementById('yearSelectContent').classList.remove('open');
                    document.getElementById('yearSelectTrigger').removeAttribute('aria-expanded');
                    
                    updatePeriodView();
                });
            });
        }
        
        function updateCurrentDateDisplay() {
            const dateElement = document.getElementById('currentDate');
            if (dateElement) {
                const now = new Date(2025, 6, 7); // Hard-coded to July 7, 2025
                const options = { 
                    weekday: 'long', 
                    year: 'numeric', 
                    month: 'long', 
                    day: 'numeric' 
                };
                dateElement.textContent = now.toLocaleDateString('en-US', options);
            }
        }
        
        function addExpenseFromSlideOut() {
            const amount = parseFloat(document.getElementById('slideOutExpenseAmount').value);
            const category = document.getElementById('slideOutExpenseCategory').value;
            const description = document.getElementById('slideOutExpenseDescription').value;
            
            let targetDate;
            if (currentPeriodMode === 'month') {
                targetDate = document.getElementById('slideOutExpenseDate').value;
                if (!targetDate) {
                    alert('Please select a date');
                    return;
                }
            } else {
                targetDate = getCurrentDate();
            }
            
            if (!amount || amount <= 0) {
                alert('Please enter a valid amount');
                return;
            }
            
            if (!category) {
                alert('Please select a category');
                return;
            }
            
            const expenses = loadExpenses();
            
            if (!expenses[targetDate]) {
                expenses[targetDate] = [];
            }
            
            const now = Date.now();
            const newExpense = {
                amount: amount,
                category: category,
                description: description || '',
                timestamp: now, // legacy
                created: now,
                updated: now
            };
            
            expenses[targetDate].push(newExpense);
            
            saveExpenses(expenses);
            
            // Clear form
            document.getElementById('slideOutExpenseAmount').value = '';
            document.getElementById('slideOutExpenseDescription').value = '';
            
            // Reset category to default using the dropdown function
            selectSlideOutOption('expenseCategory', 'groceries', 'Groceries');
            
            // Clear custom datepicker
            if (currentPeriodMode === 'month') {
                clearDate('expenseCustomDatepicker');
            }
            
            // Close slide-out
            hideExpenseSlideOut();
            
            // Update display
            updatePeriodView();
            updateChart();
            console.log('Expense added:', newExpense);
        }
        
        function addBalanceFromSlideOut() {
            const amount = parseFloat(document.getElementById('slideOutBalanceAmount').value);
            const targetDate = document.getElementById('slideOutBalanceDate').value;
            const selectedAccount = document.getElementById('slideOutBalanceAccount').value;
            
            if (!amount || amount < 0) {
                alert('Please enter a valid balance amount');
                return;
            }
            
            if (!targetDate) {
                alert('Please select a date');
                return;
            }
            
            if (!selectedAccount) {
                alert('Please select an account');
                return;
            }
            
            const balances = loadAccountBalances();
            
            if (!balances[selectedAccount]) {
                balances[selectedAccount] = {};
            }
            
            if (!balances[selectedAccount][targetDate]) {
                balances[selectedAccount][targetDate] = {
                    amount: amount,
                    created: Date.now(),
                    updated: Date.now()
                };
            } else {
                // If already exists, treat as update
                const old = balances[selectedAccount][targetDate];
                balances[selectedAccount][targetDate] = {
                    amount: amount,
                    created: old.created || Date.now(),
                    updated: Date.now()
                };
            }
            
            saveAccountBalances(balances);
            
            // Update account type chart if on home page
            if (document.getElementById('accountTypeChart')) {
                generateAccountTypeChart();
            }
            
            // Clear form
            document.getElementById('slideOutBalanceAmount').value = '';
            clearDate('balanceCustomDatepicker');
            
            // Close slide-out
            hideBalanceSlideOut();
            
            // Update display
            updateTotalSavingsDisplay();
            updateSaveScreen(); // Update save screen when balance is added
            updateChart();
        }
        
        function togglePeriodSelect(selectType) {
            const content = document.getElementById(selectType + 'SelectContent');
            const trigger = document.getElementById(selectType + 'SelectTrigger');
            const isOpen = content.classList.contains('open');
            
            // Close all other period dropdowns
            document.querySelectorAll('.period-select-content').forEach(dropdown => {
                dropdown.classList.remove('open');
            });
            document.querySelectorAll('.period-select-trigger').forEach(triggerEl => {
                triggerEl.removeAttribute('aria-expanded');
            });
            
            // Toggle current dropdown
            if (!isOpen) {
                content.classList.add('open');
                trigger.setAttribute('aria-expanded', 'true');
            }
        }
        
        function toggleSlideOutSelect(selectType) {
            const content = document.getElementById(selectType + 'Content');
            const trigger = document.getElementById(selectType + 'Trigger');
            const isOpen = content.classList.contains('open');
            
            // Close all other dropdowns
            document.querySelectorAll('.select-content').forEach(dropdown => {
                dropdown.classList.remove('open');
            });
            document.querySelectorAll('.select-trigger').forEach(triggerEl => {
                triggerEl.removeAttribute('aria-expanded');
            });
            
            // Toggle current dropdown
            if (!isOpen) {
                content.classList.add('open');
                trigger.setAttribute('aria-expanded', 'true');
            }
        }
        
        function selectSlideOutOption(selectType, value, text) {
            const trigger = document.getElementById(selectType + 'Trigger');
            const valueSpan = document.getElementById(selectType + 'Value');
            const content = document.getElementById(selectType + 'Content');
            const hiddenSelect = document.getElementById('slideOut' + selectType.charAt(0).toUpperCase() + selectType.slice(1));
            
            // Handle month/year slideout selections
            if (selectType === 'monthSelect') {
                tempSelectedMonth = parseInt(value);
                const monthInput = document.getElementById('monthInput');
                if (monthInput) {
                    monthInput.value = value;
                }
            } else if (selectType === 'monthYear') {
                tempSelectedYear = parseInt(value);
                const yearInput = document.getElementById('yearInput');
                if (yearInput) {
                    yearInput.value = value;
                }
            } else if (selectType === 'balanceAccount') {
                // Prepopulate balance amount with last balance for selected account
                const lastBalance = getLastBalanceForAccount(value);
                const balanceAmountInput = document.getElementById('slideOutBalanceAmount');
                if (balanceAmountInput && lastBalance > 0) {
                    balanceAmountInput.value = lastBalance.toFixed(2);
                }
            } else if (selectType === 'budgetProvince') {
                // Handle budget province selection
                const provinceValue = document.getElementById('budgetProvinceValue');
                if (provinceValue) {
                    provinceValue.textContent = text;
                }
            }
            
            // Update display
            if (valueSpan) {
                if (selectType === 'expenseCategory') {
                    // For category selection, use icon + text
                    valueSpan.innerHTML = getCategoryEmoji(value) + text.replace(/^[^\w\s]*\s*/, '');
                    // Initialize Lucide icons for the new content
                    if (window.lucide && typeof window.lucide.createIcons === 'function') {
                        window.lucide.createIcons();
                    }
                } else {
                    valueSpan.textContent = text;
                }
            }
            
            // Update hidden select
            if (hiddenSelect) {
                hiddenSelect.value = value;
            }
            
            // Update selected state
            content.querySelectorAll('.select-item').forEach(item => {
                item.classList.remove('selected');
            });
            const selectedItem = content.querySelector(`[data-value="${value}"]`);
            if (selectedItem) {
                selectedItem.classList.add('selected');
            }
            
            // Close dropdown
            content.classList.remove('open');
            trigger.removeAttribute('aria-expanded');
        }
        
        // Close dropdowns when clicking outside
        document.addEventListener('click', function(e) {
            if (!e.target.closest('.select-container')) {
                document.querySelectorAll('.select-content').forEach(dropdown => {
                    dropdown.classList.remove('open');
                });
                document.querySelectorAll('.select-trigger').forEach(trigger => {
                    trigger.removeAttribute('aria-expanded');
                });
            }
            
            if (!e.target.closest('.period-select-container')) {
                document.querySelectorAll('.period-select-content').forEach(dropdown => {
                    dropdown.classList.remove('open');
                });
                document.querySelectorAll('.period-select-trigger').forEach(trigger => {
                    trigger.removeAttribute('aria-expanded');
                });
            }
        });
        

        /**
         * Loads savings accounts from localStorage or sets defaults if not present.
         */
        function initializeSavingsAccounts() {
            const stored = localStorage.getItem('savingsAccounts');
            if (stored) {
                try {
                    savingsAccounts = JSON.parse(stored);
                    // Validate loaded data is an array of objects with id and name
                    if (!Array.isArray(savingsAccounts) || !savingsAccounts.every(acc => acc && typeof acc.id === 'string' && typeof acc.name === 'string')) {
                        throw new Error('Invalid savingsAccounts data');
                    }
                } catch (e) {
                    // If parsing fails, fall back to defaults
                    savingsAccounts = [
                        { id: 'checking', name: 'Checking' },
                        { id: 'savings', name: 'Savings' },
                        { id: 'emergency', name: 'Emergency Fund' }
                    ];
                }
            } else {
                savingsAccounts = [
                    { id: 'checking', name: 'Checking' },
                    { id: 'savings', name: 'Savings' },
                    { id: 'emergency', name: 'Emergency Fund' }
                ];
            }
        }

        /**
         * Fetches accounts with recent transactions from the API
         */
        async function loadAccountsWithTransactions() {
            try {
                // Get Clerk session token
                const sessionToken = await window.plaidService.getClerkSessionToken();
                
                const response = await fetch(`${window.plaidService.baseUrl}/api/accounts`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${sessionToken}`,
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`Failed to load accounts: ${response.status}`);
                }
                
                const data = await response.json();
                console.log('Loaded accounts with transactions:', data);
                
                if (data.accounts && Array.isArray(data.accounts)) {
                    // Update the global savingsAccounts with the API data
                    // Keep existing localStorage accounts and add API accounts
                    const apiAccounts = data.accounts.map(account => ({
                        id: account.account_id,
                        name: account.name,
                        type: 'plaid',
                        institutionName: account.institution_name,
                        currentBalance: account.current_balance,
                        currency: account.currency,
                        recentTransactions: account.recent_transactions || [],
                        transactionCount: account.transaction_count || 0
                    }));
                    
                    // Merge with existing localStorage accounts
                    const existingAccounts = savingsAccounts.filter(acc => acc.type !== 'plaid');
                    savingsAccounts = [...existingAccounts, ...apiAccounts];
                    
                    // Update localStorage
                    saveSavingsAccounts(savingsAccounts);
                    
                    // Update account type chart if on home page
                    if (document.getElementById('accountTypeChart')) {
                        generateAccountTypeChart();
                    }
                    
                    console.log('Updated savingsAccounts with API data:', savingsAccounts.length, 'accounts');
                    return apiAccounts;
                }
                
                return [];
            } catch (error) {
                console.error('Error loading accounts with transactions:', error);
                return [];
            }
        }

        /**
         * Saves the current savingsAccounts array to localStorage.
         * @param {Array<{id: string, name: string}>} accounts
         */
        function saveSavingsAccounts(accounts) {
            if (!Array.isArray(accounts)) return;
            localStorage.setItem('savingsAccounts', JSON.stringify(accounts));
        }

        /**
         * Saves the expenses object to localStorage.
         * @param {Record<string, Array<{amount: number, category: string, description: string, timestamp: number}>>} expenses
         */
        function saveExpenses(expenses) {
            if (!expenses || typeof expenses !== 'object' || Array.isArray(expenses)) {
                console.error('Invalid expenses object:', expenses);
                return;
            }
            
            console.log('Saving expenses to localStorage');
            try {
                localStorage.setItem(EXPENSES_KEY, JSON.stringify(expenses));
                
                // Verify what was saved
                setTimeout(() => {
                    const savedData = localStorage.getItem(EXPENSES_KEY);
                    console.log('Verified localStorage after save - item exists:', !!savedData);
                    
                    // Check if the specific expense was removed
                    try {
                        const parsedData = JSON.parse(savedData);
                        console.log('Parsed saved data has keys:', Object.keys(parsedData));
                    } catch (e) {
                        console.error('Could not parse saved data');
                    }
                }, 10);
            } catch (error) {
                console.error('Error saving expenses to localStorage:', error);
            }
        }

        // Remove old period-date-dropdowns from sticky selector
        // Remove all code related to old dropdowns and their event listeners
        // Add new month/year slide-out logic
        function showMonthYearSlideOut() {
            // Determine if this is for save screen based on current screen
            isSaveScreenSelection = (currentScreen === 2);
            
            // Set temp values based on which screen we're on
            if (isSaveScreenSelection) {
                tempSelectedMonth = selectedSaveMonthDate.getMonth();
                tempSelectedYear = selectedSaveMonthDate.getFullYear();
            } else {
                tempSelectedMonth = selectedMonthDate.getMonth();
                tempSelectedYear = selectedMonthDate.getFullYear();
            }
            
            populateMonthYearInputs();
            document.getElementById('monthYearSlideOut').classList.add('active');
        }
        function hideMonthYearSlideOut() {
            document.getElementById('monthYearSlideOut').classList.remove('active');
        }
        let tempSelectedMonth = selectedMonthDate.getMonth();
        let tempSelectedYear = selectedMonthDate.getFullYear();
        let isSaveScreenSelection = false; // Track if we're selecting for save screen
        function populateMonthYearInputs() {
            // Set current values in the input fields
            const monthInput = document.getElementById('monthInput');
            const yearInput = document.getElementById('yearInput');
            const monthYearValue = document.getElementById('monthYearValue');
            const monthYearContent = document.getElementById('monthYearContent');
            const monthSelectValue = document.getElementById('monthSelectValue');
            const monthSelectContent = document.getElementById('monthSelectContent');
            
            const monthNames = ['January', 'February', 'March', 'April', 'May', 'June', 
                               'July', 'August', 'September', 'October', 'November', 'December'];
            
            // Update month display and selection
            if (monthSelectValue) {
                monthSelectValue.textContent = monthNames[tempSelectedMonth];
            }
            
            // Update month dropdown selection
            if (monthSelectContent) {
                monthSelectContent.querySelectorAll('.select-item').forEach((item, index) => {
                    item.classList.remove('selected');
                    if (index === tempSelectedMonth) {
                        item.classList.add('selected');
                    }
                    // Add click handler if not already added
                    if (!item.onclick) {
                        item.onclick = () => selectSlideOutOption('monthSelect', index.toString(), monthNames[index]);
                    }
                });
            }
            
            if (monthInput) {
                monthInput.value = tempSelectedMonth;
            }
            
            // Populate year dropdown with current year back 15 years
            if (monthYearContent) {
                const currentYear = new Date().getFullYear();
                monthYearContent.innerHTML = '';
                
                for (let year = currentYear; year >= currentYear - 15; year--) {
                    const yearItem = document.createElement('div');
                    yearItem.className = 'select-item';
                    yearItem.setAttribute('data-value', year.toString());
                    yearItem.textContent = year.toString();
                    yearItem.onclick = () => selectSlideOutOption('monthYear', year.toString(), year.toString());
                    
                    // Mark current selected year
                    if (year === tempSelectedYear) {
                        yearItem.classList.add('selected');
                    }
                    
                    monthYearContent.appendChild(yearItem);
                }
            }
            
            // Update year display
            if (monthYearValue) {
                monthYearValue.textContent = tempSelectedYear.toString();
            }
            
            // Update hidden select
            if (yearInput) {
                yearInput.value = tempSelectedYear;
            }
        }
        document.getElementById('applyMonthYearBtn').onclick = function() {
            // Use the temp variables directly
            if (typeof tempSelectedMonth === 'number' && typeof tempSelectedYear === 'number' && !isNaN(tempSelectedMonth) && !isNaN(tempSelectedYear)) {
                if (isSaveScreenSelection) {
                    console.log(`Setting selectedSaveMonthDate: Year=${tempSelectedYear}, Month=${tempSelectedMonth}`);
                    selectedSaveMonthDate = new Date(tempSelectedYear, tempSelectedMonth, 1);
                    console.log(`New selectedSaveMonthDate: ${selectedSaveMonthDate.toISOString()}`);
                    // Force a clean rebuild of the savings display with the new month
                    updateSaveScreen();
                } else {
                    selectedMonthDate = new Date(tempSelectedYear, tempSelectedMonth, 1);
                    updatePeriodDropdownValues();
                    updateBudgetDisplay();
                    updateExpensesList();
                    renderBudgetTitle();
                }
            }
            hideMonthYearSlideOut();
        };
        function getMonthYearString(date) {
            const monthNames = ['January','February','March','April','May','June','July','August','September','October','November','December'];
            if (!date || typeof date.getMonth !== 'function' || isNaN(date.getMonth()) || isNaN(date.getFullYear())) {
                return 'Select a month';
            }
            return `${monthNames[date.getMonth()]} ${date.getFullYear()}`;
        }
        // Update the button text in the card
        function updatePeriodDropdownValues() {
            const monthNames = ['January','February','March','April','May','June','July','August','September','October','November','December'];
            const btnText = document.getElementById('monthYearSelectorText');
            if (btnText) {
                btnText.textContent = `${monthNames[selectedMonthDate.getMonth()]} ${selectedMonthDate.getFullYear()}`;
            }
            // Also update the card title if needed (legacy support)
            const budgetPeriodLabel = document.getElementById('budgetPeriodLabel');
            if (budgetPeriodLabel) {
                budgetPeriodLabel.textContent = `${monthNames[selectedMonthDate.getMonth()]} ${selectedMonthDate.getFullYear()}`;
            }
            
            // Also update save screen selector if it exists
            updateSaveMonthYearSelector();
        }
        // Remove old period dropdowns from DOM
        document.addEventListener('DOMContentLoaded', function() {
            const oldDropdowns = document.getElementById('periodDropdowns');
            if (oldDropdowns) oldDropdowns.remove();
            updatePeriodDropdownValues();
            
            // Initialize scroll detection for quick actions
            initQuickActionsScroll();
        });
        
        // Scroll detection for hiding/showing quick actions
        function initQuickActionsScroll() {
            const screens = document.querySelectorAll('.screen');
            const cashflowScreen = screens[1]; // Screen 1 is cashflow (expenses)
            const accountsScreen = screens[2]; // Screen 2 is accounts
            
            // Set up scroll behavior for cashflow screen
            if (cashflowScreen) {
                const cashflowQuickActions = cashflowScreen.querySelector('.quick-actions');
                if (cashflowQuickActions) {
                    setupScreenScroll(cashflowScreen, cashflowQuickActions);
                }
            }
            
            // Set up scroll behavior for accounts screen
            if (accountsScreen) {
                const accountsQuickActions = accountsScreen.querySelector('.quick-actions');
                if (accountsQuickActions) {
                    setupScreenScroll(accountsScreen, accountsQuickActions);
                }
            }
        }
        
        function setupScreenScroll(screen, quickActions) {
            let lastScrollY = 0;
            let isScrolling = false;
            
            function handleScroll() {
                const currentScrollY = screen.scrollTop;
                const scrollDifference = currentScrollY - lastScrollY;
                
                // Calculate if quick actions are at their natural position (bottom of screen)
                const screenHeight = screen.clientHeight;
                const screenScrollHeight = screen.scrollHeight;
                const distanceFromBottom = screenScrollHeight - (currentScrollY + screenHeight);
                
                // Get the height of the quick actions to determine when they're at natural position
                const quickActionsHeight = quickActions.offsetHeight;
                const isAtNaturalPosition = distanceFromBottom <= quickActionsHeight + 20; // 20px buffer
                
                // If at natural position, ensure buttons are visible and stop reacting
                if (isAtNaturalPosition) {
                    quickActions.classList.remove('hidden');
                    isScrolling = false;
                    return;
                }
                
                // Only trigger if we've scrolled a significant amount (reduces sensitivity)
                if (Math.abs(scrollDifference) > 5) {
                    if (scrollDifference > 0 && currentScrollY > 50) {
                        // Scrolling down - hide quick actions
                        quickActions.classList.add('hidden');
                    } else if (scrollDifference < 0) {
                        // Scrolling up - show quick actions
                        quickActions.classList.remove('hidden');
                    }
                    
                    lastScrollY = currentScrollY;
                }
                
                isScrolling = false;
            }
            
            screen.addEventListener('scroll', function() {
                if (!isScrolling) {
                    requestAnimationFrame(handleScroll);
                    isScrolling = true;
                }
            }, { passive: true });
            
        }

        /**
         * Renders the budget card title area depending on period mode.
         * In month mode: shows a large, centered, clickable month/year with chevron below.
         * In today mode: shows a static title (e.g., 'Today' or the date).
         */
        // Current selected time range
        let currentTimeRange = 'last30days';
        
        // Monthly chart tracking
        let selectedMonth = null; // No month selected by default
        let selectedYear = null; // No year selected by default
        let previousTotal = 0; // Track previous total for animation
        
        function renderBudgetTitle() {
            const subtitleContainer = document.getElementById('budgetTitleContainer');
            const contextMenuContainer = document.getElementById('timeRangeContextMenu');
            
            if (!subtitleContainer || !contextMenuContainer) return;
            
            // Clear both containers
            subtitleContainer.innerHTML = '';
            contextMenuContainer.innerHTML = '';
            
            // Add subtitle text (left side)
            const subtitleDiv = document.createElement('div');
            subtitleDiv.className = 'section-subtitle';
            subtitleDiv.id = 'timeRangeText';
            subtitleDiv.textContent = getTimeRangeLabel(currentTimeRange);
            subtitleContainer.appendChild(subtitleDiv);
            
            // Add context menu (right side)
            const dropdownContainer = document.createElement('div');
            dropdownContainer.style.position = 'relative';
            dropdownContainer.style.display = 'inline-block';
            
            const contextBtn = document.createElement('button');
            contextBtn.id = 'timeRangeSelector';
            contextBtn.className = 'dot-menu-btn';
            contextBtn.onclick = toggleTimeRangeDropdown;
            
            // Three dots icon (more-horizontal)
            const dotsIcon = document.createElement('i');
            dotsIcon.setAttribute('data-lucide', 'more-horizontal');
            dotsIcon.className = 'w-5 h-5';
            
            contextBtn.appendChild(dotsIcon);
            
            // Create dropdown menu
            const dropdown = document.createElement('div');
            dropdown.className = 'dropdown-menu dropdown-right';
            dropdown.id = 'timeRangeDropdown';
            dropdown.innerHTML = `
                <div class="dropdown-header">Select time range</div>
                <div class="dropdown-item ${currentTimeRange === 'last7days' ? 'active' : ''}" onclick="updateTimeRange('last7days')">Last 7 days</div>
                <div class="dropdown-item ${currentTimeRange === 'last14days' ? 'active' : ''}" onclick="updateTimeRange('last14days')">Last 14 days</div>
                <div class="dropdown-item ${currentTimeRange === 'last30days' ? 'active' : ''}" onclick="updateTimeRange('last30days')">Last 30 days</div>
                <div class="dropdown-item ${currentTimeRange === 'last60days' ? 'active' : ''}" onclick="updateTimeRange('last60days')">Last 60 days</div>
                <div class="dropdown-item ${currentTimeRange === 'thismonth' ? 'active' : ''}" onclick="updateTimeRange('thismonth')">This month</div>
                <div class="dropdown-item ${currentTimeRange === 'lastmonth' ? 'active' : ''}" onclick="updateTimeRange('lastmonth')">Last month</div>
                <div class="dropdown-item ${currentTimeRange === 'thisyear' ? 'active' : ''}" onclick="updateTimeRange('thisyear')">This year</div>
                <div class="dropdown-item ${currentTimeRange === 'lastyear' ? 'active' : ''}" onclick="updateTimeRange('lastyear')">Last year</div>
                <div class="dropdown-item ${currentTimeRange === 'alltime' ? 'active' : ''}" onclick="updateTimeRange('alltime')">All time</div>
            `;
            
            dropdownContainer.appendChild(contextBtn);
            dropdownContainer.appendChild(dropdown);
            
            // Create add expense button
            const addExpenseBtn = document.createElement('button');
            addExpenseBtn.className = 'dot-menu-btn';
            addExpenseBtn.onclick = showExpenseSlideOut;
            addExpenseBtn.setAttribute('aria-label', 'Add Expense');
            
            // Plus icon
            const plusIcon = document.createElement('i');
            plusIcon.setAttribute('data-lucide', 'plus');
            plusIcon.className = 'w-5 h-5';
            addExpenseBtn.appendChild(plusIcon);
            
            contextMenuContainer.appendChild(addExpenseBtn);
            contextMenuContainer.appendChild(dropdownContainer);
            
            // Ensure Lucide icons are rendered
            if (window.lucide && typeof window.lucide.createIcons === 'function') {
                window.lucide.createIcons();
            } else {
                setTimeout(() => {
                    if (window.lucide && typeof window.lucide.createIcons === 'function') {
                        window.lucide.createIcons();
                    }
                }, 100);
            }
        }
        function getMonthYearString(date) {
            const monthNames = ['January','February','March','April','May','June','July','August','September','October','November','December'];
            return `${monthNames[date.getMonth()]} ${date.getFullYear()}`;
        }

        function getTimeRangeLabel(timeRange) {
            const labels = {
                'last7days': 'Last 7 days',
                'last14days': 'Last 14 days',
                'last30days': 'Last 30 days',
                'last60days': 'Last 60 days',
                'thismonth': 'This month',
                'lastmonth': 'Last month',
                'thisyear': 'This year',
                'lastyear': 'Last year',
                'alltime': 'All time'
            };
            return labels[timeRange] || 'Last 30 days';
        }

        // Helper function to close all dropdowns
        function closeAllDropdowns() {
            const dropdowns = [
                'timeRangeDropdown',
                'cashflowDropdown', 
                'accountsDropdown',
                'netWorthDropdown',
                'accountsNetWorthDropdown',
                'accountDetailTimeRangeDropdown'
            ];
            
            dropdowns.forEach(id => {
                const dropdown = document.getElementById(id);
                if (dropdown) {
                    dropdown.classList.remove('show');
                }
            });
        }

        function toggleTimeRangeDropdown() {
            const dropdown = document.getElementById('timeRangeDropdown');
            const btn = document.getElementById('timeRangeSelector');
            const isCurrentlyOpen = dropdown && dropdown.classList.contains('show');
            
            // Close all dropdowns first
            closeAllDropdowns();
            
            // If this dropdown wasn't open, open it
            if (dropdown && btn && !isCurrentlyOpen) {
                dropdown.classList.add('show');
                
                if (dropdown.classList.contains('show')) {
                    setTimeout(() => {
                        document.addEventListener('click', closeTimeRangeDropdownOutside);
                    }, 0);
                } else {
                    document.removeEventListener('click', closeTimeRangeDropdownOutside);
                }
            }
        }

        function closeTimeRangeDropdownOutside(event) {
            const dropdown = document.getElementById('timeRangeDropdown');
            const btn = document.getElementById('timeRangeSelector');
            
            if (dropdown && !dropdown.contains(event.target) && !btn.contains(event.target)) {
                dropdown.classList.remove('show');
                document.removeEventListener('click', closeTimeRangeDropdownOutside);
            }
        }

        function updateTimeRange(newRange) {
            // Close dropdown
            const dropdown = document.getElementById('timeRangeDropdown');
            if (dropdown) {
                dropdown.classList.remove('show');
                document.removeEventListener('click', closeTimeRangeDropdownOutside);
            }

            // Update active state
            const dropdownItems = dropdown.querySelectorAll('.dropdown-item');
            dropdownItems.forEach(item => item.classList.remove('active'));
            event.currentTarget.classList.add('active');

            // Update current time range
            currentTimeRange = newRange;

            // Update button text
            const timeRangeText = document.getElementById('timeRangeText');
            if (timeRangeText) {
                timeRangeText.textContent = getTimeRangeLabel(newRange);
            }

            // Update transactions display based on selected range
            updateTransactionsForTimeRange();
            
            // Update chart if needed
            if (typeof updateChart === 'function') {
                updateChart();
            }
            
            // Update category chart if needed
            if (typeof updateCategoryChart === 'function') {
                updateCategoryChart();
            }
            
            // Update category chart with staggered bar animation (only if currently shown)
            if (currentChartIndex === 1) {
                // Category chart - staggered bar animation (data changes with time range)
                const categoryContainer = document.getElementById('categorySpendingChart');
                staggeredBarUpdate(categoryContainer, () => {
                    generateCategoryChart();
                    updateSelectedCategoryTotal();
                });
            }
            // Monthly chart doesn't need animation since it's not affected by time range
        }

        function getDateRangeForTimeRange(timeRange) {
            const today = new Date();
            const endDate = new Date(today); // End date is today
            let startDate;

            switch (timeRange) {
                case 'last7days':
                    startDate = new Date(today);
                    startDate.setDate(today.getDate() - 6); // 7 days including today
                    break;
                case 'last14days':
                    startDate = new Date(today);
                    startDate.setDate(today.getDate() - 13);
                    break;
                case 'last30days':
                    startDate = new Date(today);
                    startDate.setDate(today.getDate() - 29);
                    break;
                case 'last60days':
                    startDate = new Date(today);
                    startDate.setDate(today.getDate() - 59);
                    break;
                case 'thismonth':
                    startDate = new Date(today.getFullYear(), today.getMonth(), 1);
                    break;
                case 'lastmonth':
                    const lastMonth = new Date(today.getFullYear(), today.getMonth() - 1, 1);
                    startDate = lastMonth;
                    endDate.setTime(new Date(today.getFullYear(), today.getMonth(), 0).getTime()); // Last day of last month
                    break;
                case 'thisyear':
                    startDate = new Date(today.getFullYear(), 0, 1);
                    break;
                case 'lastyear':
                    startDate = new Date(today.getFullYear() - 1, 0, 1);
                    endDate.setTime(new Date(today.getFullYear() - 1, 11, 31).getTime());
                    break;
                case 'alltime':
                    startDate = new Date(2020, 0, 1); // Reasonable start date
                    break;
                default:
                    // Default to last 30 days
                    startDate = new Date(today);
                    startDate.setDate(today.getDate() - 29);
            }

            return { startDate, endDate };
        }

        function updateTransactionsForTimeRange() {
            // Always filter by selected time range
            const { startDate, endDate } = getDateRangeForTimeRange(currentTimeRange);
            updateExpensesListWithRange(startDate, endDate);
        }

        function updateExpensesListWithRange(startDate, endDate) {
            const expenses = loadExpenses();
            const listContainer = document.getElementById('expensesList');
            const titleElement = document.getElementById('expensesListTitle');
            
            if (!listContainer) return;
            
            let periodExpenses = [];
            
            // Convert dates to YYYY-MM-DD format for comparison
            const startDateStr = startDate.toISOString().split('T')[0];
            const endDateStr = endDate.toISOString().split('T')[0];
            
            // Filter expenses by date range
            Object.keys(expenses).forEach(date => {
                if (date >= startDateStr && date <= endDateStr) {
                    const dayExpenses = expenses[date] || [];
                    dayExpenses.forEach(expense => {
                        periodExpenses.push({
                            ...expense,
                            date: date
                        });
                    });
                }
            });
            
            // Sort: by date (desc), then by created (asc), then by timestamp for stability
            periodExpenses.sort((a, b) => {
                if (a.date !== b.date) {
                    return new Date(b.date) - new Date(a.date); // latest date first
                }
                // If same date, sort by created descending (newest first)
                const createdA = a.created || a.timestamp;
                const createdB = b.created || b.timestamp;
                if (createdA !== createdB) {
                    return createdB - createdA; // Reversed order
                }
                // If created timestamps are the same, use timestamp for stable ordering
                return b.timestamp - a.timestamp; // Reversed order
            });
            
            if (titleElement) titleElement.textContent = "Transactions";
            
            if (periodExpenses.length === 0) {
                const rangeText = getTimeRangeLabel(currentTimeRange).toLowerCase();
                listContainer.innerHTML = `<div style="text-align: center; color: #7f8c8d; padding: 20px;">No transactions recorded for ${rangeText}</div>`;
            } else {
                // Group expenses by date
                const expensesByDate = {};
                periodExpenses.forEach(expense => {
                    if (!expensesByDate[expense.date]) {
                        expensesByDate[expense.date] = [];
                    }
                    expensesByDate[expense.date].push(expense);
                });
                
                // Generate HTML with date grouping (using similar structure to updateExpensesList)
                let html = '';
                Object.keys(expensesByDate).sort((a, b) => new Date(b) - new Date(a)).forEach(date => {
                    const expenses = expensesByDate[date];
                    const dateParts = date.split('-').map(Number);
                    const dateObj = new Date(dateParts[0], dateParts[1] - 1, dateParts[2]);
                    const formattedDate = dateObj.toLocaleDateString('en-US', { 
                        weekday: 'short', 
                        month: 'short', 
                        day: 'numeric' 
                    });
                    
                    const dayTotal = expenses.reduce((sum, expense) => sum + expense.amount, 0);
                    
                    html += `
                        <div class="date-group">
                            <div class="date-header">
                                <span class="date-title">${formattedDate}</span>
                                <span class="date-total">$${dayTotal.toFixed(2)}</span>
                            </div>
                            <div class="date-transactions">
                    `;
                    
                    expenses.forEach(expense => {
                        html += `
                            <div class="swipe-container" data-type="expense" data-date="${expense.date}" data-timestamp="${expense.timestamp}">
                                <div class="swipe-content">
                                    <div class="expense-item">
                                        <div class="expense-icon">${getCategoryEmoji(expense.category)}</div>
                                        <div class="expense-details">
                                            <div class="expense-description">${expense.description ? expense.description : `${expense.category} expense`}</div>
                                        </div>
                                        <div class="expense-amount">$${parseFloat(expense.amount).toFixed(2)}</div>
                                    </div>
                                </div>
                                <div class="swipe-action" onclick="handleExpenseDelete(this); event.stopPropagation(); return false;"><i data-lucide="x" class="w-5 h-5"></i></div>
                            </div>
                        `;
                    });
                    
                    html += `
                            </div>
                        </div>
                    `;
                });
                
                listContainer.innerHTML = html;
                
                // Re-initialize Lucide icons and swipe functionality
                if (window.lucide && typeof window.lucide.createIcons === 'function') {
                    window.lucide.createIcons();
                }
                initializeSwipeToDelete();
            }
        }
        // Patch updatePeriodDropdownValues to update the title
        const _oldUpdatePeriodDropdownValues = updatePeriodDropdownValues;
        updatePeriodDropdownValues = function() {
            if (_oldUpdatePeriodDropdownValues) _oldUpdatePeriodDropdownValues();
            renderBudgetTitle();
        };
        // Patch setPeriodMode to update the title
        const _oldSetPeriodMode = setPeriodMode;
        setPeriodMode = function(mode) {
            _oldSetPeriodMode(mode);
            renderBudgetTitle();
        };
        // Initial render on DOMContentLoaded
        document.addEventListener('DOMContentLoaded', async function() {
            console.log('DOMContentLoaded fired!');
            renderBudgetTitle();
            renderSaveTitle();
            updateHomeScreen(); // Load home page data by default
            
            // Check if carousel container exists
            const carouselCheck = document.querySelector('.chart-carousel-container');
            console.log('Carousel container check:', carouselCheck ? 'FOUND' : 'NOT FOUND');
            
            // Check what screen we're on
            console.log('Current screen:', currentScreen);
            
            // Make sure we're on the cashflow screen (screen 0)
            if (currentScreen !== 0) {
                console.log(' Not on cashflow screen, switching to screen 0');
                goToScreen(0);
            }
            
            // Also check if the dots exist
            const dotsCheck = document.querySelector('.chart-dots');
            console.log(' Chart dots check:', dotsCheck ? 'FOUND' : 'NOT FOUND');
            if (dotsCheck) {
                console.log(' Dots element:', dotsCheck);
                console.log(' Dots innerHTML:', dotsCheck.innerHTML);
                console.log(' Dots visible?', getComputedStyle(dotsCheck).display !== 'none');
            }
            
            // Initialize charts and swipe functionality
            console.log('Calling switchToChart(0)');
            if (typeof switchToChart === 'function') {
                switchToChart(0); // Show first chart by default
            }
            
            // Test dot clicks directly
            setTimeout(() => {
                console.log(' Testing dot clicks...');
                const dots = document.querySelectorAll('#budgetDisplay .chart-dots .dot');
                dots.forEach((dot, index) => {
                    dot.addEventListener('click', function() {
                        console.log(` Dot ${index} clicked via event listener!`);
                        switchToChart(index);
                    });
                });
                console.log(` Added click listeners to ${dots.length} dots in budgetDisplay`);
            }, 100);
            
            // Chart swipe will be initialized when navigating to Screen 3 (Dashboard)
            
            // Initialize category chart
            if (typeof updateCategoryChart === 'function') {
                updateCategoryChart();
            }
            
            // Load accounts with recent transactions on page load
            try {
                await loadAccountsWithTransactions();
                console.log('Loaded accounts with transactions on page load');
            } catch (error) {
                console.error('Error loading accounts on page load:', error);
            }
        });

        // Swipe to Delete Functionality
        function initializeSwipeToDelete() {
            let startX = 0;
            let currentX = 0;
            let isDragging = false;
            let currentSwipeContainer = null;
            let isSwipeAction = false; // Flag to track if swipe is active
            
            console.log('Initializing simplified swipe-to-delete functionality');

            function handleTouchStart(e) {
                const touch = e.touches ? e.touches[0] : e;
                startX = touch.clientX;
                currentX = startX;
                
                // Don't start a swipe if we clicked on the delete button
                if (e.target.closest('.swipe-action')) {
                    return;
                }
                
                const swipeContainer = e.target.closest('.swipe-container');
                if (swipeContainer) {
                    isDragging = true;
                    isSwipeAction = false; // Reset swipe action flag
                    currentSwipeContainer = swipeContainer;
                    
                    // Remove transition during drag
                    const swipeContent = swipeContainer.querySelector('.swipe-content');
                    if (swipeContent) {
                        swipeContent.style.transition = 'none';
                    }
                }
            }

            function handleTouchMove(e) {
                if (!isDragging || !currentSwipeContainer) return;
                
                const touch = e.touches ? e.touches[0] : e;
                currentX = touch.clientX;
                
                const deltaX = currentX - startX;
                
                // Only allow left swipe (negative deltaX)
                if (deltaX < 0) {
                    isSwipeAction = true; // Mark as a swipe action
                    const translateX = Math.max(deltaX, -80);
                    const swipeContent = currentSwipeContainer.querySelector('.swipe-content');
                    if (swipeContent) {
                        swipeContent.style.transform = `translateX(${translateX}px)`;
                        
                        // Prevent page scrolling when swiping horizontally
                        if (Math.abs(deltaX) > 10 && e.cancelable) {
                            e.preventDefault();
                        }
                    }
                }
            }

            function handleTouchEnd(e) {
                if (!isDragging || !currentSwipeContainer) return;
                
                isDragging = false;
                const deltaX = currentX - startX;
                const swipeContent = currentSwipeContainer.querySelector('.swipe-content');
                
                if (swipeContent) {
                    swipeContent.style.transition = 'transform 0.2s ease';
                    
                    // If swiped more than 30px to the left, show delete action
                    if (deltaX < -30) {
                        currentSwipeContainer.classList.add('swiped');
                        swipeContent.style.transform = 'translateX(-80px)';
                    } else {
                        // Reset to original position
                        currentSwipeContainer.classList.remove('swiped');
                        swipeContent.style.transform = 'translateX(0)';
                    }
                }
                
                currentSwipeContainer = null;
            }

            // Helper function to reset any swiped items when tapping elsewhere
            function handleDocumentClick(e) {
                // Don't reset if clicking on swipe action (delete button)
                if (e.target.closest('.swipe-action')) {
                    return;
                }
                
                // Reset all swiped items when clicking outside
                if (!e.target.closest('.swipe-container')) {
                    document.querySelectorAll('.swipe-container.swiped').forEach(container => {
                        container.classList.remove('swiped');
                        const content = container.querySelector('.swipe-content');
                        if (content) content.style.transform = 'translateX(0)';
                    });
                }
            }
            
            // Add custom click handler for swipe containers to handle edit functionality
            function handleContainerClick(e) {
                // If we're in a swipe action, don't trigger edit
                if (isSwipeAction) {
                    isSwipeAction = false;
                    return;
                }
                
                // Don't trigger edit if we're clicking on the delete button
                if (e.target.closest('.swipe-action')) {
                    console.log('Click on swipe action, ignoring for edit');
                    return;
                }
                
                const container = e.target.closest('.swipe-container');
                if (container) {
                    const type = container.dataset.type;
                    console.log('Container click detected for type:', type);
                    
                    // Handle expense edit
                    if (type === 'expense') {
                        const date = container.dataset.date;
                        const timestamp = container.dataset.timestamp;
                        if (date && timestamp) {
                            console.log('Calling editExpense with:', { date, timestamp });
                            // Only call editExpense if this was a tap, not a swipe
                            editExpense(date, timestamp);
                        }
                    }
                    // Handle balance edit (if needed)
                    // else if (type === 'balance') { ... }
                }
            }

            // Add event listeners to the document
            document.addEventListener('touchstart', handleTouchStart, { passive: false });
            document.addEventListener('touchmove', handleTouchMove, { passive: false });
            document.addEventListener('touchend', handleTouchEnd, { passive: true });
            document.addEventListener('click', handleDocumentClick);
            document.addEventListener('click', handleContainerClick);

            // Also handle mouse events for desktop testing
            document.addEventListener('mousedown', handleTouchStart);
            document.addEventListener('mousemove', (e) => {
                if (isDragging) handleTouchMove(e);
            });
            document.addEventListener('mouseup', handleTouchEnd);
        }

        // Initialize swipe functionality when DOM is loaded
        document.addEventListener('DOMContentLoaded', function() {
            initializeSwipeToDelete();
        });

        /**
         * Update the visibility of balance-related UI elements
         */
        function updateBalanceUIVisibility(showBalance) {
            const balanceBtn = document.getElementById('balanceActionBtn');
            const fabBalanceOption = document.getElementById('fabBalanceOption');
            const balanceActionCard = document.getElementById('balanceActionCard');
            
            if (balanceBtn) {
                balanceBtn.style.display = showBalance ? 'flex' : 'none';
            }
            
            if (fabBalanceOption) {
                fabBalanceOption.style.display = showBalance ? 'flex' : 'none';
            }
            
            if (balanceActionCard) {
                balanceActionCard.style.display = showBalance ? 'block' : 'none';
            }
        }

        /**
         * Loads comprehensive test data for both balances and expenses from January to today.
         * This function creates realistic financial data for testing the chart and reports.
         */
        async function loadTestData() {
            console.log('Loading comprehensive test data...');
            
            // Get current date and calculate January 1st of current year
            const today = new Date();
            const januaryFirst = new Date(today.getFullYear(), 0, 1);
            
            // Initialize test data structures with more account types
            const testBalances = {
                checking: {},
                savings: {},
                emergency: {},
                investment: {},
                retirement: {},
                crypto: {},
                credit_card: {},
                student_loan: {},
                mortgage: {}
            };
            
            const testExpenses = {};
            
            // Generate balance data with realistic growth patterns - limited to 3 entries per month per account
            let currentDate = new Date(januaryFirst);
            
            // Starting balances with more realistic values - ensure they start lower and increase over time
            // Start with lower values to show growth over time
            let checkingBalance = 1500 + Math.random() * 1000; // $1500-2500
            let savingsBalance = 5000 + Math.random() * 2000; // $5000-7000
            let emergencyBalance = 2000 + Math.random() * 1000; // $2000-3000
            let investmentBalance = 10000 + Math.random() * 5000; // $10000-15000
            let retirementBalance = 30000 + Math.random() * 15000; // $30000-45000
            let cryptoBalance = 1000 + Math.random() * 1000; // $1000-2000
            
            // Liability balances (these are debts, so they're negative values for net worth calculation)
            let creditCardBalance = 2500 + Math.random() * 2000; // $2500-4500 debt
            let studentLoanBalance = 15000 + Math.random() * 10000; // $15000-25000 debt
            let mortgageBalance = 180000 + Math.random() * 50000; // $180000-230000 debt
            
            // Set a steady growth rate for each account (monthly)
            const growthRates = {
                checking: 0.02 + Math.random() * 0.03, // 2-5% monthly growth
                savings: 0.03 + Math.random() * 0.02,  // 3-5% monthly growth
                emergency: 0.01 + Math.random() * 0.01, // 1-2% monthly growth
                investment: 0.04 + Math.random() * 0.04, // 4-8% monthly growth
                retirement: 0.03 + Math.random() * 0.03, // 3-6% monthly growth
                crypto: 0.05 + Math.random() * 0.1,  // 5-15% monthly growth (more volatile)
                credit_card: -0.05 - Math.random() * 0.05, // -5% to -10% monthly (paying down debt)
                student_loan: -0.01 - Math.random() * 0.01, // -1% to -2% monthly (standard loan payments)
                mortgage: -0.005 - Math.random() * 0.005 // -0.5% to -1% monthly (30-year mortgage)
            };
            
            // Market trend simulation - creates more realistic patterns
            let marketTrend = 0; // Neutral market
            let marketCycle = 0;
            let cryptoVolatility = 1;
            
            // Paycheck dates - simulate bi-weekly payments
            const paycheckDates = [];
            let paycheckDate = new Date(januaryFirst);
            // Start with first Friday in January
            while (paycheckDate.getDay() !== 5) { // 5 is Friday
                paycheckDate.setDate(paycheckDate.getDate() + 1);
            }
            // Generate bi-weekly paycheck dates
            while (paycheckDate <= today) {
                paycheckDates.push(new Date(paycheckDate));
                paycheckDate.setDate(paycheckDate.getDate() + 14); // Every two weeks
            }
            
            // Tax refund date - usually between February and April
            const taxRefundMonth = 2 + Math.floor(Math.random() * 3); // February (2) to April (4)
            const taxRefundDay = 5 + Math.floor(Math.random() * 20); // Between 5th and 25th
            const taxRefundDate = new Date(today.getFullYear(), taxRefundMonth, taxRefundDay);
            
            // Holiday/bonus dates
            const bonusDate = new Date(today.getFullYear(), 11, 15); // December 15th
            
            // Track how many entries we've created per month per account
            const entriesPerMonth = {};
            
            while (currentDate <= today) {
                const dateKey = currentDate.toISOString().split('T')[0]; // YYYY-MM-DD format
                const month = currentDate.getMonth();
                const year = currentDate.getFullYear();
                const monthKey = `${year}-${month}`;
                const dayOfMonth = currentDate.getDate();
                
                // Initialize entries counter for new month
                if (!entriesPerMonth[monthKey]) {
                    entriesPerMonth[monthKey] = {
                        checking: 0,
                        savings: 0,
                        emergency: 0,
                        investment: 0,
                        retirement: 0,
                        crypto: 0,
                        credit_card: 0,
                        student_loan: 0,
                        mortgage: 0
                    };
                }
                
                // Update market trends periodically (creates realistic waves)
                marketCycle += 0.1;
                marketTrend = Math.sin(marketCycle) * 0.8; // -0.8 to 0.8 range
                
                // Periodically update crypto volatility
                cryptoVolatility = 1 + Math.sin(marketCycle * 2) * 0.5; // 0.5 to 1.5 range
                
                // Check if today is a paycheck date
                const isPayday = paycheckDates.some(date => 
                    date.getFullYear() === currentDate.getFullYear() &&
                    date.getMonth() === currentDate.getMonth() &&
                    date.getDate() === currentDate.getDate()
                );
                
                // Determine if we should record a balance update for this day
                // Prioritize important dates: paydays, month start/end, and tax refund/bonus days
                const isMonthStart = dayOfMonth === 1;
                const isMonthEnd = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 0).getDate() === dayOfMonth;
                const isTaxRefundDay = currentDate.getFullYear() === taxRefundDate.getFullYear() && 
                                      currentDate.getMonth() === taxRefundDate.getMonth() && 
                                      currentDate.getDate() === taxRefundDate.getDate();
                const isBonusDay = currentDate.getFullYear() === bonusDate.getFullYear() && 
                                  currentDate.getMonth() === bonusDate.getMonth() && 
                                  currentDate.getDate() === bonusDate.getDate();
                
                // Record these important days regardless of other factors
                const isVeryImportantDay = isMonthStart || isMonthEnd || isPayday || isTaxRefundDay || isBonusDay;
                
                // For other days, calculate if we should record based on:
                // 1. How many entries we already have this month
                // 2. How much time has passed since the last recorded entry
                // 3. How significant the balance changes have been
                
                // Track significant changes in balances (> 5% from previous day)
                const significantChanges = {
                    checking: Math.abs(checkingBalance - (testBalances.checking[getPreviousDateKey(dateKey)] || 0)) > checkingBalance * 0.05,
                    savings: Math.abs(savingsBalance - (testBalances.savings[getPreviousDateKey(dateKey)] || 0)) > savingsBalance * 0.05,
                    emergency: Math.abs(emergencyBalance - (testBalances.emergency[getPreviousDateKey(dateKey)] || 0)) > emergencyBalance * 0.05,
                    investment: Math.abs(investmentBalance - (testBalances.investment[getPreviousDateKey(dateKey)] || 0)) > investmentBalance * 0.05,
                    retirement: Math.abs(retirementBalance - (testBalances.retirement[getPreviousDateKey(dateKey)] || 0)) > retirementBalance * 0.05,
                    crypto: Math.abs(cryptoBalance - (testBalances.crypto[getPreviousDateKey(dateKey)] || 0)) > cryptoBalance * 0.05
                };
                
                // If there's a significant change in any account, we might want to record it
                const hasSignificantChange = Object.values(significantChanges).some(change => change);
                
                // Higher chance of recording if we have fewer entries already
                const entriesThisMonth = Object.values(entriesPerMonth[monthKey]).reduce((sum, count) => sum + count, 0);
                const fewEntriesBoost = entriesThisMonth < 6 ? 0.15 : 0; // Boost chance if we have fewer than 6 total entries
                
                // Combine factors for a weighted decision
                const shouldRecordToday = isVeryImportantDay || 
                                        hasSignificantChange || 
                                        Math.random() < (0.05 + fewEntriesBoost); // 5-20% chance
                
                // Check if we're still under the limit of 3 entries per month per account
                const canAddMoreEntries = Object.values(entriesPerMonth[monthKey]).some(count => count < 3);
                
                // Helper function to get previous date key
                function getPreviousDateKey(dateKey) {
                    const date = new Date(dateKey);
                    date.setDate(date.getDate() - 1);
                    return date.toISOString().split('T')[0];
                }
                
                // Regular daily simulation
                // Add some balance updates for important days or based on our weighted decision
                if (shouldRecordToday && canAddMoreEntries) { // Record if we should and still under limit
                    // Simulate salary deposits on paydays
                    if (isPayday) {
                        const salary = 2500 + Math.random() * 500;
                        checkingBalance += salary; // Salary deposit
                        
                        // Automatic transfers to savings and retirement on payday
                        const savingsTransfer = salary * (0.1 + Math.random() * 0.1); // 10-20%
                        const retirementTransfer = salary * (0.05 + Math.random() * 0.05); // 5-10%
                        
                        checkingBalance -= savingsTransfer;
                        savingsBalance += savingsTransfer;
                        
                        checkingBalance -= retirementTransfer;
                        retirementBalance += retirementTransfer;
                    }
                    
                    // Random transfers between accounts
                    if (Math.random() < 0.15) {
                        const transfer = 500 + Math.random() * 1000;
                        if (checkingBalance > transfer + 1000) { // Only if enough buffer
                            checkingBalance -= transfer;
                            savingsBalance += transfer;
                        }
                    }
                    
                    // Occasional emergency fund contributions
                    if (Math.random() < 0.08) {
                        const emergencyTransfer = 200 + Math.random() * 300;
                        if (savingsBalance > emergencyTransfer + 1000) {
                            savingsBalance -= emergencyTransfer;
                            emergencyBalance += emergencyTransfer;
                        }
                    }
                    
                    // Random investment activity
                    if (Math.random() < 0.1) {
                        const investAmount = 500 + Math.random() * 1000;
                        if (savingsBalance > investAmount + 2000) {
                            savingsBalance -= investAmount;
                            investmentBalance += investAmount;
                        }
                    }
                    
                    // Random crypto trading
                    if (Math.random() < 0.05) {
                        const cryptoAmount = 200 + Math.random() * 500;
                        if (checkingBalance > cryptoAmount + 1000) {
                            checkingBalance -= cryptoAmount;
                            cryptoBalance += cryptoAmount;
                        }
                    }
                    
                    // Tax refund deposit
                    if (currentDate.getFullYear() === taxRefundDate.getFullYear() && 
                        currentDate.getMonth() === taxRefundDate.getMonth() && 
                        currentDate.getDate() === taxRefundDate.getDate()) {
                        const refundAmount = 1200 + Math.random() * 1800; // $1200-3000
                        checkingBalance += refundAmount;
                    }
                    
                    // Year-end bonus
                    if (currentDate.getFullYear() === bonusDate.getFullYear() && 
                        currentDate.getMonth() === bonusDate.getMonth() && 
                        currentDate.getDate() === bonusDate.getDate()) {
                        const bonusAmount = 3000 + Math.random() * 2000; // $3000-5000
                        checkingBalance += bonusAmount;
                    }
                    
                    // Add some daily spending from checking (more on weekends)
                    const isWeekend = currentDate.getDay() === 0 || currentDate.getDay() === 6;
                    const dailySpending = isWeekend ? 
                        (50 + Math.random() * 150) : // $50-200 on weekends
                        (20 + Math.random() * 80);  // $20-100 on weekdays
                    checkingBalance = Math.max(500, checkingBalance - dailySpending); // Keep minimum $500
                    
                    // Market fluctuations affect investment accounts
                    const dailyMarketChange = marketTrend + (Math.random() * 0.02 - 0.01); // -0.01 to +0.01 + trend
                    investmentBalance += investmentBalance * dailyMarketChange * 0.01; // Apply percentage change
                    retirementBalance += retirementBalance * dailyMarketChange * 0.008; // Slightly less volatile
                    
                    // Crypto is even more volatile
                    const cryptoChange = dailyMarketChange * 4 * cryptoVolatility;
                    cryptoBalance += cryptoBalance * cryptoChange * 0.01;
                    
                    // Add some interest to savings and emergency fund
                    // Higher interest during certain months (promotional rates)
                    const interestMultiplier = (month === 1 || month === 7) ? 2 : 1; // Feb and Aug
                    savingsBalance += savingsBalance * 0.0004 * interestMultiplier; // ~0.04% daily (APY ~1.5%)
                    emergencyBalance += emergencyBalance * 0.0005 * interestMultiplier; // ~0.05% daily (APY ~1.8%)
                }
                
                // Always ensure balances stay above minimum values
                checkingBalance = Math.max(100, checkingBalance);
                savingsBalance = Math.max(100, savingsBalance);
                emergencyBalance = Math.max(100, emergencyBalance);
                investmentBalance = Math.max(100, investmentBalance);
                retirementBalance = Math.max(100, retirementBalance);
                cryptoBalance = Math.max(10, cryptoBalance);
                
                // For each account, check previous entries this month and ensure new balance is different
                const checkPreviousEntryDifferent = (accountType, currentBalance) => {
                    // Get all dates with entries for this account in the current month
                    const datesWithEntries = Object.keys(testBalances[accountType])
                        .filter(date => date.startsWith(`${year}-${String(month + 1).padStart(2, '0')}`));
                    
                    // Check if any previous entries have the same rounded balance value
                    if (datesWithEntries.length > 0) {
                        const roundedCurrentBalance = accountType.includes('investment') || accountType.includes('crypto') || accountType.includes('retirement')
                            ? Math.round(currentBalance * 100) / 100  // Round to cents for investments
                            : Math.round(currentBalance);              // Round to dollars for regular accounts
                            
                        // Check if this exact balance already exists
                        const hasSameBalance = datesWithEntries.some(date => {
                            return Math.abs(testBalances[accountType][date] - roundedCurrentBalance) < 0.01;
                        });
                        
                        // If same balance exists, add a small random change (0.5%-2%)
                        if (hasSameBalance) {
                            const changeDirection = Math.random() > 0.5 ? 1 : -1;
                            const changePercent = 0.005 + Math.random() * 0.015; // 0.5% to 2%
                            return currentBalance * (1 + (changeDirection * changePercent));
                        }
                    }
                    
                    return currentBalance;
                };
                
                // Record with realistic rounding - only add entries if we're under the limit of 3 per month per account
                if (entriesPerMonth[monthKey].checking < 3) {
                    // Ensure this entry is different from previous entries
                    checkingBalance = checkPreviousEntryDifferent('checking', checkingBalance);
                    testBalances.checking[dateKey] = Math.round(checkingBalance);
                    entriesPerMonth[monthKey].checking++;
                }
                
                if (entriesPerMonth[monthKey].savings < 3) {
                    // Ensure this entry is different from previous entries
                    savingsBalance = checkPreviousEntryDifferent('savings', savingsBalance);
                    testBalances.savings[dateKey] = Math.round(savingsBalance);
                    entriesPerMonth[monthKey].savings++;
                }
                
                if (entriesPerMonth[monthKey].emergency < 3) {
                    // Ensure this entry is different from previous entries
                    emergencyBalance = checkPreviousEntryDifferent('emergency', emergencyBalance);
                    testBalances.emergency[dateKey] = Math.round(emergencyBalance);
                    entriesPerMonth[monthKey].emergency++;
                }
                
                if (entriesPerMonth[monthKey].investment < 3) {
                    // Ensure this entry is different from previous entries
                    investmentBalance = checkPreviousEntryDifferent('investment', investmentBalance);
                    testBalances.investment[dateKey] = Math.round(investmentBalance * 100) / 100;
                    entriesPerMonth[monthKey].investment++;
                }
                
                if (entriesPerMonth[monthKey].retirement < 3) {
                    // Ensure this entry is different from previous entries
                    retirementBalance = checkPreviousEntryDifferent('retirement', retirementBalance);
                    testBalances.retirement[dateKey] = Math.round(retirementBalance * 100) / 100;
                    entriesPerMonth[monthKey].retirement++;
                }
                
                if (entriesPerMonth[monthKey].crypto < 3) {
                    // Ensure this entry is different from previous entries
                    cryptoBalance = checkPreviousEntryDifferent('crypto', cryptoBalance);
                    testBalances.crypto[dateKey] = Math.round(cryptoBalance * 100) / 100;
                    entriesPerMonth[monthKey].crypto++;
                }
                
                if (entriesPerMonth[monthKey].credit_card < 3) {
                    // Ensure this entry is different from previous entries
                    creditCardBalance = checkPreviousEntryDifferent('credit_card', creditCardBalance);
                    testBalances.credit_card[dateKey] = Math.round(creditCardBalance);
                    entriesPerMonth[monthKey].credit_card++;
                }
                
                if (entriesPerMonth[monthKey].student_loan < 3) {
                    // Ensure this entry is different from previous entries
                    studentLoanBalance = checkPreviousEntryDifferent('student_loan', studentLoanBalance);
                    testBalances.student_loan[dateKey] = Math.round(studentLoanBalance);
                    entriesPerMonth[monthKey].student_loan++;
                }
                
                if (entriesPerMonth[monthKey].mortgage < 3) {
                    // Ensure this entry is different from previous entries
                    mortgageBalance = checkPreviousEntryDifferent('mortgage', mortgageBalance);
                    testBalances.mortgage[dateKey] = Math.round(mortgageBalance);
                    entriesPerMonth[monthKey].mortgage++;
                }
                
                // Generate expense data (not every day)
                if (Math.random() < 0.7) { // 70% chance of expenses
                    const expenseCategories = ['groceries', 'transportation', 'dining', 'entertainment', 'personal', 'clothing', 'health', 'subscriptions', 'other'];
                    const numExpenses = Math.floor(Math.random() * 3) + 1; // 1-3 expenses per day
                    
                    testExpenses[dateKey] = [];
                    
                    for (let i = 0; i < numExpenses; i++) {
                        const category = expenseCategories[Math.floor(Math.random() * expenseCategories.length)];
                        let amount = 0;
                        
                        // Generate realistic amounts based on category
                        switch (category) {
                            case 'groceries':
                                amount = 15 + Math.random() * 85; // $15-100
                                break;
                            case 'transportation':
                                amount = 5 + Math.random() * 45; // $5-50
                                break;
                            case 'dining':
                                amount = 12 + Math.random() * 38; // $12-50
                                break;
                            case 'entertainment':
                                amount = 8 + Math.random() * 42; // $8-50
                                break;
                            case 'personal':
                                amount = 10 + Math.random() * 40; // $10-50
                                break;
                            case 'clothing':
                                amount = 25 + Math.random() * 75; // $25-100
                                break;
                            case 'health':
                                amount = 15 + Math.random() * 35; // $15-50
                                break;
                            case 'subscriptions':
                                amount = 5 + Math.random() * 25; // $5-30
                                break;
                            case 'other':
                                amount = 5 + Math.random() * 45; // $5-50
                                break;
                        }
                        
                        testExpenses[dateKey].push({
                            amount: Math.round(amount * 100) / 100, // Round to 2 decimal places
                            category: category,
                            description: `${category.charAt(0).toUpperCase() + category.slice(1)} expense`,
                            timestamp: Date.now() + i, // Ensure unique timestamps
                            created: Date.now() + i,
                            updated: Date.now() + i
                        });
                    }
                }
                
                // Count how many accounts have reached their maximum entries
                const accountsWithMaxEntries = Object.values(entriesPerMonth[monthKey]).filter(count => count >= 3).length;
                const totalAccounts = Object.keys(entriesPerMonth[monthKey]).length;
                
                // Skip ahead if we're close to the end of the month and have most accounts filled
                // This balances between optimizing performance and ensuring good data distribution
                const isLateInMonth = dayOfMonth > 20; // Later part of month
                const mostAccountsFilled = accountsWithMaxEntries >= totalAccounts - 1; // All but one account filled
                const shouldSkipToNextMonth = isLateInMonth && mostAccountsFilled;
                
                // If we're about to start a new month, apply monthly growth to all accounts
                // This ensures consistent month-to-month growth for the "Saved this month" calculation
                if (dayOfMonth === 1 || shouldSkipToNextMonth) {
                    // Apply monthly growth rates to simulate consistent saving and investment returns
                    checkingBalance *= (1 + growthRates.checking / 30); // Daily equivalent of monthly rate
                    savingsBalance *= (1 + growthRates.savings / 30);
                    emergencyBalance *= (1 + growthRates.emergency / 30);
                    investmentBalance *= (1 + growthRates.investment / 30);
                    retirementBalance *= (1 + growthRates.retirement / 30);
                    cryptoBalance *= (1 + growthRates.crypto / 30);
                    
                    // Apply debt paydown rates (negative growth means reducing debt)
                    creditCardBalance *= (1 + growthRates.credit_card / 30);
                    studentLoanBalance *= (1 + growthRates.student_loan / 30);
                    mortgageBalance *= (1 + growthRates.mortgage / 30);
                }
                
                if (shouldSkipToNextMonth) {
                    // Move to first day of next month
                    currentDate = new Date(currentDate.getFullYear(), currentDate.getMonth() + 1, 1);
                } else {
                    // Move to next day
                    currentDate.setDate(currentDate.getDate() + 1);
                }
            }
            
            // Save test data to localStorage
            localStorage.setItem('accountBalances', JSON.stringify(testBalances));
            localStorage.setItem('dailyExpenses', JSON.stringify(testExpenses));
            
            // Initialize or update savings accounts
            const defaultAccounts = [
                { id: 'checking', name: 'Checking', type: 'cash' },
                { id: 'savings', name: 'Savings', type: 'cash' },
                { id: 'emergency', name: 'Emergency Fund', type: 'cash' },
                { id: 'investment', name: 'Brokerage Account', type: 'investment' },
                { id: 'retirement', name: '401(k)', type: 'investment' },
                { id: 'crypto', name: 'Crypto Portfolio', type: 'investment' },
                { id: 'credit_card', name: 'Credit Card', type: 'liability' },
                { id: 'student_loan', name: 'Student Loan', type: 'liability' },
                { id: 'mortgage', name: 'Mortgage', type: 'liability' }
            ];
            
            // Always update savings accounts when loading test data
            localStorage.setItem('savingsAccounts', JSON.stringify(defaultAccounts));
            // Update the global savingsAccounts variable to match
            savingsAccounts = [...defaultAccounts];
            
            console.log('Test data loaded successfully!');
            console.log('Balance data:', testBalances);
            console.log('Entries per month:', entriesPerMonth);
            console.log('Expense data sample:', Object.keys(testExpenses).slice(0, 5).map(date => ({ date, expenses: testExpenses[date] })));
            
            // Ensure all required functions are called to update the UI
            updatePeriodView(); // This will call updateSaveScreen() internally
            // Force update of all relevant UI components
            await updateSaveBalanceHistory();
            await updateSaveTotalSavingsDisplay(); // Make sure the total savings display is updated
            updateSaveTargetDisplay(); // Update the saving target display
            updateAccountList();
            updateSlideOutAccountDropdown();
            
            if (currentScreen === 1) {
                updateChart();
            }
            
            // Log some useful information
            console.log('Final account totals:');
            Object.keys(testBalances).forEach(account => {
                const dates = Object.keys(testBalances[account]).sort();
                if (dates.length > 0) {
                    const firstDate = dates[0];
                    const lastDate = dates[dates.length - 1];
                    console.log(`${account}: ${testBalances[account][firstDate]}  ${testBalances[account][lastDate]}`);
                }
            });
            
            // Show success message
            alert('Test data loaded successfully! Check the Reports screen to see the chart with comprehensive data from January to today.');
        }
    
        /**
         * Formats a number as a currency string with proper commas and 2 decimal places.
         * @param {number} amount - The amount to format.
         * @returns {string} Formatted currency string (e.g., "$1,234.56").
         */
        function formatCurrency(amount) {
            if (typeof amount !== 'number' || isNaN(amount)) {
                return '$0.00';
            }
            
            const isNegative = amount < 0;
            const absoluteAmount = Math.abs(amount);
            const formatted = '$' + absoluteAmount.toLocaleString('en-US', {
                minimumFractionDigits: 2,
                maximumFractionDigits: 2
            });
            
            return isNegative ? `(${formatted})` : formatted;
        }
        
        /**
         * Formats a number as a currency string without decimal places for whole amounts.
         * @param {number} amount - The amount to format.
         * @returns {string} Formatted currency string (e.g., "$1,234").
         */
        function formatCurrencyWhole(amount) {
            if (typeof amount !== 'number' || isNaN(amount)) {
                return '$0';
            }
            return '$' + amount.toLocaleString('en-US', {
                minimumFractionDigits: 0,
                maximumFractionDigits: 0
            });
        }

        function getCategoryEmoji(category) {
            const iconMap = {
                'groceries': '<i data-lucide="shopping-cart" class="w-4 h-4"></i>',
                'transportation': '<i data-lucide="car" class="w-4 h-4"></i>',
                'dining': '<i data-lucide="utensils" class="w-4 h-4"></i>',
                'entertainment': '<i data-lucide="film" class="w-4 h-4"></i>',
                'personal': '<i data-lucide="user" class="w-4 h-4"></i>',
                'clothing': '<i data-lucide="shirt" class="w-4 h-4"></i>',
                'health': '<i data-lucide="heart-pulse" class="w-4 h-4"></i>',
                'subscriptions': '<i data-lucide="tv" class="w-4 h-4"></i>',
                'mortgage': '<i data-lucide="home" class="w-4 h-4"></i>',
                'loan': '<i data-lucide="dollar-sign" class="w-4 h-4"></i>',
                'garbage': '<i data-lucide="trash-2" class="w-4 h-4"></i>',
                'home improvement': '<i data-lucide="hammer" class="w-4 h-4"></i>',
                'insurance': '<i data-lucide="umbrella" class="w-4 h-4"></i>',
                'pets': '<i data-lucide="dog" class="w-4 h-4"></i>',
                'phone': '<i data-lucide="smartphone" class="w-4 h-4"></i>',
                'internet': '<i data-lucide="globe" class="w-4 h-4"></i>',
                'utilities': '<i data-lucide="zap" class="w-4 h-4"></i>',
                'other': '<i data-lucide="more-horizontal" class="w-4 h-4"></i>'
            };
            
            return iconMap[category.toLowerCase()] || '<i data-lucide="more-horizontal" class="w-4 h-4"></i>';
        }
        
        function updateSaveChangeIndicators(targetAmount, progressAmount, progressPercentage) {
            const saveTargetChange = document.getElementById('saveTargetChange');
            const saveProgressChange = document.getElementById('saveProgressChange');
            
            // Update target indicator (always show monthly target)
            if (saveTargetChange) {
                const targetArrow = saveTargetChange.querySelector('.change-arrow');
                const targetText = saveTargetChange.querySelector('.change-amount');
                if (targetArrow) targetArrow.textContent = '';
                if (targetText) targetText.textContent = 'Monthly';
            }
            
            // Update progress indicator based on target progress
            if (saveProgressChange) {
                const progressArrow = saveProgressChange.querySelector('.change-arrow');
                const progressText = saveProgressChange.querySelector('.change-amount');
                const progressCard = document.querySelector('.save-progress-card .change-indicator');
                
                if (progressPercentage >= 100) {
                    if (progressArrow) progressArrow.textContent = ''; // checkmark
                    if (progressText) progressText.textContent = 'Target Met';
                    if (progressCard) progressCard.classList.remove('behind-target');
                } else if (progressPercentage >= 75) {
                    if (progressArrow) progressArrow.textContent = '';
                    if (progressText) progressText.textContent = 'On Track';
                    if (progressCard) progressCard.classList.remove('behind-target');
                } else if (progressPercentage >= 50) {
                    if (progressArrow) progressArrow.textContent = '';
                    if (progressText) progressText.textContent = 'Slow Progress';
                    if (progressCard) progressCard.classList.remove('behind-target');
                } else {
                    if (progressArrow) progressArrow.textContent = '';
                    if (progressText) progressText.textContent = 'Behind Target';
                    if (progressCard) progressCard.classList.add('behind-target');
                }
            }
        }
        
        function updateHomeScreen() {
            updateHomeTransactions();
            updateHomeCashflow();
            updateHomeNetWorth();
            initializeHomeRangePickers();
        }
        
        function updateHomeTransactions() {
            const expenses = loadExpenses();
            let monthlyTransactions = [];
            
            // Always get current month's transactions regardless of toggle state
            const today = new Date();
            const currentMonthKey = `${today.getFullYear()}-${String(today.getMonth() + 1).padStart(2, '0')}`;
            
            Object.keys(expenses).forEach(date => {
                if (date.startsWith(currentMonthKey)) {
                    const dayExpenses = expenses[date] || [];
                    dayExpenses.forEach(expense => {
                        monthlyTransactions.push({
                            ...expense,
                            date: date
                        });
                    });
                }
            });
            
            // Sort: by date (desc), then by created (asc), then by timestamp for stability (same as cashflow page)
            monthlyTransactions.sort((a, b) => {
                if (a.date !== b.date) {
                    return new Date(b.date) - new Date(a.date); // latest date first
                }
                // If same date, sort by created descending (newest first)
                const createdA = a.created || a.timestamp;
                const createdB = b.created || b.timestamp;
                if (createdA !== createdB) {
                    return createdB - createdA; // Reversed order
                }
                // If created timestamps are the same, use timestamp for stable ordering
                return b.timestamp - a.timestamp;
            });
            
            // Take last 4 transactions from current month
            const recentTransactions = monthlyTransactions.slice(0, 4);
            
            const listContainer = document.getElementById('homeTransactionsList');
            if (!listContainer) return;
            
            if (recentTransactions.length === 0) {
                listContainer.innerHTML = '<div style="text-align: center; color: #7f8c8d; padding: 20px;">No recent transactions</div>';
                return;
            }
            
            listContainer.innerHTML = recentTransactions.map(transaction => {
                // Parse date manually to avoid timezone issues (same as cashflow page)
                const dateParts = transaction.date.split('-').map(Number);
                const dateObj = new Date(dateParts[0], dateParts[1] - 1, dateParts[2]);
                const displayDate = dateObj.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                
                // Format amounts same as cashflow page - just the amount with dark color
                return `
                    <div class="home-transaction-item">
                        <div class="transaction-info">
                            <div class="transaction-description">${getCategoryEmoji(transaction.category)} ${transaction.description ? transaction.description : `${transaction.category.charAt(0).toUpperCase() + transaction.category.slice(1)} expense`}</div>
                            <div class="transaction-date">${displayDate}</div>
                        </div>
                        <div class="transaction-amount">
                            $${parseFloat(transaction.amount).toFixed(2)}
                        </div>
                    </div>
                `;
            }).join('');
            
            // Initialize Lucide icons for the new transaction icons
            if (window.lucide && typeof window.lucide.createIcons === 'function') {
                window.lucide.createIcons();
            }
        }
        
        function updateHomeCashflow() {
            // Initialize with 1M view by default
            updateHomeCashflowWithRange('1m');
        }
        
        function calculateCumulativeSpending(expenses, monthKey, isCurrentMonth) {
            const monthExpenses = [];
            const today = new Date();
            const currentDay = today.getDate();
            
            // Gather all expenses for the month
            Object.keys(expenses).forEach(date => {
                if (date.startsWith(monthKey)) {
                    const dayExpenses = expenses[date] || [];
                    const totalForDay = dayExpenses.reduce((sum, expense) => sum + expense.amount, 0);
                    if (totalForDay > 0) {
                        const dayOfMonth = parseInt(date.split('-')[2]);
                        monthExpenses.push({ day: dayOfMonth, amount: totalForDay });
                    }
                }
            });
            
            // Sort by day
            monthExpenses.sort((a, b) => a.day - b.day);
            
            // Calculate cumulative amounts
            const cumulativeData = [];
            let cumulative = 0;
            
            monthExpenses.forEach(expense => {
                cumulative += expense.amount;
                cumulativeData.push({ day: expense.day, cumulative });
            });
            
            // For current month, only show up to current day
            if (isCurrentMonth) {
                return cumulativeData.filter(d => d.day <= currentDay);
            }
            
            return cumulativeData;
        }
        
        // Universal function for animating line charts from left to right (line only)
        function animateLinePath(ctx, points, options = {}) {
            const {
                duration = 800,
                strokeStyle = '#8b5cf6',
                lineWidth = 2.5,
                onComplete = null,
                startDelay = 0
            } = options;
            
            if (points.length < 2) {
                if (onComplete) onComplete();
                return;
            }
            
            let startTime = null;
            const totalLength = points.length - 1;
            
            function animate(timestamp) {
                if (!startTime) startTime = timestamp + startDelay;
                const elapsed = timestamp - startTime;
                const progress = Math.min(elapsed / duration, 1);
                
                // Use easing function for smoother animation
                const easedProgress = 1 - Math.pow(1 - progress, 3); // cubic easing out
                
                const pointsToShow = Math.floor(easedProgress * totalLength) + 1;
                
                // Draw line up to current progress
                ctx.strokeStyle = strokeStyle;
                ctx.lineWidth = lineWidth;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.beginPath();
                
                for (let i = 0; i < Math.min(pointsToShow, points.length); i++) {
                    if (i === 0) {
                        ctx.moveTo(points[i].x, points[i].y);
                    } else {
                        ctx.lineTo(points[i].x, points[i].y);
                    }
                }
                
                // If we're between points, interpolate
                if (pointsToShow < points.length && easedProgress < 1) {
                    const lastIndex = Math.floor(easedProgress * totalLength);
                    const nextIndex = Math.min(lastIndex + 1, points.length - 1);
                    const segmentProgress = (easedProgress * totalLength) - lastIndex;
                    
                    if (lastIndex < points.length - 1) {
                        const x = points[lastIndex].x + (points[nextIndex].x - points[lastIndex].x) * segmentProgress;
                        const y = points[lastIndex].y + (points[nextIndex].y - points[lastIndex].y) * segmentProgress;
                        ctx.lineTo(x, y);
                    }
                }
                
                ctx.stroke();
                
                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else if (onComplete) {
                    onComplete();
                }
            }
            
            requestAnimationFrame(animate);
        }
        
        function drawHomeCashflowChart(currentMonthData, lastMonthData, yAxisMax) {
            const canvas = document.getElementById('homeCashflowCanvas');
            if (!canvas) return;
            
            // Set canvas size to match container
            const container = canvas.parentElement;
            const rect = container.getBoundingClientRect();
            const containerHeight = Math.max(rect.height, 250); // Minimum 250px height
            
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = containerHeight * window.devicePixelRatio;
            canvas.style.width = rect.width + 'px';
            canvas.style.height = containerHeight + 'px';
            
            const ctx = canvas.getContext('2d');
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            
            const width = rect.width;
            const height = containerHeight;
            
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            
            // Chart dimensions - minimal margins for edge-to-edge appearance
            const margin = { top: 25, right: 5, bottom: 10, left: 5 };
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;
            
            // Helper functions
            const xScale = (day) => margin.left + (day / 31) * chartWidth;
            const yScale = (amount) => margin.top + chartHeight - (amount / yAxisMax) * chartHeight;
            
            // Draw reference line at current month's latest value
            const currentValue = currentMonthData.length > 0 ? currentMonthData[currentMonthData.length - 1].cumulative : 0;
            const currentY = yScale(currentValue);
            
            ctx.strokeStyle = '#9ca3af';
            ctx.lineWidth = 1;
            ctx.setLineDash([4, 4]); // Dashed line
            ctx.beginPath();
            ctx.moveTo(margin.left, currentY);
            ctx.lineTo(margin.left + chartWidth, currentY);
            ctx.stroke();
            
            // Current amount label
            ctx.fillStyle = '#6b7280';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText(`$${(currentValue / 1000).toFixed(1)}k`, 10, currentY - 8);
            
            // Reset line dash for chart lines
            ctx.setLineDash([]);
            
            // Draw last month data (gray, thinner)
            if (lastMonthData.length > 0) {
                ctx.strokeStyle = '#d1d5db';
                ctx.lineWidth = 1.5;
                ctx.beginPath();
                
                lastMonthData.forEach((point, index) => {
                    const x = xScale(point.day);
                    const y = yScale(point.cumulative);
                    
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                
                ctx.stroke();
            }
            
            // Draw current month data (purple color, thicker) with animation
            if (currentMonthData.length > 0) {
                const gradient = ctx.createLinearGradient(0, 0, 0, height);
                gradient.addColorStop(0, '#8b5cf6');
                gradient.addColorStop(1, '#7c3aed');
                
                // Pre-fill the area
                ctx.globalAlpha = 0.1;
                ctx.fillStyle = gradient;
                ctx.beginPath();
                currentMonthData.forEach((point, index) => {
                    const x = xScale(point.day);
                    const y = yScale(point.cumulative);
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.lineTo(xScale(currentMonthData[currentMonthData.length - 1].day), yScale(0));
                ctx.lineTo(xScale(currentMonthData[0].day), yScale(0));
                ctx.closePath();
                ctx.fill();
                ctx.globalAlpha = 1;
                
                // Convert data to points for animation
                const points = currentMonthData.map(point => ({
                    x: xScale(point.day),
                    y: yScale(point.cumulative)
                }));
                
                // Animate only the line from left to right
                animateLinePath(ctx, points, {
                    strokeStyle: gradient,
                    lineWidth: 2.5,
                    duration: 1000
                });
            }
        }
        
        function updateHomeNetWorthWithChart(range) {
            const balances = loadAccountBalances();
            const today = getCurrentDate();
            
            // Calculate current net worth (assets - liabilities)
            let totalAssets = 0;
            let totalLiabilities = 0;
            
            // Load account types to distinguish between assets and liabilities
            const savingsAccounts = JSON.parse(localStorage.getItem('savingsAccounts')) || [];
            
            Object.keys(balances).forEach(accountName => {
                const accountBalances = balances[accountName];
                const currentBalance = getTotalBalanceForDate(accountBalances, today);
                
                // Check if this account is a liability
                const accountInfo = savingsAccounts.find(acc => acc.id === accountName);
                const isLiability = accountInfo && accountInfo.type === 'liability';
                
                if (isLiability) {
                    totalLiabilities += currentBalance;
                } else {
                    totalAssets += currentBalance;
                }
            });
            
            const totalNetWorth = totalAssets - totalLiabilities;
            
            // Use demo value if no actual balance data
            const displayNetWorth = totalNetWorth > 0 ? totalNetWorth : 68502;
            
            // Generate sample net worth history for chart
            const netWorthHistory = generateNetWorthHistory(displayNetWorth, range);
            
            // Draw the net worth chart
            drawHomeNetWorthChart(netWorthHistory);
            
            // Update the title and change indicator
            updateHomeNetWorthDisplay(displayNetWorth, range);
        }
        
        function generateNetWorthHistory(currentValue, range) {
            const history = [];
            let totalDays = 30;
            let sampleEveryNDays = 1; // Sample every day by default
            
            switch (range) {
                case '1m': 
                    totalDays = 30; 
                    sampleEveryNDays = 1;
                    break;
                case '3m': 
                    totalDays = 90; 
                    sampleEveryNDays = 2; // Sample every 2 days
                    break;
                case '6m': 
                    totalDays = 180; 
                    sampleEveryNDays = 3; // Sample every 3 days
                    break;
                case 'ytd': 
                    const now = new Date();
                    const startOfYear = new Date(now.getFullYear(), 0, 1);
                    totalDays = Math.floor((now - startOfYear) / (1000 * 60 * 60 * 24));
                    sampleEveryNDays = totalDays > 180 ? 7 : 3; // Weekly for long YTD periods
                    break;
                case '1y': 
                    totalDays = 365; 
                    sampleEveryNDays = 7; // Sample weekly
                    break;
                case 'all': 
                    totalDays = 1095; // 3 years
                    sampleEveryNDays = 14; // Sample bi-weekly
                    break;
            }
            
            // If currentValue is 0 (no data), use sample data for demo
            const baseValue = currentValue > 0 ? currentValue : 68502;
            
            for (let i = totalDays; i >= 0; i -= sampleEveryNDays) {
                const date = new Date();
                date.setDate(date.getDate() - i);
                
                // Generate realistic fluctuation with overall upward trend
                const trendFactor = 0.85 + (0.3 * (totalDays - i) / totalDays); // Enhanced upward trend with more variation
                const fluctuation = (Math.random() - 0.5) * 0.001; // 0.05% change for ultra-smooth curve
                const dayValue = baseValue * trendFactor * (1 + fluctuation);
                
                history.push({
                    date: date.toISOString().split('T')[0],
                    value: Math.max(0, dayValue)
                });
            }
            
            return history;
        }
        
        function generateAssetsHistory(currentValue, range) {
            const balances = loadAccountBalances();
            const savingsAccounts = JSON.parse(localStorage.getItem('savingsAccounts')) || [];
            
            // Get all available dates with balance data
            const availableDates = getAllAvailableDates(balances).sort();
            
            if (availableDates.length === 0) {
                // Fallback to demo data if no real data exists
                return generateDemoAssetsHistory(currentValue, range);
            }
            
            // Determine sampling frequency based on range
            let sampleEveryNDays = 1;
            let maxDaysBack = 30;
            
            switch (range) {
                case '1m': 
                    maxDaysBack = 30; 
                    sampleEveryNDays = 1; // Daily if available
                    break;
                case '3m': 
                    maxDaysBack = 90; 
                    sampleEveryNDays = 3; // Every 3 days
                    break;
                case '6m': 
                    maxDaysBack = 180; 
                    sampleEveryNDays = 7; // Weekly
                    break;
                case 'ytd': 
                    const now = new Date();
                    const startOfYear = new Date(now.getFullYear(), 0, 1);
                    maxDaysBack = Math.floor((now - startOfYear) / (1000 * 60 * 60 * 24));
                    sampleEveryNDays = maxDaysBack > 180 ? 14 : 7; // Bi-weekly or weekly
                    break;
                case '1y': 
                    maxDaysBack = 365; 
                    sampleEveryNDays = 14; // Bi-weekly
                    break;
                case 'all': 
                default:
                    maxDaysBack = 1095; // 3 years
                    sampleEveryNDays = 30; // Monthly
                    break;
            }
            
            // Calculate cutoff date
            const today = new Date();
            const cutoffDate = new Date();
            cutoffDate.setDate(today.getDate() - maxDaysBack);
            const cutoffDateStr = cutoffDate.toISOString().split('T')[0];
            
            // Filter dates within range
            const relevantDates = availableDates.filter(date => date >= cutoffDateStr);
            
            if (relevantDates.length === 0) {
                // Fallback if no data in range
                return generateDemoAssetsHistory(currentValue, range);
            }
            
            // Sample dates based on frequency
            const sampledDates = [];
            let lastSampledIndex = -sampleEveryNDays; // Start so first date gets included
            
            for (let i = 0; i < relevantDates.length; i++) {
                if (i - lastSampledIndex >= sampleEveryNDays || i === relevantDates.length - 1) {
                    sampledDates.push(relevantDates[i]);
                    lastSampledIndex = i;
                }
            }
            
            // Calculate real asset totals for each sampled date
            const history = [];
            
            sampledDates.forEach(date => {
                let assetsTotal = 0;
                
                // Sum up all asset accounts (exclude liabilities) for this date
                Object.keys(balances).forEach(accountId => {
                    const accountBalances = balances[accountId] || {};
                    const accountInfo = savingsAccounts.find(acc => acc.id === accountId);
                    const isLiability = accountInfo && accountInfo.type === 'liability';
                    
                    // Only count assets, not liabilities
                    if (!isLiability) {
                        // Get balance for this date, or closest previous date
                        let balance = 0;
                        if (accountBalances[date]) {
                            const balanceData = accountBalances[date];
                            balance = balanceData && typeof balanceData === 'object' ? balanceData.amount : balanceData;
                        } else {
                            // Find closest previous date with balance
                            const accountDates = Object.keys(accountBalances).filter(d => d <= date).sort();
                            if (accountDates.length > 0) {
                                const lastDate = accountDates[accountDates.length - 1];
                                const balanceData = accountBalances[lastDate];
                                balance = balanceData && typeof balanceData === 'object' ? balanceData.amount : balanceData;
                            }
                        }
                        
                        if (typeof balance === 'number' && !isNaN(balance)) {
                            assetsTotal += balance;
                        }
                    }
                });
                
                history.push({
                    date: date,
                    value: Math.max(0, assetsTotal)
                });
            });
            
            return history.length > 0 ? history : generateDemoAssetsHistory(currentValue, range);
        }
        
        function generateDemoAssetsHistory(currentValue, range) {
            // Fallback demo data when no real data exists
            const history = [];
            let totalDays = 30;
            let sampleEveryNDays = 1;
            
            switch (range) {
                case '1m': totalDays = 30; sampleEveryNDays = 1; break;
                case '3m': totalDays = 90; sampleEveryNDays = 2; break;
                case '6m': totalDays = 180; sampleEveryNDays = 3; break;
                case 'ytd': 
                    const now = new Date();
                    const startOfYear = new Date(now.getFullYear(), 0, 1);
                    totalDays = Math.floor((now - startOfYear) / (1000 * 60 * 60 * 24));
                    sampleEveryNDays = totalDays > 180 ? 7 : 3;
                    break;
                case '1y': totalDays = 365; sampleEveryNDays = 7; break;
                case 'all': totalDays = 1095; sampleEveryNDays = 14; break;
            }
            
            const baseValue = currentValue > 0 ? currentValue : 85000;
            
            for (let i = totalDays; i >= 0; i -= sampleEveryNDays) {
                const date = new Date();
                date.setDate(date.getDate() - i);
                
                // Simple trend with small variation for demo
                const progress = (totalDays - i) / totalDays;
                const trendFactor = 0.85 + (0.3 * progress);
                const fluctuation = (Math.random() - 0.5) * 0.05; // 2.5%
                const dayValue = baseValue * trendFactor * (1 + fluctuation);
                
                history.push({
                    date: date.toISOString().split('T')[0],
                    value: Math.max(baseValue * 0.7, dayValue)
                });
            }
            
            return history;
        }
        
        function drawHomeNetWorthChart(data) {
            console.log('Drawing net worth chart with data:', data);
            const canvas = document.getElementById('homeNetWorthCanvas');
            if (!canvas) {
                console.log('Net worth canvas not found');
                return;
            }
            
            // Set canvas size to match container (same height as cashflow chart)
            const container = canvas.parentElement;
            const rect = container.getBoundingClientRect();
            const containerHeight = Math.max(rect.height, 250); // Minimum 250px height like cashflow
            
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = containerHeight * window.devicePixelRatio;
            canvas.style.width = rect.width + 'px';
            canvas.style.height = containerHeight + 'px';
            
            const ctx = canvas.getContext('2d');
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            
            const width = rect.width;
            const height = containerHeight;
            
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            
            if (!data.length) return;
            
            // Chart dimensions (increased left margin for Y-axis labels)
            const margin = { top: 20, right: 20, bottom: 20, left: 60 };
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;
            
            // Find min/max values
            const values = data.map(d => d.value);
            const minValue = Math.min(...values);
            const maxValue = Math.max(...values);
            const valueRange = maxValue - minValue;
            
            // Round maxValue to nearest appropriate value for cleaner labels
            const roundedMax = Math.ceil(maxValue / 10000) * 10000;
            const adjustedRange = roundedMax - minValue;
            
            // Helper functions
            const xScale = (index) => margin.left + (index / (data.length - 1)) * chartWidth;
            const yScale = (value) => margin.top + chartHeight - ((value - minValue) / adjustedRange) * chartHeight;
            
            // Draw reference line at current (latest) value
            const currentValue = data.length > 0 ? data[data.length - 1].value : 0;
            const currentY = yScale(currentValue);
            
            ctx.strokeStyle = '#9ca3af';
            ctx.lineWidth = 1;
            ctx.setLineDash([4, 4]); // Dashed line
            ctx.beginPath();
            ctx.moveTo(margin.left, currentY);
            ctx.lineTo(margin.left + chartWidth, currentY);
            ctx.stroke();
            
            // Current amount label
            ctx.fillStyle = '#6b7280';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText(`$${(currentValue / 1000).toFixed(1)}k`, 10, currentY - 8);
            
            // Reset line dash for chart lines
            ctx.setLineDash([]);
            
            // Create gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, height);
            gradient.addColorStop(0, '#5fa42e');
            gradient.addColorStop(1, '#4a7c23');
            
            // Draw area fill
            ctx.globalAlpha = 0.1;
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.moveTo(xScale(0), yScale(data[0].value));
            data.forEach((point, index) => {
                ctx.lineTo(xScale(index), yScale(point.value));
            });
            ctx.lineTo(xScale(data.length - 1), margin.top + chartHeight);
            ctx.lineTo(xScale(0), margin.top + chartHeight);
            ctx.closePath();
            ctx.fill();
            ctx.globalAlpha = 1;
            
            // Draw smooth line using bezier curves with animation
            if (data.length > 1) {
                // Convert data to points for animation (simplified to linear for now)
                const points = data.map((point, index) => ({
                    x: xScale(index),
                    y: yScale(point.value)
                }));
                
                // Animate the line from left to right
                animateLinePath(ctx, points, {
                    strokeStyle: '#5fa42e',
                    lineWidth: 2,
                    duration: 1000
                });
            }
        }
        
        function updateHomeNetWorthDisplay(totalNetWorth, range) {
            // Calculate change percentage based on range (mock data for now)
            let changePercent = 0;
            let rangeLabel = '';
            
            switch (range) {
                case '1m':
                    changePercent = 5.2;
                    rangeLabel = '1 month';
                    break;
                case '3m':
                    changePercent = 12.8;
                    rangeLabel = '3 months';
                    break;
                case '6m':
                    changePercent = 18.5;
                    rangeLabel = '6 months';
                    break;
                case 'ytd':
                    changePercent = 15.3;
                    rangeLabel = 'year to date';
                    break;
                case '1y':
                    changePercent = 22.1;
                    rangeLabel = '1 year';
                    break;
                case 'all':
                    changePercent = 0.3;
                    rangeLabel = 'all time';
                    break;
            }
            
            const netWorthTitle = document.getElementById('netWorthTitle');
            const netWorthChange = document.getElementById('netWorthChange');
            
            if (netWorthTitle) {
                netWorthTitle.textContent = `${formatCurrency(totalNetWorth)} Net Worth`;
            }
            
            if (netWorthChange) {
                const isPositive = changePercent > 0;
                const arrow = isPositive ? 'arrow-up' : 'arrow-down';
                const color = isPositive ? '#5fa42e' : '#ef4444';
                const changeAmount = (totalNetWorth * changePercent / 100).toFixed(2);
                netWorthChange.innerHTML = `
                    <i data-lucide="${arrow}" class="w-4 h-4 inline" style="color: ${color}"></i>
                    <span style="color: ${color}">$${Math.abs(changeAmount)} (${Math.abs(changePercent).toFixed(1)}%)</span>
                `;
                
                // Reinitialize lucide icons
                if (typeof lucide !== 'undefined') {
                    lucide.createIcons();
                }
            }
        }
        
        function updateHomeNetWorth() {
            updateHomeNetWorthWithChart('all'); // Default to all time view to match active button
        }
        
        function scrollToTransactions() {
            // Scroll to transactions section on cashflow page
            setTimeout(() => {
                const transactionsCard = document.querySelector('#expensesListTitle');
                if (transactionsCard) {
                    transactionsCard.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            }, 300);
        }
        
        function handleNetWorthCardClick(event) {
            // Prevent navigation if clicking on dropdown menu or menu button
            const dropdown = document.getElementById('netWorthDropdown');
            const menuBtn = document.getElementById('netWorthMenuBtn');
            
            if (dropdown && (dropdown.contains(event.target) || menuBtn.contains(event.target))) {
                event.stopPropagation();
                return;
            }
            
            // Otherwise navigate to screen 2
            goToScreen(2);
        }

        // Home screen range picker functionality  
        function initializeHomeRangePickers() {
            // Cashflow dropdown is initialized with onclick handlers in HTML
            // Net Worth now uses dropdown menu instead of bottom picker
        }
        
        function updateHomeCashflowWithRange(range) {
            const expenses = loadExpenses();
            const today = new Date();
            const currentYear = today.getFullYear();
            const currentMonth = today.getMonth();
            
            let currentPeriodData = [];
            let lastPeriodData = [];
            
            switch (range) {
                case 'week':
                    // This week vs last week
                    // Get current week's dates (Monday to Sunday)
                    const thisWeek = [];
                    const lastWeek = [];
                    
                    // Calculate days to Monday (0 = Sunday, 1 = Monday, etc.)
                    const dayOfWeek = today.getDay();
                    const daysFromMonday = dayOfWeek === 0 ? 6 : dayOfWeek - 1;
                    
                    // Get this week's dates
                    for (let i = 0; i < 7; i++) {
                        const date = new Date(today);
                        date.setDate(today.getDate() - daysFromMonday + i);
                        thisWeek.push(date.toISOString().split('T')[0]);
                    }
                    
                    // Get last week's dates
                    for (let i = 0; i < 7; i++) {
                        const date = new Date(today);
                        date.setDate(today.getDate() - daysFromMonday - 7 + i);
                        lastWeek.push(date.toISOString().split('T')[0]);
                    }
                    
                    // Calculate cumulative spending for this week and last week
                    let thisWeekCumulative = 0;
                    let lastWeekCumulative = 0;
                    
                    for (let i = 0; i < 7; i++) {
                        const thisDate = thisWeek[i];
                        if (expenses[thisDate]) {
                            const dailyTotal = expenses[thisDate].reduce((sum, exp) => sum + exp.amount, 0);
                            thisWeekCumulative += dailyTotal;
                            currentPeriodData.push({ day: i + 1, cumulative: thisWeekCumulative });
                        } else {
                            currentPeriodData.push({ day: i + 1, cumulative: thisWeekCumulative });
                        }
                        
                        const lastDate = lastWeek[i];
                        if (expenses[lastDate]) {
                            const dailyTotal = expenses[lastDate].reduce((sum, exp) => sum + exp.amount, 0);
                            lastWeekCumulative += dailyTotal;
                            lastPeriodData.push({ day: i + 1, cumulative: lastWeekCumulative });
                        } else {
                            lastPeriodData.push({ day: i + 1, cumulative: lastWeekCumulative });
                        }
                    }
                    break;
                    
                case '1m':
                case 'month':
                    // Current month vs last month
                    const currentMonthKey = `${currentYear}-${String(currentMonth + 1).padStart(2, '0')}`;
                    const lastMonth = currentMonth === 0 ? 11 : currentMonth - 1;
                    const lastMonthYear = currentMonth === 0 ? currentYear - 1 : currentYear;
                    const lastMonthKey = `${lastMonthYear}-${String(lastMonth + 1).padStart(2, '0')}`;
                    
                    currentPeriodData = calculateCumulativeSpending(expenses, currentMonthKey, true);
                    lastPeriodData = calculateCumulativeSpending(expenses, lastMonthKey, false);
                    break;
                
                case 'year':
                    // This month vs. same month last year
                    const thisMonthKey = `${currentYear}-${String(currentMonth + 1).padStart(2, '0')}`;
                    const sameMonthLastYearKey = `${currentYear - 1}-${String(currentMonth + 1).padStart(2, '0')}`;
                    
                    currentPeriodData = calculateCumulativeSpending(expenses, thisMonthKey, true);
                    lastPeriodData = calculateCumulativeSpending(expenses, sameMonthLastYearKey, false);
                    break;
                    
                case 'average':
                    // This month vs average month over past year
                    const monthKey = `${currentYear}-${String(currentMonth + 1).padStart(2, '0')}`;
                    currentPeriodData = calculateCumulativeSpending(expenses, monthKey, true);
                    
                    // Calculate average spending for each day of the month over past year
                    const dailyAverages = {};
                    let daysCounted = {};
                    
                    // Loop through past 12 months
                    for (let i = 1; i <= 12; i++) {
                        const m = (currentMonth - i + 12) % 12;
                        const y = currentYear - Math.floor((currentMonth - i + 12) / 12);
                        const mk = `${y}-${String(m + 1).padStart(2, '0')}`;
                        
                        // For each day in this month, add to average
                        Object.keys(expenses).forEach(date => {
                            if (date.startsWith(mk)) {
                                const day = parseInt(date.split('-')[2]);
                                const dailyTotal = expenses[date].reduce((sum, exp) => sum + exp.amount, 0);
                                
                                if (!dailyAverages[day]) dailyAverages[day] = 0;
                                if (!daysCounted[day]) daysCounted[day] = 0;
                                
                                dailyAverages[day] += dailyTotal;
                                daysCounted[day]++;
                            }
                        });
                    }
                    
                    // Calculate cumulative average spending
                    let cumulativeAvg = 0;
                    for (let day = 1; day <= 31; day++) {
                        if (daysCounted[day] && daysCounted[day] > 0) {
                            const avgForDay = dailyAverages[day] / daysCounted[day];
                            cumulativeAvg += avgForDay;
                            lastPeriodData.push({ day: day, cumulative: cumulativeAvg });
                        } else if (day <= today.getDate()) {
                            // For days with no data, keep the cumulative total the same
                            lastPeriodData.push({ day: day, cumulative: cumulativeAvg });
                        }
                    }
                    break;
                    
                case 'ytd':
                    // This year vs last year (YTD)
                    let thisYearCumulative = 0;
                    let lastYearCumulative = 0;
                    let dayCount = 0;
                    
                    // Calculate days from Jan 1 to today
                    const startOfYear = new Date(currentYear, 0, 1);
                    const msPerDay = 1000 * 60 * 60 * 24;
                    const daysInYear = Math.floor((today - startOfYear) / msPerDay) + 1;
                    
                    // Loop through each day of the year so far
                    for (let i = 0; i < daysInYear; i++) {
                        const thisYearDate = new Date(currentYear, 0, 1 + i);
                        const lastYearDate = new Date(currentYear - 1, 0, 1 + i);
                        
                        const thisYearKey = `${thisYearDate.getFullYear()}-${String(thisYearDate.getMonth() + 1).padStart(2, '0')}-${String(thisYearDate.getDate()).padStart(2, '0')}`;
                        const lastYearKey = `${lastYearDate.getFullYear()}-${String(lastYearDate.getMonth() + 1).padStart(2, '0')}-${String(lastYearDate.getDate()).padStart(2, '0')}`;
                        
                        // Add this year's expenses
                        if (expenses[thisYearKey]) {
                            const dailyTotal = expenses[thisYearKey].reduce((sum, exp) => sum + exp.amount, 0);
                            thisYearCumulative += dailyTotal;
                        }
                        currentPeriodData.push({ day: i + 1, cumulative: thisYearCumulative });
                        
                        // Add last year's expenses
                        if (expenses[lastYearKey]) {
                            const dailyTotal = expenses[lastYearKey].reduce((sum, exp) => sum + exp.amount, 0);
                            lastYearCumulative += dailyTotal;
                        }
                        lastPeriodData.push({ day: i + 1, cumulative: lastYearCumulative });
                    }
                    break;
                    
                default:
                    console.log(`Unhandled range type: ${range}, falling back to 'month'`);
                    // Default to this month vs. last month
                    return updateHomeCashflowWithRange('month');
                    break;
            }
            
            // Find the maximum value for y-axis scaling
            const maxCurrent = currentPeriodData.length ? Math.max(...currentPeriodData.map(d => d.cumulative)) : 0;
            const maxLast = lastPeriodData.length ? Math.max(...lastPeriodData.map(d => d.cumulative)) : 0;
            const maxValue = Math.max(maxCurrent, maxLast);
            
            // Round to nearest $100
            const yAxisMax = Math.ceil(maxValue / 100) * 100;
            
            // Update legend labels based on range
            updateCashflowLegend(range);
            
            // Draw the chart with updated data
            drawHomeCashflowChartWithRange(currentPeriodData, lastPeriodData, yAxisMax, range);
        }
        
        function updateCashflowLegend(range) {
            const legend = document.getElementById('cashflowLegend');
            if (!legend) return;
            
            let currentLabel, previousLabel;
            
            switch (range) {
                case 'week':
                    currentLabel = 'This week';
                    previousLabel = 'Last week';
                    break;
                case '1m':
                case 'month':
                    currentLabel = 'This month';
                    previousLabel = 'Last month';
                    break;
                case 'year':
                    currentLabel = 'This month';
                    previousLabel = 'Same month last year';
                    break;
                case 'average':
                    currentLabel = 'This month';
                    previousLabel = 'Monthly average';
                    break;
                case 'ytd':
                    currentLabel = 'This year';
                    previousLabel = 'Last year (YTD)';
                    break;
                default:
                    currentLabel = 'This month';
                    previousLabel = 'Last month';
                    break;
            }
            
            const legendLabels = legend.querySelectorAll('.legend-label');
            if (legendLabels.length >= 2) {
                legendLabels[0].textContent = currentLabel;
                legendLabels[1].textContent = previousLabel;
            }
        }
        
        function toggleCashflowDropdown() {
            const dropdown = document.getElementById('cashflowDropdown');
            const menuBtn = document.getElementById('cashflowMenuBtn');
            const isCurrentlyOpen = dropdown && dropdown.classList.contains('show');
            
            // Close all dropdowns first
            closeAllDropdowns();
            
            // If this dropdown wasn't open, open it
            if (dropdown && menuBtn && !isCurrentlyOpen) {
                dropdown.classList.add('show');
                
                if (dropdown.classList.contains('show')) {
                    // Don't position with inline styles - use CSS instead
                    // This ensures the dropdown scrolls with the section
                    
                    // Close dropdown when clicking outside
                    document.addEventListener('click', closeCashflowDropdownOutside);
                } else {
                    document.removeEventListener('click', closeCashflowDropdownOutside);
                }
            }
        }
        
        function closeCashflowDropdownOutside(event) {
            const dropdown = document.getElementById('cashflowDropdown');
            const menuBtn = document.getElementById('cashflowMenuBtn');
            
            if (dropdown && !dropdown.contains(event.target) && !menuBtn.contains(event.target)) {
                dropdown.classList.remove('show');
                document.removeEventListener('click', closeCashflowDropdownOutside);
            }
        }
        
        function updateCashflowRange(rangeType) {
            // Close dropdown
            const dropdown = document.getElementById('cashflowDropdown');
            if (dropdown) {
                dropdown.classList.remove('show');
                document.removeEventListener('click', closeCashflowDropdownOutside);
            }
            
            // Update active state
            const dropdownItems = document.querySelectorAll('.dropdown-item');
            dropdownItems.forEach(item => item.classList.remove('active'));
            event.currentTarget.classList.add('active');
            
            // Update subtitle
            const subtitle = document.getElementById('cashflowSubtitle');
            if (subtitle) {
                subtitle.textContent = event.currentTarget.textContent;
            }
            
            // Pass the range type directly - no need to map to different values
            // since we've updated updateHomeCashflowWithRange to handle these directly
            const chartRange = rangeType;
            
            // Log for debugging
            console.log(`Selected range: ${rangeType}`);
            
            // Update the chart with the mapped range
            updateHomeCashflowWithRange(chartRange);
        }

        function toggleAccountsDropdown() {
            const dropdown = document.getElementById('accountsDropdown');
            const menuBtn = document.getElementById('accountsMenuBtn');
            const isCurrentlyOpen = dropdown && dropdown.classList.contains('show');
            
            // Close all dropdowns first
            closeAllDropdowns();
            
            // If this dropdown wasn't open, open it
            if (dropdown && menuBtn && !isCurrentlyOpen) {
                dropdown.classList.add('show');
                
                if (dropdown.classList.contains('show')) {
                    setTimeout(() => {
                        document.addEventListener('click', closeAccountsDropdownOutside);
                    }, 0);
                } else {
                    document.removeEventListener('click', closeAccountsDropdownOutside);
                }
            }
        }

        function closeAccountsDropdownOutside(event) {
            const dropdown = document.getElementById('accountsDropdown');
            const menuBtn = document.getElementById('accountsMenuBtn');
            
            if (dropdown && menuBtn && 
                !dropdown.contains(event.target) && 
                !menuBtn.contains(event.target)) {
                dropdown.classList.remove('show');
                document.removeEventListener('click', closeAccountsDropdownOutside);
            }
        }

        function toggleNetWorthDropdown() {
            const dropdown = document.getElementById('netWorthDropdown');
            const menuBtn = document.getElementById('netWorthMenuBtn');
            const isCurrentlyOpen = dropdown && dropdown.classList.contains('show');
            
            // Close all dropdowns first
            closeAllDropdowns();
            
            // If this dropdown wasn't open, open it
            if (dropdown && menuBtn && !isCurrentlyOpen) {
                dropdown.classList.add('show');
                
                if (dropdown.classList.contains('show')) {
                    setTimeout(() => {
                        document.addEventListener('click', closeNetWorthDropdownOutside);
                    }, 0);
                }
            }
        }
        
        function closeNetWorthDropdownOutside(event) {
            const dropdown = document.getElementById('netWorthDropdown');
            const menuBtn = document.getElementById('netWorthMenuBtn');
            
            if (dropdown && !dropdown.contains(event.target) && !menuBtn.contains(event.target)) {
                dropdown.classList.remove('show');
                document.removeEventListener('click', closeNetWorthDropdownOutside);
            }
        }
        
        function updateNetWorthRange(rangeType) {
            // Close dropdown
            const dropdown = document.getElementById('netWorthDropdown');
            if (dropdown) {
                dropdown.classList.remove('show');
                document.removeEventListener('click', closeNetWorthDropdownOutside);
            }
            
            // Update active state in dropdown
            const dropdownItems = document.querySelectorAll('#netWorthDropdown .dropdown-item');
            dropdownItems.forEach(item => item.classList.remove('active'));
            event.currentTarget.classList.add('active');
            
            // Update subtitle
            const subtitle = document.getElementById('netWorthSubtitle');
            if (subtitle) {
                subtitle.textContent = event.currentTarget.textContent;
            }
            
            // Update the net worth chart with new range
            updateHomeNetWorthWithChart(rangeType);
        }
        
        // Accounts Assets functions (showing total assets instead of net worth)
        function updateAccountsNetWorthWithChart(range) {
            const balances = loadAccountBalances();
            const today = getCurrentDate();
            
            // Calculate total assets (excluding liabilities)
            let totalAssets = 0;
            
            // Load account types to distinguish between assets and liabilities
            const savingsAccounts = JSON.parse(localStorage.getItem('savingsAccounts')) || [];
            
            Object.keys(balances).forEach(accountName => {
                const accountBalances = balances[accountName];
                const currentBalance = getTotalBalanceForDate(accountBalances, today);
                
                // Check if this account is a liability
                const accountInfo = savingsAccounts.find(acc => acc.id === accountName);
                const isLiability = accountInfo && accountInfo.type === 'liability';
                
                // Only count assets, not liabilities
                if (!isLiability) {
                    totalAssets += currentBalance;
                }
            });
            
            // Use demo value if no actual balance data  
            const displayAssets = totalAssets > 0 ? totalAssets : 85000; // Higher demo value for assets only
            
            // Generate sample assets history for chart with more variation
            const assetsHistory = generateAssetsHistory(displayAssets, range);
            
            // Draw the assets chart
            drawAccountsNetWorthChart(assetsHistory);
            
            // Update the title and change indicator
            updateAccountsNetWorthDisplay(displayAssets, range);
        }

        function drawAccountsNetWorthChart(data) {
            console.log('Drawing accounts assets chart with data:', data);
            const canvas = document.getElementById('accountsNetWorthCanvas');
            if (!canvas) {
                console.log('Accounts assets canvas not found');
                return;
            }
            
            // Set canvas size to match container (same as home chart)
            const container = canvas.parentElement;
            const rect = container.getBoundingClientRect();
            const containerHeight = Math.max(rect.height, 250); // Minimum 250px height
            
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = containerHeight * window.devicePixelRatio;
            canvas.style.width = rect.width + 'px';
            canvas.style.height = containerHeight + 'px';
            
            const ctx = canvas.getContext('2d');
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            
            const width = rect.width;
            const height = containerHeight;
            
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            
            if (!data.length) return;
            
            // Chart dimensions (proper margins for edge-to-edge feel)
            const margin = { top: 20, right: 20, bottom: 20, left: 60 };
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;
            
            // Find min/max values
            const values = data.map(d => d.value);
            const minValue = Math.min(...values);
            const maxValue = Math.max(...values);
            const valueRange = maxValue - minValue;
            
            // Round maxValue to nearest appropriate value for cleaner labels
            const roundedMax = Math.ceil(maxValue / 10000) * 10000;
            const adjustedRange = roundedMax - minValue;
            
            // Helper functions
            const xScale = (index) => margin.left + (index / (data.length - 1)) * chartWidth;
            const yScale = (value) => margin.top + chartHeight - ((value - minValue) / adjustedRange) * chartHeight;
            
            // Draw reference line at current (latest) value
            const currentValue = data.length > 0 ? data[data.length - 1].value : 0;
            const currentY = yScale(currentValue);
            
            ctx.strokeStyle = '#9ca3af';
            ctx.lineWidth = 1;
            ctx.setLineDash([4, 4]); // Dashed line
            ctx.beginPath();
            ctx.moveTo(margin.left, currentY);
            ctx.lineTo(margin.left + chartWidth, currentY);
            ctx.stroke();
            
            // Current amount label
            ctx.fillStyle = '#6b7280';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText(`$${(currentValue / 1000).toFixed(1)}k`, 10, currentY - 8);
            
            // Reset line dash for chart lines
            ctx.setLineDash([]);
            
            // Create correct gradient (matching home chart)
            const gradient = ctx.createLinearGradient(0, 0, 0, height);
            gradient.addColorStop(0, '#5fa42e');
            gradient.addColorStop(1, '#4a7c23');
            
            // Draw area fill
            ctx.globalAlpha = 0.1;
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.moveTo(xScale(0), yScale(data[0].value));
            
            for (let i = 1; i < data.length; i++) {
                ctx.lineTo(xScale(i), yScale(data[i].value));
            }
            
            ctx.lineTo(xScale(data.length - 1), height - margin.bottom);
            ctx.lineTo(xScale(0), height - margin.bottom);
            ctx.closePath();
            ctx.fill();
            
            // Draw main line with animation
            ctx.globalAlpha = 1;
            if (data.length > 1) {
                // Convert data to points for animation
                const points = data.map((point, index) => ({
                    x: xScale(index),
                    y: yScale(point.value)
                }));
                
                // Animate only the line from left to right
                animateLinePath(ctx, points, {
                    strokeStyle: '#5fa42e',
                    lineWidth: 2.5,
                    duration: 1000
                });
            }
        }

        function updateAccountsNetWorthDisplay(totalAssets, range) {
            // Calculate change percentage based on range (mock data for now)
            let changePercent = 0;
            let rangeLabel = '';
            
            switch(range) {
                case '1m': 
                    changePercent = 1.2; 
                    rangeLabel = '1 month';
                    break;
                case '3m': 
                    changePercent = 3.8; 
                    rangeLabel = '3 months';
                    break;
                case '6m': 
                    changePercent = 7.2; 
                    rangeLabel = '6 months';
                    break;
                case 'ytd': 
                    changePercent = 5.1; 
                    rangeLabel = 'Year to date';
                    break;
                case '1y': 
                    changePercent = 12.4; 
                    rangeLabel = '1 year';
                    break;
                case 'all': 
                default: 
                    changePercent = 24.6; 
                    rangeLabel = 'All time';
                    break;
            }
            
            const assetsTitle = document.getElementById('accountsNetWorthTitle');
            const assetsChange = document.getElementById('accountsNetWorthChange');
            
            if (assetsTitle) {
                assetsTitle.textContent = `${formatCurrency(totalAssets)} total assets`;
            }
            
            if (assetsChange) {
                const isPositive = changePercent > 0;
                const arrow = isPositive ? 'arrow-up' : 'arrow-down';
                const color = isPositive ? '#5fa42e' : '#ef4444';
                const changeAmount = (totalAssets * changePercent / 100).toFixed(2);
                assetsChange.innerHTML = `
                    <i data-lucide="${arrow}" class="w-4 h-4 inline" style="color: ${color}"></i>
                    <span style="color: ${color}">$${Math.abs(changeAmount)} (${Math.abs(changePercent).toFixed(1)}%)</span>
                `;
                
                // Re-initialize Lucide icons
                if (window.lucide && typeof window.lucide.createIcons === 'function') {
                    window.lucide.createIcons();
                }
            }
        }

        function updateAccountsNetWorth() {
            updateAccountsNetWorthWithChart('all'); // Default to all time view to match active button
        }

        function handleAccountsNetWorthCardClick(event) {
            // Prevent navigation if clicking on dropdown menu or menu button
            const dropdown = document.getElementById('accountsNetWorthDropdown');
            const menuBtn = document.getElementById('accountsNetWorthMenuBtn');
            
            if (dropdown && (dropdown.contains(event.target) || menuBtn.contains(event.target))) {
                event.stopPropagation();
                return;
            }
            
            // Navigate to reports or detailed view
            console.log('Navigate to accounts net worth details');
        }

        function toggleAccountsNetWorthDropdown() {
            const dropdown = document.getElementById('accountsNetWorthDropdown');
            const menuBtn = document.getElementById('accountsNetWorthMenuBtn');
            const isCurrentlyOpen = dropdown && dropdown.classList.contains('show');
            
            // Close all dropdowns first
            closeAllDropdowns();
            
            // If this dropdown wasn't open, open it
            if (dropdown && menuBtn && !isCurrentlyOpen) {
                dropdown.classList.add('show');
                
                if (dropdown.classList.contains('show')) {
                    setTimeout(() => {
                        document.addEventListener('click', closeAccountsNetWorthDropdownOutside);
                    }, 0);
                }
            }
        }

        function closeAccountsNetWorthDropdownOutside(event) {
            const dropdown = document.getElementById('accountsNetWorthDropdown');
            const menuBtn = document.getElementById('accountsNetWorthMenuBtn');
            
            if (dropdown && !dropdown.contains(event.target) && !menuBtn.contains(event.target)) {
                dropdown.classList.remove('show');
                document.removeEventListener('click', closeAccountsNetWorthDropdownOutside);
            }
        }

        function updateAccountsNetWorthRange(rangeType, event) {
            // Close dropdown
            const dropdown = document.getElementById('accountsNetWorthDropdown');
            if (dropdown) {
                dropdown.classList.remove('show');
                document.removeEventListener('click', closeAccountsNetWorthDropdownOutside);
            }
            
            // Update active state in dropdown
            const dropdownItems = document.querySelectorAll('#accountsNetWorthDropdown .dropdown-item');
            dropdownItems.forEach(item => item.classList.remove('active'));
            if (event && event.currentTarget) {
                event.currentTarget.classList.add('active');
            }
            
            // Update subtitle
            const subtitle = document.getElementById('accountsNetWorthSubtitle');
            if (subtitle && event && event.currentTarget) {
                subtitle.textContent = event.currentTarget.textContent;
            }
            
            // Update the assets chart with new range
            updateAccountsNetWorthWithChart(rangeType);
        }
        
        function calculateCumulativeSpendingForMonths(expenses, monthCount, offsetMonths) {
            const today = new Date();
            let cumulativeData = [];
            let cumulative = 0;
            
            // Generate data for each day across all months in the period
            for (let monthOffset = offsetMonths + monthCount - 1; monthOffset >= offsetMonths; monthOffset--) {
                const targetDate = new Date(today);
                targetDate.setMonth(today.getMonth() - monthOffset);
                const monthKey = `${targetDate.getFullYear()}-${String(targetDate.getMonth() + 1).padStart(2, '0')}`;
                
                // Get expenses for this month
                Object.keys(expenses).forEach(date => {
                    if (date.startsWith(monthKey)) {
                        const dayExpenses = expenses[date] || [];
                        const totalForDay = dayExpenses.reduce((sum, expense) => sum + expense.amount, 0);
                        if (totalForDay > 0) {
                            cumulative += totalForDay;
                            const dayOfPeriod = Math.floor((new Date(date) - new Date(targetDate.getFullYear(), targetDate.getMonth(), 1)) / (1000 * 60 * 60 * 24)) + 1;
                            cumulativeData.push({ day: dayOfPeriod + (monthCount - monthOffset - 1) * 31, cumulative });
                        }
                    }
                });
            }
            
            return cumulativeData.sort((a, b) => a.day - b.day);
        }
        
        function drawHomeCashflowChartWithRange(currentPeriodData, lastPeriodData, yAxisMax, range) {
            const canvas = document.getElementById('homeCashflowCanvas');
            if (!canvas) return;
            
            // Set canvas size to match container
            const container = canvas.parentElement;
            const rect = container.getBoundingClientRect();
            const containerHeight = Math.max(rect.height, 250); // Minimum 250px height
            
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = containerHeight * window.devicePixelRatio;
            canvas.style.width = rect.width + 'px';
            canvas.style.height = containerHeight + 'px';
            
            const ctx = canvas.getContext('2d');
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            
            const width = rect.width;
            const height = containerHeight;
            
            // Clear canvas
            ctx.clearRect(0, 0, width, height);
            
            // Chart dimensions - minimal margins for edge-to-edge appearance
            const margin = { top: 25, right: 0, bottom: 10, left: 0 };
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;
            
            // Calculate max days based on range
            let maxDays;
            switch (range) {
                case 'week': maxDays = 7; break;
                case 'month':
                case '1m': maxDays = 31; break;
                case 'year': maxDays = 31; break; // Month comparison
                case 'average': maxDays = 31; break; // Month comparison
                case 'ytd': 
                    // Calculate days elapsed in the year so far
                    const now = new Date();
                    const startOfYear = new Date(now.getFullYear(), 0, 1);
                    const msPerDay = 1000 * 60 * 60 * 24;
                    maxDays = Math.floor((now - startOfYear) / msPerDay) + 1;
                    break;
                default: maxDays = 31; break;
            }
            
            // Helper functions
            const xScale = (day) => margin.left + (day / maxDays) * chartWidth;
            const yScale = (amount) => margin.top + chartHeight - (amount / yAxisMax) * chartHeight;
            
            // Draw reference line at current period's latest value
            const currentValue = currentPeriodData.length > 0 ? currentPeriodData[currentPeriodData.length - 1].cumulative : 0;
            const currentY = yScale(currentValue);
            
            ctx.strokeStyle = '#9ca3af';
            ctx.lineWidth = 1;
            ctx.setLineDash([4, 4]); // Dashed line
            ctx.beginPath();
            ctx.moveTo(margin.left, currentY);
            ctx.lineTo(margin.left + chartWidth, currentY);
            ctx.stroke();
            
            // Current amount label
            ctx.fillStyle = '#6b7280';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText(`$${(currentValue / 1000).toFixed(1)}k`, 10, currentY - 8);
            
            // Reset line dash for chart lines
            ctx.setLineDash([]);
            
            // Draw last period data (gray, thinner) with smooth curves
            if (lastPeriodData.length > 0) {
                ctx.strokeStyle = '#d1d5db';
                ctx.lineWidth = 1.5;
                ctx.lineCap = 'round';
                ctx.lineJoin = 'round';
                ctx.beginPath();
                
                if (lastPeriodData.length > 1) {
                    ctx.moveTo(xScale(lastPeriodData[0].day), yScale(lastPeriodData[0].cumulative));
                    
                    for (let i = 1; i < lastPeriodData.length; i++) {
                        const prevX = xScale(lastPeriodData[i-1].day);
                        const prevY = yScale(lastPeriodData[i-1].cumulative);
                        const currX = xScale(lastPeriodData[i].day);
                        const currY = yScale(lastPeriodData[i].cumulative);
                        
                        if (i === 1) {
                            const cpx = prevX + (currX - prevX) * 0.3;
                            ctx.quadraticCurveTo(cpx, prevY, currX, currY);
                        } else {
                            const cpx1 = prevX + (currX - prevX) * 0.15;
                            const cpx2 = currX - (currX - prevX) * 0.15;
                            ctx.bezierCurveTo(cpx1, prevY, cpx2, currY, currX, currY);
                        }
                    }
                }
                
                ctx.stroke();
            }
            
            // Draw current period data (purple color, thicker) with animation
            if (currentPeriodData.length > 0) {
                const gradient = ctx.createLinearGradient(0, 0, 0, height);
                gradient.addColorStop(0, '#8b5cf6');
                gradient.addColorStop(1, '#7c3aed');
                
                // Pre-fill the area
                ctx.globalAlpha = 0.1;
                ctx.fillStyle = gradient;
                ctx.beginPath();
                currentPeriodData.forEach((point, index) => {
                    const x = xScale(point.day);
                    const y = yScale(point.cumulative);
                    if (index === 0) {
                        ctx.moveTo(x, y);
                    } else {
                        ctx.lineTo(x, y);
                    }
                });
                ctx.lineTo(xScale(currentPeriodData[currentPeriodData.length - 1].day), yScale(0));
                ctx.lineTo(xScale(currentPeriodData[0].day), yScale(0));
                ctx.closePath();
                ctx.fill();
                ctx.globalAlpha = 1;
                
                // Convert data to points for animation (simplified to linear for now)
                const points = currentPeriodData.map(point => ({
                    x: xScale(point.day),
                    y: yScale(point.cumulative)
                }));
                
                // Animate only the line from left to right
                animateLinePath(ctx, points, {
                    strokeStyle: gradient,
                    lineWidth: 2.5,
                    duration: 1000
                });
            }
        }
        

        // Update save target display
        function updateSaveTargetDisplay() {
            const today = new Date();
            const daysInMonth = new Date(today.getFullYear(), today.getMonth() + 1, 0).getDate();
            const dayOfMonth = today.getDate();
            
            let targetAmount = 0;
            let progressAmount = 0;
            let progressPercentage = 0;
            let lastBalanceDate = '';
            let periodLabel = '';
            let description = '';
            
            if (currentSavePeriodMode === 'today') {
                // Daily saving target (monthly target divided by days in month)
                targetAmount = getMonthlySavingsTarget() / daysInMonth;
                periodLabel = 'Daily Saving Target';
                description = 'daily saving target';
                
                const progressLabel = document.getElementById('saveProgressLabel');
                if (progressLabel) {
                    progressLabel.textContent = 'Progress Today';
                }
            } else {
                // Monthly saving target - use the value from settings
                targetAmount = getMonthlySavingsTarget();
                periodLabel = `${selectedSaveMonthDate.toLocaleDateString('en-US', { month: 'long', year: 'numeric' })} Saving Target`;
                description = 'monthly saving target';
                
                const progressLabel = document.getElementById('saveProgressLabel');
                if (progressLabel) {
                    progressLabel.textContent = 'Saved this month';
                }
            }
            
            // Calculate progress based on balance differences
            const { currentTotal, previousTotal, lastDate } = getSaveBalanceComparison();
            // Calculate the amount saved - ensure it's never negative for display purposes
            // For monthly view, this should show the amount saved since the previous month
            progressAmount = currentTotal - previousTotal;
            
            // For testing/debugging - log the values
            console.log('Save comparison:', {
                currentTotal,
                previousTotal,
                progressAmount,
                targetAmount
            });
            
            // Store the last balance date for reference
            lastBalanceDate = lastDate;
            
            // Calculate progress percentage against the target
            progressPercentage = targetAmount > 0 ? (progressAmount / targetAmount) * 100 : 0;
            
            // Update display elements
            const saveTargetDescription = document.getElementById('saveTargetDescription');
            const saveTargetAmount = document.getElementById('saveTargetAmount');
            const saveProgressAmount = document.getElementById('saveProgressAmount');
            
            // Update the month/year selector text
            updateSaveMonthYearSelector();
            if (saveTargetDescription) {
                saveTargetDescription.textContent = description;
            }
            if (saveTargetAmount) {
                saveTargetAmount.textContent = formatCurrency(targetAmount);
            }
            if (saveProgressAmount) {
                const sign = progressAmount >= 0 ? '+' : '';
                // Format without percentage and without "since [month name]"
                saveProgressAmount.textContent = `${sign}${formatCurrency(progressAmount)}`;
            }
            
            // Update save change indicators
            updateSaveChangeIndicators(targetAmount, progressAmount, progressPercentage);
            
            // Update progress label to show appropriate context
            const progressLabel = document.getElementById('saveProgressLabel');
            if (progressLabel) {
                if (currentSavePeriodMode === 'today') {
                    const lastDateObj = new Date(lastBalanceDate);
                    const lastDateFormatted = lastDateObj.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
                    progressLabel.textContent = `Today vs ${lastDateFormatted}`;
                } else {
                    // For monthly mode, show "Saved this month"
                    progressLabel.textContent = `Saved this month`;
                    
                    // Also update the comparison text to show which month we're comparing with
                    const previousMonth = new Date(selectedSaveMonthDate);
                    previousMonth.setMonth(previousMonth.getMonth() - 1);
                    const previousMonthName = previousMonth.toLocaleDateString('en-US', { month: 'long' });
                    
                    const saveComparisonLabel = document.getElementById('saveComparisonLabel');
                    if (saveComparisonLabel) {
                        saveComparisonLabel.textContent = `since ${previousMonthName}`;
                    }
                }
            }
        }
        
        // Get balance comparison for progress calculation
        function getBalanceComparison() {
            const balances = loadAccountBalances();
            const today = getCurrentDate();
            
            // Get current total balance (sum of all accounts)
            const currentTotal = getTotalBalanceForDate(balances, today);
            
            if (currentSavePeriodMode === 'today') {
                // For daily: compare to yesterday or last available balance
                const yesterday = getPreviousDate(today);
                let previousTotal = getTotalBalanceForDate(balances, yesterday);
                let lastDate = yesterday;
                
                // If no balance for yesterday, find the closest available balance
                if (previousTotal === 0) {
                    const availableDates = getAllAvailableDates(balances);
                    const lastAvailableDate = availableDates.find(date => date < yesterday);
                    if (lastAvailableDate) {
                        previousTotal = getTotalBalanceForDate(balances, lastAvailableDate);
                        lastDate = lastAvailableDate;
                    }
                }
                
                return { currentTotal, previousTotal, lastDate };
            } else {
                // For monthly: compare to same day last month or last available balance
                const sameDayLastMonth = getSameDayLastMonth(today);
                let previousTotal = getTotalBalanceForDate(balances, sameDayLastMonth);
                let lastDate = sameDayLastMonth;
                
                // If no balance for same day last month, find the closest available balance
                if (previousTotal === 0) {
                    const availableDates = getAllAvailableDates(balances);
                    const lastAvailableDate = availableDates.find(date => date < sameDayLastMonth);
                    if (lastAvailableDate) {
                        previousTotal = getTotalBalanceForDate(balances, lastAvailableDate);
                        lastDate = lastAvailableDate;
                    }
                }
                
                return { currentTotal, previousTotal, lastDate };
            }
        }
        
        // Get balance comparison for save screen (uses selected month)
        function getSaveBalanceComparison() {
            const balances = loadAccountBalances();
            
            if (currentSavePeriodMode === 'today') {
                // For daily mode, use the same logic as regular comparison
                return getBalanceComparison();
            } else {
                // For monthly mode, calculate the total amount saved during the selected month
                const selectedMonthKey = getSelectedSaveMonthKey();
                let currentTotal = 0;
                let lastDate = '';
                
                // Calculate total balance at the end of the selected month
                let totalEndOfMonth = 0;
                let totalStartOfMonth = 0;
                
                // Process each account
                Object.keys(balances).forEach(accountId => {
                    const accountBalances = balances[accountId] || {};
                    
                    // Get all balances for the selected month
                    const monthBalances = Object.keys(accountBalances)
                        .filter(date => date.startsWith(selectedMonthKey))
                        .sort();
                    
                    // Get the last balance for the current month
                    if (monthBalances.length > 0) {
                        const latestDate = monthBalances[monthBalances.length - 1];
                        const latestBalance = accountBalances[latestDate];
                        
                        // Handle both old format (direct number) and new format (object with amount)
                        const amount = latestBalance && typeof latestBalance === 'object' ? 
                            latestBalance.amount : latestBalance;
                            
                        if (typeof amount === 'number' && !isNaN(amount)) {
                            totalEndOfMonth += amount;
                        }
                        
                        if (!lastDate || latestDate > lastDate) {
                            lastDate = latestDate;
                        }
                    }
                    
                    // Get the first balance of the month or last balance of previous month
                    // First try to find the earliest balance of the current month
                    if (monthBalances.length > 0) {
                        const earliestDate = monthBalances[0];
                        const earliestBalance = accountBalances[earliestDate];
                        
                        const amount = earliestBalance && typeof earliestBalance === 'object' ? 
                            earliestBalance.amount : earliestBalance;
                            
                        if (typeof amount === 'number' && !isNaN(amount)) {
                            totalStartOfMonth += amount;
                        }
                    } else {
                        // If no balances for current month, try to find the latest balance from previous month
                        const previousMonth = new Date(selectedSaveMonthDate);
                        previousMonth.setMonth(previousMonth.getMonth() - 1);
                        const previousMonthKey = `${previousMonth.getFullYear()}-${String(previousMonth.getMonth() + 1).padStart(2, '0')}`;
                        
                        const previousMonthBalances = Object.keys(accountBalances)
                            .filter(date => date.startsWith(previousMonthKey))
                            .sort()
                            .reverse();
                            
                        if (previousMonthBalances.length > 0) {
                            const latestPrevBalance = accountBalances[previousMonthBalances[0]];
                            const amount = latestPrevBalance && typeof latestPrevBalance === 'object' ? 
                                latestPrevBalance.amount : latestPrevBalance;
                                
                            if (typeof amount === 'number' && !isNaN(amount)) {
                                totalStartOfMonth += amount;
                            }
                        }
                    }
                });
                
                // Calculate the amount saved during the current month
                currentTotal = totalEndOfMonth;
                
                // Get the previous month's total for comparison
                const previousMonth = new Date(selectedSaveMonthDate);
                previousMonth.setMonth(previousMonth.getMonth() - 1);
                const previousMonthKey = `${previousMonth.getFullYear()}-${String(previousMonth.getMonth() + 1).padStart(2, '0')}`;
                
                let previousTotal = 0;
                
                // Calculate the total at the end of the previous month
                Object.keys(balances).forEach(accountId => {
                    const accountBalances = balances[accountId] || {};
                    const previousMonthBalances = Object.keys(accountBalances)
                        .filter(date => date.startsWith(previousMonthKey))
                        .sort();
                        
                    if (previousMonthBalances.length > 0) {
                        const latestDate = previousMonthBalances[previousMonthBalances.length - 1];
                        const latestBalance = accountBalances[latestDate];
                        
                        const amount = latestBalance && typeof latestBalance === 'object' ? 
                            latestBalance.amount : latestBalance;
                            
                        if (typeof amount === 'number' && !isNaN(amount)) {
                            previousTotal += amount;
                        }
                    }
                });
                
                // Log for debugging
                console.log('Month comparison:', { 
                    selectedMonth: selectedMonthKey, 
                    previousMonth: previousMonthKey,
                    currentTotal, 
                    previousTotal,
                    change: currentTotal - previousTotal
                });
                
                return { currentTotal, previousTotal, lastDate };
            }
        }
        
        // Get total balance for a specific date
        function getTotalBalanceForDate(balances, date) {
            let totalBalance = 0;
            
            // Sum up all account balances for the given date
            Object.keys(balances).forEach(accountId => {
                const accountBalances = balances[accountId] || {};
                if (accountBalances[date]) {
                    const balance = accountBalances[date];
                    // Handle both old format (direct number) and new format (object with amount)
                    const amount = balance && typeof balance === 'object' ? balance.amount : balance;
                    
                    if (typeof amount === 'number' && !isNaN(amount)) {
                        totalBalance += amount;
                    }
                }
            });
            
            return totalBalance;
        }
        
        // Get previous date (yesterday)
        function getPreviousDate(dateString) {
            const date = new Date(dateString);
            date.setDate(date.getDate() - 1);
            return date.toISOString().split('T')[0];
        }
        
        // Get same day last month
        function getSameDayLastMonth(dateString) {
            const date = new Date(dateString);
            date.setMonth(date.getMonth() - 1);
            
            // Handle edge case: if current day doesn't exist in previous month
            // (e.g., Jan 31 -> Feb 28/29), use the last day of previous month
            const lastDayOfPrevMonth = new Date(date.getFullYear(), date.getMonth() + 1, 0).getDate();
            if (date.getDate() > lastDayOfPrevMonth) {
                date.setDate(lastDayOfPrevMonth);
            }
            
            return date.toISOString().split('T')[0];
        }
        
        // Get the most recent balance date for the selected month
        function getMostRecentBalanceDate() {
            try {
                const balances = loadAccountBalances();
                
                // For the current/selected month
                let year, month;
                if (currentSavePeriodMode === 'today') {
                    const today = new Date();
                    year = today.getFullYear();
                    month = today.getMonth();
                } else {
                    year = selectedSaveMonthDate.getFullYear();
                    month = selectedSaveMonthDate.getMonth();
                }
                
                // Get the start and end of the month
                const startDate = new Date(year, month, 1);
                const endDate = new Date(year, month + 1, 0);
                
                console.log('getMostRecentBalanceDate', { 
                    mode: currentSavePeriodMode,
                    year: year,
                    month: month,
                    startDate: startDate.toISOString().split('T')[0], 
                    endDate: endDate.toISOString().split('T')[0] 
                });
                
                // Find all balance dates within this month across all accounts
                let allDatesInMonth = [];
                
                if (balances && typeof balances === 'object') {
                    Object.keys(balances).forEach(accountId => {
                        const accountBalances = balances[accountId] || {};
                        
                        Object.keys(accountBalances).forEach(dateStr => {
                            try {
                                const balanceDate = new Date(dateStr);
                                if (balanceDate >= startDate && balanceDate <= endDate) {
                                    allDatesInMonth.push(dateStr);
                                }
                            } catch (e) {
                                console.error('Error processing date:', dateStr, e);
                            }
                        });
                    });
                }
                
                console.log('All dates with balance data this month:', allDatesInMonth);
                
                // If there are no dates, return 'No data'
                if (allDatesInMonth.length === 0) {
                    console.log('No balance dates found for this month');
                    return 'No data';
                }
                
                // Sort dates to find the most recent
                allDatesInMonth.sort((a, b) => new Date(b) - new Date(a));
                
                // Format the most recent date nicely
                // Parse the date in UTC to prevent timezone issues
                const mostRecentDate = new Date(allDatesInMonth[0] + 'T00:00:00Z');
                const formattedDate = mostRecentDate.toLocaleDateString('en-US', { 
                    month: 'short', 
                    day: 'numeric', 
                    year: 'numeric',
                    timeZone: 'UTC' // Ensure consistent date display regardless of local timezone
                });
                
                console.log('Most recent balance date:', formattedDate);
                return formattedDate;
            } catch (error) {
                console.error('Error in getMostRecentBalanceDate:', error);
                return 'No data';
            }
        }

        // Update save screen total savings display
        async function updateSaveTotalSavingsDisplay() {
            const balances = loadAccountBalances();
            
            // Update the "Last updated" note with the actual last balance date
            const lastUpdatedNote = document.getElementById('lastUpdatedNote');
            if (lastUpdatedNote) {
                console.log('Updating last updated note with actual date...');
                // Check if the function is defined first
                if (typeof getMostRecentBalanceDate === 'function') {
                    const mostRecentDate = getMostRecentBalanceDate();
                    console.log('Got most recent date for display:', mostRecentDate);
                    // Only show the note if there is actual data
                    if (mostRecentDate !== 'No data') {
                        lastUpdatedNote.textContent = `Last updated: ${mostRecentDate}`;
                        lastUpdatedNote.style.display = 'block'; // Show the note
                        console.log('Showing last updated note:', lastUpdatedNote.textContent);
                    } else {
                        lastUpdatedNote.style.display = 'none'; // Hide the note if no data
                        console.log('Hiding last updated note - no data available');
                    }
                } else {
                    console.error('getMostRecentBalanceDate function not defined');
                    lastUpdatedNote.style.display = 'none'; // Hide the note if function not available
                }
            }
            
            // Calculate total balance based on current view mode
            let actualTotalBalance = 0;
            
            if (currentSavePeriodMode === 'month') {
                // For month mode, use the balances from the selected month
                const selectedMonthKey = getSelectedSaveMonthKey();
                console.log('Calculating total for selected month:', selectedMonthKey);
                
                Object.keys(balances).forEach(accountId => {
                    // Get all balance entries for this account in the selected month
                    const monthEntries = Object.keys(balances[accountId] || {})
                        .filter(date => date.startsWith(selectedMonthKey))
                        .sort();  // Sort dates chronologically
                    
                    if (monthEntries.length > 0) {
                        // Get the last entry for the month
                        const lastDateInMonth = monthEntries[monthEntries.length - 1];
                        const lastBalanceInMonth = balances[accountId][lastDateInMonth];
                        
                        console.log(`Account ${accountId} last balance for ${lastDateInMonth}:`, lastBalanceInMonth);
                        
                        // Handle both object format and direct number format
                        if (lastBalanceInMonth !== null && lastBalanceInMonth !== undefined) {
                            if (typeof lastBalanceInMonth === 'object' && typeof lastBalanceInMonth.amount === 'number') {
                                actualTotalBalance += lastBalanceInMonth.amount;
                                console.log(`Added ${formatCurrency(lastBalanceInMonth.amount)} from account ${accountId} (object format)`);
                            } else if (typeof lastBalanceInMonth === 'number') {
                                actualTotalBalance += lastBalanceInMonth;
                                console.log(`Added ${formatCurrency(lastBalanceInMonth)} from account ${accountId} (number format)`);
                            } else {
                                console.warn(`Invalid balance format for account ${accountId}:`, lastBalanceInMonth);
                            }
                        }
                    }
                });
            } else {
                // For 'today' mode, use the latest balance regardless of date
                Object.keys(balances).forEach(accountId => {
                    const latestBalance = getLastBalanceForAccount(accountId);
                    if (latestBalance && typeof latestBalance.amount === 'number') {
                        actualTotalBalance += latestBalance.amount;
                    }
                });
            }
            
            // Log individual account balances for verification
            console.log(`Individual account balances for ${currentSavePeriodMode} mode:`);
            if (currentSavePeriodMode === 'month') {
                const selectedMonthKey = getSelectedSaveMonthKey();
                Object.keys(balances).forEach(accountId => {
                    const monthEntries = Object.keys(balances[accountId] || {})
                        .filter(date => date.startsWith(selectedMonthKey))
                        .sort();
                    
                    const accountInfo = savingsAccounts.find(acc => acc.id === accountId) || { name: 'Unknown Account' };
                    
                    if (monthEntries.length > 0) {
                        const lastDateInMonth = monthEntries[monthEntries.length - 1];
                        const lastBalanceInMonth = balances[accountId][lastDateInMonth];
                        
                        console.log(`- ${accountInfo.name} (${accountId}): ${formatCurrency(lastBalanceInMonth?.amount || 0)} (last entry in month: ${lastDateInMonth})`);
                    } else {
                        console.log(`- ${accountInfo.name} (${accountId}): No data for selected month`);
                    }
                });
            } else {
                Object.keys(balances).forEach(accountId => {
                    const latestBalance = getLastBalanceForAccount(accountId);
                    const accountInfo = savingsAccounts.find(acc => acc.id === accountId) || { name: 'Unknown Account' };
                    if (latestBalance && typeof latestBalance.amount === 'number') {
                        console.log(`- ${accountInfo.name} (${accountId}): ${formatCurrency(latestBalance.amount)}`);
                    }
                });
            }
            
            // Display the calculated total balance based on period mode
            const saveTotalAccountBalance = document.getElementById('saveTotalAccountBalance');
            if (saveTotalAccountBalance) {
                saveTotalAccountBalance.textContent = formatCurrency(actualTotalBalance);
                console.log(`Updating total balance display to: ${formatCurrency(actualTotalBalance)}`);
            }
            
            // For comparison and change calculation
            const saveTotalBalanceChange = document.getElementById('saveTotalBalanceChange');
            
            if (currentSavePeriodMode === 'today') {
                // For today mode, use current date
                const { previousTotal, lastDate } = getBalanceComparison();
                const balanceChange = actualTotalBalance - previousTotal;
                
                if (saveTotalBalanceChange) {
                    // Show the change since yesterday with a plus/minus sign
                    const sign = balanceChange >= 0 ? '+' : '';
                    saveTotalBalanceChange.textContent = `${sign}${formatCurrency(balanceChange)} since yesterday`;
                    saveTotalBalanceChange.className = balanceChange >= 0 ? 
                        'balance-change-modern positive' : 'balance-change-modern negative';
                }
                
                // Update the date display
                const saveBalanceDate = document.getElementById('saveBalanceDate');
                if (saveBalanceDate) {
                    const today = new Date();
                    saveBalanceDate.textContent = today.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });
                }
                
                console.log('Today total:', { actualTotalBalance, previousTotal, balanceChange });
            } else {
                // For monthly mode, use selected month data
                const { currentTotal, previousTotal, lastDate } = getSaveBalanceComparison();
                const balanceChange = actualTotalBalance - previousTotal;
                
                if (saveTotalBalanceChange) {
                    // Show the change since previous month with a plus/minus sign
                    const sign = balanceChange >= 0 ? '+' : '';
                    // Get the previous month name for display
                    const prevMonth = new Date(selectedSaveMonthDate);
                    prevMonth.setMonth(prevMonth.getMonth() - 1);
                    const prevMonthName = prevMonth.toLocaleDateString('en-US', { month: 'long' });
                    saveTotalBalanceChange.textContent = `${sign}${formatCurrency(balanceChange)} since ${prevMonthName}`;
                    saveTotalBalanceChange.className = balanceChange >= 0 ? 
                        'balance-change-modern positive' : 'balance-change-modern negative';
                    
                    console.log(`Monthly comparison: ${formatCurrency(actualTotalBalance)} vs ${formatCurrency(previousTotal)} from ${prevMonthName}`);
                }
                
                // Update the date display
                const saveBalanceDate = document.getElementById('saveBalanceDate');
                if (saveBalanceDate) {
                    const selectedMonthName = selectedSaveMonthDate.toLocaleDateString('en-US', { month: 'long' });
                    saveBalanceDate.textContent = selectedMonthName;
                }
                
                console.log('Month total:', { actualTotalBalance, currentTotal, previousTotal, balanceChange });
            }
            
            // Update save screen balance history
            await updateSaveBalanceHistory();
        }
        
        // Update save screen balance history
        // Sample account transaction data
        function generateSampleAccountTransactions() {
            const sampleTransactions = {
                'checking': [
                    { date: '2025-07-23', type: 'income', description: 'Salary Deposit', amount: 3200, category: 'Income' },
                    { date: '2025-07-22', type: 'expense', description: 'Grocery Store', amount: -89.45, category: 'Food' },
                    { date: '2025-07-21', type: 'expense', description: 'Gas Station', amount: -65.20, category: 'Transportation' },
                    { date: '2025-07-20', type: 'expense', description: 'Coffee Shop', amount: -12.50, category: 'Food' },
                    { date: '2025-07-19', type: 'transfer', description: 'Transfer to Savings', amount: -500, category: 'Transfer' }
                ],
                'savings': [
                    { date: '2025-07-19', type: 'transfer', description: 'Transfer from Checking', amount: 500, category: 'Transfer' },
                    { date: '2025-07-15', type: 'income', description: 'Interest Payment', amount: 2.34, category: 'Interest' },
                    { date: '2025-07-01', type: 'income', description: 'Monthly Auto-Save', amount: 750, category: 'Savings' }
                ],
                'creditcard': [
                    { date: '2025-07-23', type: 'expense', description: 'Amazon Purchase', amount: -156.78, category: 'Shopping' },
                    { date: '2025-07-22', type: 'expense', description: 'Restaurant', amount: -67.89, category: 'Food' },
                    { date: '2025-07-21', type: 'expense', description: 'Netflix Subscription', amount: -15.99, category: 'Entertainment' },
                    { date: '2025-07-20', type: 'expense', description: 'Uber Ride', amount: -23.45, category: 'Transportation' }
                ],
                'investment': [
                    { date: '2025-07-22', type: 'income', description: 'Dividend Payment', amount: 45.67, category: 'Investment' },
                    { date: '2025-07-15', type: 'income', description: 'Market Gain', amount: 123.45, category: 'Investment' },
                    { date: '2025-07-01', type: 'transfer', description: 'Monthly Investment', amount: 1000, category: 'Investment' }
                ]
            };
            return sampleTransactions;
        }

        // Get appropriate icon for account type
        function getAccountIcon(accountType, accountId) {
            const iconMap = {
                'cash': { icon: 'banknote' },
                'investment': { icon: 'trending-up' },
                'liability': { icon: 'credit-card' },
                'checking': { icon: 'banknote' },
                'savings': { icon: 'piggy-bank' },
                'creditcard': { icon: 'credit-card' },
                'emergency': { icon: 'shield' }
            };
            
            return iconMap[accountId] || iconMap[accountType] || { icon: 'wallet' };
        }

        // Update account type chart and total balance
        function updateAccountSummary() {
            const balances = loadAccountBalances();
            
            // Calculate totals by type
            let investmentTotal = 0;
            let cashTotal = 0;
            let debtTotal = 0;
            let totalBalance = 0;

            savingsAccounts.forEach(account => {
                const currentBalance = getLastBalanceForAccount(account.id);
                const balance = currentBalance ? currentBalance.amount : 0;
                
                if (account.type === 'investment') {
                    investmentTotal += balance;
                } else if (account.type === 'liability') {
                    debtTotal += Math.abs(balance); // Show as positive for chart
                    totalBalance -= Math.abs(balance); // Subtract debt from net worth
                } else {
                    cashTotal += balance;
                    totalBalance += balance; // Add assets to net worth
                }
                
                // Investment accounts also add to net worth
                if (account.type === 'investment') {
                    totalBalance += balance;
                }
            });


            // Old chart update code removed - now using networth chart
        }

        // Render new accounts layout
        async function renderNewAccountsLayout() {
            const container = document.getElementById('accountsList');
            if (!container) return;

            // Load accounts with recent transactions from API
            await loadAccountsWithTransactions();
            
            const balances = loadAccountBalances();
            
            // Group accounts by type
            const accountTypes = {
                'cash': { title: 'Cash & Checking', accounts: [] },
                'investment': { title: 'Investments', accounts: [] },
                'liability': { title: 'Credit & Loans', accounts: [] }
            };

            // Get current balances and group accounts
            let html = '';
            savingsAccounts.forEach(account => {
                const accountType = account.type || 'cash';
                // Use API balance for Plaid accounts, otherwise use local balance
                let balance;
                if (account.type === 'plaid' && account.currentBalance !== undefined) {
                    balance = account.currentBalance;
                } else {
                    const currentBalance = getLastBalanceForAccount(account.id);
                    balance = currentBalance ? currentBalance.amount : 0;
                }
                
                if (!accountTypes[accountType]) {
                    accountTypes[accountType] = { title: accountType.charAt(0).toUpperCase() + accountType.slice(1), accounts: [] };
                }
                
                accountTypes[accountType].accounts.push({
                    ...account,
                    balance: balance
                });
            });

            // Render each account type group
            Object.entries(accountTypes).forEach(([type, group]) => {
                if (group.accounts.length === 0) return;

                const groupTotal = group.accounts.reduce((sum, account) => {
                    // For liability accounts, treat balance as negative
                    const isLiability = account.type === 'liability';
                    const displayBalance = isLiability ? -Math.abs(account.balance) : account.balance;
                    return sum + displayBalance;
                }, 0);
                const formattedGroupTotal = groupTotal < 0 ? 
                    `(${formatCurrency(Math.abs(groupTotal))})` : 
                    formatCurrency(groupTotal);
                
                html += `
                    <div class="account-group-header">
                        <div class="account-group-title">${group.title}</div>
                        <div class="account-group-total">${formattedGroupTotal}</div>
                    </div>
                `;

                group.accounts.forEach(account => {
                    const { icon } = getAccountIcon(account.type, account.id);
                    // Use real recent transactions from API data or empty array for non-Plaid accounts
                    const accountTransactions = account.recentTransactions || [];
                    // For liability accounts, show balance as negative with parentheses
                    const isLiability = account.type === 'liability';
                    const displayBalance = isLiability ? -Math.abs(account.balance) : account.balance;
                    const formattedBalance = displayBalance < 0 ? 
                        `(${formatCurrency(Math.abs(displayBalance))})` : 
                        formatCurrency(displayBalance);
                    
                    html += `
                        <div class="account-item" onclick="openAccountDetail('${account.id}')">
                            <div class="account-icon">
                                <i data-lucide="${icon}" class="w-5 h-5"></i>
                            </div>
                            <div class="account-info">
                                <div class="account-name">${account.name}</div>
                            </div>
                            <div class="account-balance">${formattedBalance}</div>
                        </div>
                    `;
                });
            });

            container.innerHTML = html;
            
            // Reinitialize Lucide icons
            if (typeof lucide !== 'undefined') {
                lucide.createIcons();
            }
        }

        // Render transactions for an account (similar to transaction list style)
        function renderAccountTransactions(transactions) {
            if (!transactions || transactions.length === 0) {
                return '<div style="text-align: center; color: #7f8c8d; padding: 1rem;">No recent transactions</div>';
            }

            let html = '';
            transactions.slice(0, 5).forEach(transaction => {
                // Defensive checks for transaction data
                const amount = transaction.amount || 0;
                const description = transaction.description || transaction.name || 'Unknown Transaction';
                const category = transaction.category || 'other';
                const transactionType = transaction.type || (amount < 0 ? 'expense' : 'income');
                
                // For display: expenses (negative amounts) should show as red outgoing, income (positive) as green incoming
                const isIncome = transactionType === 'income' || amount > 0;
                const amountColor = isIncome ? '#5fa42e' : 'hsl(var(--foreground))';
                const formattedAmount = isIncome ? 
                    formatCurrency(Math.abs(amount)) : 
                    `(${formatCurrency(Math.abs(amount))})`;
                
                html += `
                    <div class="transaction-item">
                        <div class="transaction-icon">
                            <i data-lucide="${getTransactionIcon(transactionType)}" class="w-4 h-4"></i>
                        </div>
                        <div class="transaction-info">
                            <div class="transaction-description">${description}</div>
                            <div class="transaction-category">${category}</div>
                        </div>
                        <div class="transaction-amount" style="color: ${amountColor};">
                            ${formattedAmount}
                        </div>
                    </div>
                `;
            });

            return html;
        }

        // Get icon for transaction type
        function getTransactionIcon(type) {
            const iconMap = {
                'income': 'arrow-down-left',
                'expense': 'arrow-up-right',
                'transfer': 'arrow-right-left'
            };
            return iconMap[type] || 'circle';
        }

        // Toggle account transactions accordion
        function toggleAccountTransactions(accountId) {
            const transactionsEl = document.getElementById(`transactions-${accountId}`);
            if (transactionsEl) {
                transactionsEl.classList.toggle('expanded');
            }
        }

        // Open account detail page (placeholder)
        function openAccountDetail(accountId) {
            const account = savingsAccounts.find(acc => acc.id === accountId);
            if (!account) {
                console.error('Account not found:', accountId);
                return;
            }

            // Store current account for detail view
            window.currentAccountDetail = {
                id: accountId,
                account: account,
                timeRange: 'month'
            };

            // Update header info
            document.getElementById('accountDetailTitle').textContent = account.name;
            
            // Get current balance
            const currentBalance = getLastBalanceForAccount(accountId);
            const balance = currentBalance ? currentBalance.amount : 0;
            const isLiability = account.type === 'liability';
            const displayBalance = isLiability ? -Math.abs(balance) : balance;
            
            document.getElementById('accountDetailBalance').textContent = formatCurrency(displayBalance);

            // Show the overlay
            document.getElementById('accountDetailOverlay').classList.add('active');
            
            // Add slide transition to main content
            const appContainer = document.querySelector('.app-container');
            appContainer.classList.add('settings-open');

            // Load account data
            updateAccountDetailChart();
            updateAccountDetailTransactions();

            // Initialize swipe-to-go-back
            initAccountDetailSwipe();
        }

        function closeAccountDetail() {
            const screen = document.getElementById('accountDetailScreen');
            const overlay = document.getElementById('accountDetailOverlay');
            const appContainer = document.querySelector('.app-container');
            
            if (overlay && screen) {
                // Remove slide transition from main content
                appContainer.classList.remove('settings-open');
                
                // Animate the screen sliding out to the right with snappier transition
                screen.style.transition = 'transform 0.2s cubic-bezier(0.4, 0.0, 0.2, 1)';
                screen.style.transform = 'translateX(100%)';
                
                // Start fading out the overlay with snappier transition
                overlay.style.transition = 'opacity 0.2s cubic-bezier(0.4, 0.0, 0.2, 1)';
                overlay.style.opacity = '0';
                
                // Clean up after animation completes
                setTimeout(() => {
                    overlay.classList.remove('active');
                    overlay.style.transition = '';
                    overlay.style.opacity = '';
                    screen.style.transition = '';
                    screen.style.transform = '';
                    
                    if (window.currentAccountDetail) {
                        window.currentAccountDetail = null;
                    }
                }, 200);
            }
        }

        function updateAccountDetailChart() {
            if (!window.currentAccountDetail) return;

            const accountId = window.currentAccountDetail.id;
            const timeRange = window.currentAccountDetail.timeRange;
            
            // Generate account history for the specific account
            const accountHistory = generateAccountHistory(accountId, timeRange);
            
            // Draw the chart
            drawAccountDetailChart(accountHistory);
        }

        function smoothAccountData(data) {
            if (data.length <= 2) return data;
            
            const smoothed = [];
            const windowSize = Math.min(3, data.length); // Use smaller window for limited data
            
            for (let i = 0; i < data.length; i++) {
                if (i === 0 || i === data.length - 1) {
                    // Keep first and last points unchanged
                    smoothed.push(data[i]);
                } else {
                    // Calculate moving average for middle points
                    const start = Math.max(0, i - Math.floor(windowSize / 2));
                    const end = Math.min(data.length, i + Math.floor(windowSize / 2) + 1);
                    
                    let sum = 0;
                    let count = 0;
                    for (let j = start; j < end; j++) {
                        sum += data[j].value;
                        count++;
                    }
                    
                    smoothed.push({
                        date: data[i].date,
                        value: sum / count
                    });
                }
            }
            
            return smoothed;
        }

        function generateAccountHistory(accountId, range) {
            const balances = loadAccountBalances();
            const accountBalances = balances[accountId] || {};
            
            if (Object.keys(accountBalances).length === 0) {
                return generateDemoAccountHistory(range);
            }

            // Get available dates for this account
            const availableDates = Object.keys(accountBalances).sort();
            
            // Determine sampling and range
            let maxDaysBack = 30;
            let sampleEveryNDays = 1;
            
            switch (range) {
                case 'week': maxDaysBack = 7; sampleEveryNDays = 1; break;
                case 'month': maxDaysBack = 30; sampleEveryNDays = 1; break;
                case 'quarter': maxDaysBack = 90; sampleEveryNDays = 3; break;
                case 'year': maxDaysBack = 365; sampleEveryNDays = 7; break;
                case 'all': maxDaysBack = 1095; sampleEveryNDays = 30; break;
            }

            // Filter dates within range
            const today = new Date();
            const cutoffDate = new Date();
            cutoffDate.setDate(today.getDate() - maxDaysBack);
            const cutoffDateStr = cutoffDate.toISOString().split('T')[0];
            
            const relevantDates = availableDates.filter(date => date >= cutoffDateStr);
            
            if (relevantDates.length === 0) {
                return generateDemoAccountHistory(range);
            }

            // Sample dates
            const sampledDates = [];
            let lastSampledIndex = -sampleEveryNDays;
            
            for (let i = 0; i < relevantDates.length; i++) {
                if (i - lastSampledIndex >= sampleEveryNDays || i === relevantDates.length - 1) {
                    sampledDates.push(relevantDates[i]);
                    lastSampledIndex = i;
                }
            }

            // Build history
            const history = [];
            sampledDates.forEach(date => {
                const balanceData = accountBalances[date];
                const balance = balanceData && typeof balanceData === 'object' ? balanceData.amount : balanceData;
                
                if (typeof balance === 'number' && !isNaN(balance)) {
                    history.push({
                        date: date,
                        value: Math.abs(balance) // Use absolute value for chart display
                    });
                }
            });

            // Smooth the data to reduce rough deltas
            const smoothedHistory = smoothAccountData(history);

            return smoothedHistory.length > 0 ? smoothedHistory : generateDemoAccountHistory(range);
        }

        function generateDemoAccountHistory(range) {
            const history = [];
            let totalDays = 30;
            let baseValue = 5000;
            
            switch (range) {
                case 'week': totalDays = 7; break;
                case 'month': totalDays = 30; break;
                case 'quarter': totalDays = 90; break;
                case 'year': totalDays = 365; break;
                case 'all': totalDays = 1095; break;
            }

            for (let i = totalDays; i >= 0; i -= 1) {
                const date = new Date();
                date.setDate(date.getDate() - i);
                
                const progress = (totalDays - i) / totalDays;
                const trend = 0.9 + (0.2 * progress);
                const fluctuation = (Math.random() - 0.5) * 0.1;
                const value = baseValue * trend * (1 + fluctuation);
                
                history.push({
                    date: date.toISOString().split('T')[0],
                    value: Math.max(100, value)
                });
            }

            return history;
        }

        function drawAccountDetailChart(data) {
            const canvas = document.getElementById('accountDetailCanvas');
            if (!canvas || !data.length) return;

            // Use the same drawing logic as the assets chart
            const container = canvas.parentElement;
            const rect = container.getBoundingClientRect();
            const containerHeight = Math.max(rect.height, 200);
            
            canvas.width = rect.width * window.devicePixelRatio;
            canvas.height = containerHeight * window.devicePixelRatio;
            canvas.style.width = rect.width + 'px';
            canvas.style.height = containerHeight + 'px';
            
            const ctx = canvas.getContext('2d');
            ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
            
            const width = rect.width;
            const height = containerHeight;
            
            ctx.clearRect(0, 0, width, height);
            
            const margin = { top: 20, right: 20, bottom: 20, left: 60 };
            const chartWidth = width - margin.left - margin.right;
            const chartHeight = height - margin.top - margin.bottom;
            
            const values = data.map(d => d.value);
            const minValue = Math.min(...values);
            const maxValue = Math.max(...values);
            const valueRange = maxValue - minValue;
            
            const roundedMax = Math.ceil(maxValue / 1000) * 1000;
            const adjustedRange = roundedMax - minValue;
            
            const xScale = (index) => margin.left + (index / (data.length - 1)) * chartWidth;
            const yScale = (value) => margin.top + chartHeight - ((value - minValue) / adjustedRange) * chartHeight;
            
            // Current value reference line
            const currentValue = data[data.length - 1].value;
            const currentY = yScale(currentValue);
            
            ctx.strokeStyle = '#9ca3af';
            ctx.lineWidth = 1;
            ctx.setLineDash([4, 4]);
            ctx.beginPath();
            ctx.moveTo(margin.left, currentY);
            ctx.lineTo(margin.left + chartWidth, currentY);
            ctx.stroke();
            
            // Current amount label
            ctx.fillStyle = '#6b7280';
            ctx.font = '12px sans-serif';
            ctx.textAlign = 'left';
            ctx.fillText(`$${(currentValue / 1000).toFixed(1)}k`, 10, currentY - 8);
            
            ctx.setLineDash([]);
            
            // Gradient
            const gradient = ctx.createLinearGradient(0, 0, 0, height);
            gradient.addColorStop(0, '#5fa42e');
            gradient.addColorStop(1, '#4a7c23');
            
            // Area fill
            ctx.globalAlpha = 0.1;
            ctx.fillStyle = gradient;
            ctx.beginPath();
            ctx.moveTo(xScale(0), yScale(data[0].value));
            
            for (let i = 1; i < data.length; i++) {
                ctx.lineTo(xScale(i), yScale(data[i].value));
            }
            
            ctx.lineTo(xScale(data.length - 1), height - margin.bottom);
            ctx.lineTo(xScale(0), height - margin.bottom);
            ctx.closePath();
            ctx.fill();
            
            // Main line with animation
            ctx.globalAlpha = 1;
            if (data.length > 1) {
                // Convert data to points for animation
                const points = data.map((point, index) => ({
                    x: xScale(index),
                    y: yScale(point.value)
                }));
                
                // Animate only the line from left to right
                animateLinePath(ctx, points, {
                    strokeStyle: '#5fa42e',
                    lineWidth: 2.5,
                    duration: 1000
                });
            }
        }

        function toggleAccountDetailTimeRange() {
            const dropdown = document.getElementById('accountDetailTimeRangeDropdown');
            const menuBtn = document.getElementById('accountDetailTimeRangeBtn');
            const isCurrentlyOpen = dropdown && dropdown.classList.contains('show');
            
            // Close all dropdowns first
            closeAllDropdowns();
            
            // If this dropdown wasn't open, open it
            if (dropdown && menuBtn && !isCurrentlyOpen) {
                dropdown.classList.add('show');
                
                if (dropdown.classList.contains('show')) {
                    setTimeout(() => {
                        document.addEventListener('click', closeAccountDetailTimeRangeOutside);
                    }, 0);
                }
            }
        }

        function closeAccountDetailTimeRangeOutside(event) {
            const dropdown = document.getElementById('accountDetailTimeRangeDropdown');
            const menuBtn = document.getElementById('accountDetailTimeRangeBtn');
            
            if (dropdown && !dropdown.contains(event.target) && !menuBtn.contains(event.target)) {
                dropdown.classList.remove('show');
                document.removeEventListener('click', closeAccountDetailTimeRangeOutside);
            }
        }

        function updateAccountDetailTimeRange(rangeType, event) {
            if (!window.currentAccountDetail) return;

            // Close dropdown
            const dropdown = document.getElementById('accountDetailTimeRangeDropdown');
            if (dropdown) {
                dropdown.classList.remove('show');
                document.removeEventListener('click', closeAccountDetailTimeRangeOutside);
            }
            
            // Update active state in dropdown
            const dropdownItems = document.querySelectorAll('#accountDetailTimeRangeDropdown .dropdown-item');
            dropdownItems.forEach(item => item.classList.remove('active'));
            if (event && event.currentTarget) {
                event.currentTarget.classList.add('active');
            }
            
            // Update subtitle
            const subtitle = document.getElementById('accountDetailActivitySubtitle');
            if (subtitle && event && event.currentTarget) {
                subtitle.textContent = event.currentTarget.textContent;
            }
            
            // Update stored range and refresh data
            window.currentAccountDetail.timeRange = rangeType;
            updateAccountDetailChart();
            updateAccountDetailTransactions();
        }

        function updateAccountDetailTransactions() {
            if (!window.currentAccountDetail) return;

            const accountId = window.currentAccountDetail.id;
            const timeRange = window.currentAccountDetail.timeRange;
            
            // Get transactions for this account
            const transactions = getAccountTransactions(accountId, timeRange);
            
            // Render transaction list
            renderAccountDetailTransactions(transactions);
        }

        function getAccountTransactions(accountId, timeRange) {
            // Load real expense data from localStorage
            const expenses = loadExpenses();
            let transactions = [];

            // Convert expenses to transaction format
            Object.keys(expenses).forEach(dateKey => {
                const dayExpenses = expenses[dateKey] || [];
                dayExpenses.forEach(expense => {
                    // Include all transactions as they represent account activity
                    transactions.push({
                        date: dateKey,
                        description: expense.description || getCategoryDisplayName(expense.category),
                        amount: -expense.amount, // Expenses are negative transactions
                        type: 'debit',
                        category: expense.category
                    });
                });
            });

            // Add sample income transactions if no real data exists or to make data more realistic
            if (transactions.length === 0) {
                transactions = generateSampleTransactions(accountId);
            } else {
                // Add periodic income transactions to make data more realistic
                transactions = [...transactions, ...generateIncomeTransactions()];
            }

            // Filter by time range
            const today = new Date();
            let cutoffDate = new Date();
            
            switch (timeRange) {
                case 'week': cutoffDate.setDate(today.getDate() - 7); break;
                case 'month': cutoffDate.setMonth(today.getMonth() - 1); break;
                case 'quarter': cutoffDate.setMonth(today.getMonth() - 3); break;
                case 'year': cutoffDate.setFullYear(today.getFullYear() - 1); break;
                case 'all': cutoffDate = new Date('2000-01-01'); break;
            }

            return transactions
                .filter(transaction => new Date(transaction.date) >= cutoffDate)
                .sort((a, b) => new Date(b.date) - new Date(a.date)); // Sort by date descending
        }

        function generateSampleTransactions(accountId) {
            // Return sample transactions for demo purposes
            return [
                {
                    date: '2025-07-29',
                    description: 'Direct Deposit - Salary',
                    amount: 2500.00,
                    type: 'credit'
                },
                {
                    date: '2025-07-28',
                    description: 'Grocery Store Purchase',
                    amount: -89.32,
                    type: 'debit'
                },
                {
                    date: '2025-07-27',
                    description: 'Online Transfer',
                    amount: -200.00,
                    type: 'debit'
                },
                {
                    date: '2025-07-26',
                    description: 'ATM Withdrawal',
                    amount: -60.00,
                    type: 'debit'
                }
            ];
        }

        function getCategoryDisplayName(category) {
            const categoryMap = {
                'groceries': 'Groceries',
                'transportation': 'Transportation', 
                'dining': 'Dining Out',
                'entertainment': 'Entertainment',
                'personal': 'Personal Care',
                'clothing': 'Clothing',
                'utilities': 'Utilities',
                'healthcare': 'Healthcare',
                'subscription': 'Subscriptions',
                'rent': 'Rent/Mortgage',
                'other': 'Other'
            };
            return categoryMap[category] || 'Other Expense';
        }

        function generateIncomeTransactions() {
            // Add some realistic income transactions
            const incomeTransactions = [];
            const today = new Date();
            
            // Add salary deposit for last month
            const lastMonth = new Date(today);
            lastMonth.setMonth(lastMonth.getMonth() - 1);
            lastMonth.setDate(1); // First of last month
            
            incomeTransactions.push({
                date: lastMonth.toISOString().split('T')[0],
                description: 'Direct Deposit - Salary',
                amount: 4200.00,
                type: 'credit'
            });
            
            // Add this month's salary if we're past the 1st
            if (today.getDate() > 1) {
                const thisMonth = new Date(today);
                thisMonth.setDate(1);
                
                incomeTransactions.push({
                    date: thisMonth.toISOString().split('T')[0],
                    description: 'Direct Deposit - Salary',
                    amount: 4200.00,
                    type: 'credit'
                });
            }
            
            return incomeTransactions;
        }

        function renderAccountDetailTransactions(transactions) {
            const container = document.getElementById('accountDetailTransactionsList');
            
            if (!transactions || transactions.length === 0) {
                container.innerHTML = `
                    <div style="text-align: center; color: #7f8c8d; padding: 20px;">
                        No transactions found for this period
                    </div>
                `;
                return;
            }

            const transactionsHtml = transactions.map(transaction => {
                const isCredit = transaction.amount > 0;
                const amountClass = isCredit ? 'credit' : 'debit';
                const amountText = isCredit ? `+${formatCurrency(transaction.amount)}` : formatCurrency(transaction.amount);
                
                return `
                    <div class="expense-item">
                        <div class="expense-date">${formatDate(transaction.date)}</div>
                        <div class="expense-details">
                            <div class="expense-description">${transaction.description}</div>
                        </div>
                        <div class="expense-amount ${amountClass}">${amountText}</div>
                    </div>
                `;
            }).join('');

            container.innerHTML = transactionsHtml;
        }

        function initAccountDetailSwipe() {
            const screen = document.getElementById('accountDetailScreen');
            const overlay = document.getElementById('accountDetailOverlay');
            let startX = 0;
            let startY = 0;
            let currentX = 0;
            let isDragging = false;
            let isHorizontalSwipe = false;

            function handleTouchStart(e) {
                startX = e.touches[0].clientX;
                startY = e.touches[0].clientY;
                currentX = startX;
                isDragging = true;
                isHorizontalSwipe = false;
                
                // Disable CSS transitions during drag
                screen.style.transition = 'none';
                overlay.style.transition = 'none';
            }

            function handleTouchMove(e) {
                if (!isDragging) return;
                
                currentX = e.touches[0].clientX;
                const currentY = e.touches[0].clientY;
                const deltaX = currentX - startX;
                const deltaY = currentY - startY;
                
                // Determine if this is a horizontal swipe
                if (!isHorizontalSwipe && (Math.abs(deltaX) > 10 || Math.abs(deltaY) > 10)) {
                    isHorizontalSwipe = Math.abs(deltaX) > Math.abs(deltaY);
                    
                    if (isHorizontalSwipe) {
                        // Prevent vertical scrolling during horizontal swipe
                        screen.style.touchAction = 'pan-x';
                        e.preventDefault();
                    } else {
                        // Allow vertical scrolling for non-horizontal gestures
                        screen.style.touchAction = 'pan-y';
                        isDragging = false;
                        return;
                    }
                }
                
                // Only allow rightward swipes (closing gesture) and only if horizontal
                if (isHorizontalSwipe && deltaX > 0) {
                    e.preventDefault(); // Prevent vertical scroll
                    const transform = Math.min(deltaX, screen.offsetWidth);
                    screen.style.transform = `translateX(${transform}px)`;
                }
            }

            function handleTouchEnd(e) {
                if (!isDragging) return;
                
                isDragging = false;
                isHorizontalSwipe = false;
                const deltaX = currentX - startX;
                
                // Restore normal touch behavior
                screen.style.touchAction = '';
                
                // If swiped more than 1/3 of the screen width, close
                if (deltaX > screen.offsetWidth / 3) {
                    // Close immediately without snap back
                    closeAccountDetail();
                } else if (deltaX > 0) {
                    // Snap back to original position with snappier transition
                    screen.style.transition = 'transform 0.2s cubic-bezier(0.4, 0.0, 0.2, 1)';
                    screen.style.transform = 'translateX(0)';
                    
                    // Clean up after animation
                    setTimeout(() => {
                        screen.style.transition = '';
                        screen.style.transform = '';
                    }, 200);
                } else {
                    // No drag happened, just clean up
                    screen.style.transition = '';
                    screen.style.transform = '';
                }
            }

            // Add touch event listeners
            screen.addEventListener('touchstart', handleTouchStart, { passive: true });
            screen.addEventListener('touchmove', handleTouchMove, { passive: false });
            screen.addEventListener('touchend', handleTouchEnd, { passive: true });
        }

        function formatDate(dateString) {
            const date = new Date(dateString);
            const today = new Date();
            const yesterday = new Date(today);
            yesterday.setDate(yesterday.getDate() - 1);
            
            if (date.toDateString() === today.toDateString()) {
                return 'Today';
            } else if (date.toDateString() === yesterday.toDateString()) {
                return 'Yesterday';
            } else {
                return date.toLocaleDateString('en-US', { 
                    month: 'short', 
                    day: 'numeric' 
                });
            }
        }

        async function updateSaveBalanceHistory() {
            // Use new accounts layout instead of old balance history
            updateAccountSummary();
            await renderNewAccountsLayout();
            return;
            
            // Group balance records by account for the selected month
            const selectedMonthKey = getSelectedSaveMonthKey();
            const previousMonth = new Date(selectedSaveMonthDate);
            previousMonth.setMonth(previousMonth.getMonth() - 1);
            const previousMonthKey = `${previousMonth.getFullYear()}-${String(previousMonth.getMonth() + 1).padStart(2, '0')}`;

            // Ensure savingsAccounts is initialized
            if (!savingsAccounts || savingsAccounts.length === 0) {
                const savedAccounts = localStorage.getItem('savingsAccounts');
                if (savedAccounts) {
                    savingsAccounts = JSON.parse(savedAccounts);
                }
            }
            
            // Group accounts by type
            const accountTypes = {
                'cash': { title: 'Cash Accounts', accounts: [] },
                'investment': { title: 'Investments', accounts: [] },
                'liability': { title: 'Debt', accounts: [] },
                'other': { title: 'Other Accounts', accounts: [] }
            };
            
            console.log('savingsAccounts:', savingsAccounts);
            console.log('balances:', balances);

            // Prepare grouped data
            const grouped = {};
            savingsAccounts.forEach(account => {
                // Determine account type - default to 'other' if not specified
                const accountType = account.type || 'other';
                
                const accountBalances = balances[account.id] || {};
                // Get all updates for the selected month, sort by date (chronologically, not alphabetically)
                const monthUpdates = Object.keys(accountBalances)
                    .filter(date => date.startsWith(selectedMonthKey))
                    .map(date => {
                        const entry = accountBalances[date];
                        return {
                            date,
                            amount: entry.amount !== undefined ? entry.amount : entry,
                            created: entry.created || new Date(date).getTime(),
                            updated: entry.updated || entry.created || new Date(date).getTime()
                        };
                    })
                    .sort((a, b) => {
                        // Sort by date (most recent first)
                        return new Date(b.date) - new Date(a.date);
                    });
                // Get last value from previous month
                const prevMonthDates = Object.keys(accountBalances)
                    .filter(date => date.startsWith(previousMonthKey))
                    .sort();
                const prevMonthLastDate = prevMonthDates.length > 0 ? prevMonthDates[prevMonthDates.length - 1] : null;
                const prevMonthLastValue = prevMonthLastDate ? (accountBalances[prevMonthLastDate].amount !== undefined ? accountBalances[prevMonthLastDate].amount : accountBalances[prevMonthLastDate]) : 0;
                
                grouped[account.id] = {
                    name: account.name,
                    type: accountType,
                    monthUpdates,
                    prevMonthLastValue
                };
                
                // Only add to type group if it has updates this month
                if (monthUpdates.length > 0) {
                    // Add to the appropriate type group
                    if (accountTypes[accountType]) {
                        accountTypes[accountType].accounts.push(account.id);
                    } else {
                        accountTypes.other.accounts.push(account.id);
                    }
                }
            });

            // Render account sections by type
            let html = '';
            let anyData = false;
            
            // Process each account type section
            Object.keys(accountTypes).forEach(type => {
                const { title, accounts } = accountTypes[type];
                
                // Skip types with no accounts
                if (accounts.length === 0) return;
                
                anyData = true;
                // Create section header outside the card
                html += `
                <h2 class="account-section-header">${title}</h2>
                <div class="account-type-section">
                `;
                
                // Add accounts for this section
                accounts.forEach(accountId => {
                    const { name, monthUpdates, type: accountType } = grouped[accountId];
                    if (monthUpdates.length === 0) return; // Only show accounts with data
                    
                    // Latest value for the selected month (should be first in the array since we sorted by date descending)
                    const latest = monthUpdates[0];
                    console.log(`Latest balance for ${name} (${accountId}): ${formatCurrency(latest.amount)} on ${latest.date}`);
                    
                    // Calculate all-time percent (from first ever value)
                    const accountBalances = balances[accountId] || {};
                    const allDates = Object.keys(accountBalances).sort(); // Sort chronologically
                    const firstValue = allDates.length > 0 ? 
                        (accountBalances[allDates[0]].amount !== undefined ? 
                            accountBalances[allDates[0]].amount : accountBalances[allDates[0]]) : 0;
                    const allTimePercent = firstValue && latest.amount ? ((latest.amount - firstValue) / firstValue) * 100 : 0;
                    
                    // Check if this is a debt account
                    const isDebt = accountType === 'liability';
                    const debtClass = isDebt ? ' debt' : '';
                    const formatAmount = (amount) => isDebt ? `(${formatCurrency(amount)})` : formatCurrency(amount);
                    console.log(`Account ${name} - Type: ${accountType}, IsDebt: ${isDebt}, Class: '${debtClass}'`);
                // Account header: account name, latest value
                html += `<div class="modern-account-accordion" data-account-id="${accountId}">
                    <div class="modern-account-accordion-header" onclick="toggleAccountAccordion('${accountId}')">
                        <div class="modern-account-header-left">
                            <div class="modern-account-title">${name}</div>
                        </div>
                        <div class="modern-account-header-right">
                            <div class="modern-account-balance${debtClass}">${formatAmount(latest.amount)}</div>
                            <div class="modern-account-change ${allTimePercent >= 0 ? 'positive' : 'negative'}">
                                <i data-lucide="${allTimePercent >= 0 ? 'trending-up' : 'trending-down'}" class="change-arrow"></i>
                                ${Math.abs(allTimePercent).toFixed(1)}%
                            </div>
                        </div>
                        <div class="account-chevron"><i data-lucide="chevron-down" class="modern-account-chevron" id="chevron-${accountId}"></i></div>
                    </div>
                    <div class="modern-account-accordion-body" id="accordion-body-${accountId}">
                        <div class="modern-account-updates">
                `;
                // Sort updates by date in descending order (newest first)
                const sortedUpdates = [...monthUpdates].sort((a, b) => {
                    return new Date(b.date) - new Date(a.date);
                });
                
                // Process updates in chronological order for display
                let prevValue = null;
                let prevDate = null;
                
                // First pass to determine previous values
                const updatesWithPercents = sortedUpdates.map((update, index) => {
                    // Calculate percent change from previous value (next in array)
                    let percent = null;
                    let arrow = '';
                    
                    // If we have a next item (which is the previous date's value)
                    const nextItem = sortedUpdates[index + 1];
                    if (nextItem) {
                        const previousAmount = nextItem.amount;
                        if (previousAmount !== null && previousAmount !== 0) {
                            percent = ((update.amount - previousAmount) / Math.abs(previousAmount)) * 100;
                            if (percent > 0.01) {
                                arrow = '<i data-lucide="arrow-up-right" class="balance-arrow positive"></i>';
                            } else if (percent < -0.01) {
                                arrow = '<i data-lucide="arrow-down-right" class="balance-arrow negative"></i>';
                            } else {
                                arrow = '<i data-lucide="arrow-right" class="balance-arrow neutral"></i>';
                            }
                        }
                    }
                    
                    const percentClass = percent > 0 ? 'positive' : percent < 0 ? 'negative' : 'neutral';
                    
                    const [year, month, day] = update.date.split('-').map(Number);
                    const dateObj = new Date(year, month - 1, day);
                    const displayDate = dateObj.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
                    
                    return {
                        ...update,
                        displayDate,
                        percent,
                        percentClass,
                        arrow
                    };
                });
                
                // Render updates
                updatesWithPercents.forEach(update => {
                    html += `<div class="swipe-container" data-type="balance" data-account-id="${accountId}" data-date="${update.date}">
                        <div class="swipe-content">
                            <div class="modern-account-update-row">
                                <div class="modern-update-date">${update.displayDate}</div>
                                <div class="modern-update-amount-stack">
                                <div class="modern-update-diff${debtClass}">${formatAmount(update.amount)}</div>
                                <div class="modern-update-percent ${update.percentClass}">${update.percent !== null ? `${update.arrow}${update.percent >= 0 ? '+' : ''}${update.percent.toFixed(2)}%` : '--'}</div>
                                </div>
                            </div>
                        </div>
                        <div class="swipe-action" onclick="handleBalanceDelete(this); event.stopPropagation(); return false;"><i data-lucide="x" class="w-4 h-4"></i></div>
                    </div>`;
                });
                
                html += `</div></div></div>`; // Close modern-account-updates, modern-account-accordion-body, modern-account-accordion
                });
                
                html += `</div>`; // Close account-type-section
            });
            if (!anyData) {
                const selectedMonthName = selectedSaveMonthDate.toLocaleDateString('en-US', { month: 'long', year: 'numeric' });
                html = `<div style="text-align: center; color: #7f8c8d; padding: 20px;">No balance records for ${selectedMonthName}</div>`;
            }
            historyContainer.innerHTML = html;
            // Ensure Lucide icons are rendered
            if (window.lucide && typeof window.lucide.createIcons === 'function') {
                window.lucide.createIcons();
            }
        }

        // Accordion toggle function
        function toggleAccountAccordion(accountId) {
            const body = document.getElementById(`accordion-body-${accountId}`);
            const chevron = document.getElementById(`chevron-${accountId}`);
            const accordion = document.querySelector(`.modern-account-accordion[data-account-id='${accountId}']`);
            const header = document.querySelector(`.modern-account-accordion[data-account-id='${accountId}'] .modern-account-accordion-header`);
            // Remove any inline styles that might have been set
            if (body) {
                body.style.display = '';
                body.style.maxHeight = '';
                body.style.opacity = '';
            }
            if(accordion) {
                accordion.classList.toggle('expanded');
            }
            if (body.classList.contains('expanded')) {
                body.classList.remove('expanded');
                if (header) header.classList.remove('expanded');
            } else {
                body.classList.add('expanded');
                if (header) header.classList.add('expanded');
            }
        }

        // Account type section toggle function
        function toggleAccountTypeSection(typeKey) {
            const section = document.querySelector(`.account-type-section[onclick*="${typeKey}"]`);
            const body = document.getElementById(`type-body-${typeKey}`);
            const chevron = document.getElementById(`type-chevron-${typeKey}`);
            
            if (section && body) {
                // Toggle collapsed class on section
                section.classList.toggle('collapsed');
                
                // Toggle chevron rotation
                if (chevron) {
                    chevron.style.transform = section.classList.contains('collapsed') ? 'rotate(0deg)' : 'rotate(180deg)';
                }
                
                // Add expanded class for border styling when not collapsed
                if (section.classList.contains('collapsed')) {
                    section.classList.remove('expanded');
                } else {
                    section.classList.add('expanded');
                }
            }
        }

        // Get all available dates from balance data
        function getAllAvailableDates(balances) {
            const allDates = new Set();
            
            Object.keys(balances).forEach(accountId => {
                const accountBalances = balances[accountId] || {};
                Object.keys(accountBalances).forEach(date => {
                    allDates.add(date);
                });
            });
            
            return Array.from(allDates).sort();
        }

        // Get the last balance for a specific account
        function getLastBalanceForAccount(accountId) {
            const balances = loadAccountBalances();
            const accountBalances = balances[accountId] || {};
            
            if (Object.keys(accountBalances).length === 0) {
                return { amount: 0 }; // No balance records for this account
            }
            
            // Get all dates for this account and sort them chronologically (newest first)
            const dates = Object.keys(accountBalances).sort((a, b) => {
                // Sort dates in descending order (newest first)
                return new Date(b) - new Date(a);
            });
            
            // Get the latest balance (first in the sorted array)
            const lastBalance = accountBalances[dates[0]];
            
            // Log for debugging
            console.log(`Latest balance for account ${accountId}: ${JSON.stringify(lastBalance)} on date ${dates[0]}`);
            
            // Handle both old format (direct number) and new format (object with amount)
            if (lastBalance === null || lastBalance === undefined) {
                return { amount: 0 };
            } else if (typeof lastBalance === 'object') {
                return lastBalance;
            } else {
                return { amount: lastBalance };
            }
        }


        function generateAccountTypeChart() {
            const accountTypeChart = document.getElementById('accountTypeChart');
            if (!accountTypeChart) return;
            
            // Group accounts by type and calculate totals
            const accountTypes = {
                'cash': { total: 0, icon: 'dollar-sign', label: 'Cash' },
                'investment': { total: 0, icon: 'trending-up', label: 'Investments' },
                'liability': { total: 0, icon: 'credit-card', label: 'Debt' }
            };

            // Aggregate balances from all accounts including Plaid
            savingsAccounts.forEach(account => {
                const accountType = account.type === 'plaid' ? (account.subtype === 'credit card' ? 'liability' : account.subtype === 'investment' ? 'investment' : 'cash') : (account.type || 'cash');
                
                // Use API balance for Plaid accounts, otherwise use local balance
                let balance;
                if (account.type === 'plaid' && account.currentBalance !== undefined) {
                    balance = account.currentBalance;
                } else {
                    const currentBalance = getLastBalanceForAccount(account.id);
                    balance = currentBalance ? currentBalance.amount : 0;
                }
                
                if (accountTypes[accountType]) {
                    // For liability accounts, use absolute value since debt should show as positive amounts in the chart
                    // but we'll display them with brackets in the UI
                    accountTypes[accountType].total += Math.abs(balance);
                }
            });

            // Convert to array format for the chart, filtering out zero amounts
            const accountData = Object.entries(accountTypes)
                .filter(([type, data]) => data.total > 0)
                .map(([type, data]) => ({
                    type: type,
                    label: data.label,
                    amount: data.total,
                    icon: data.icon
                }));
            
            // Calculate total for percentage
            const totalValue = accountData.reduce((sum, account) => sum + account.amount, 0);
            
            // If no accounts with balances, show placeholder
            if (accountData.length === 0 || totalValue === 0) {
                accountTypeChart.innerHTML = `
                    <div class="card-content">
                        <div style="text-align: center; color: #7f8c8d; padding: 1rem;">
                            <i data-lucide="info" class="w-4 h-4" style="margin-bottom: 0.5rem;"></i>
                            <div>Add accounts or update balances to see chart</div>
                        </div>
                    </div>
                `;
                accountTypeChart.classList.add('home-section');
                
                // Ensure Lucide icons are rendered
                setTimeout(() => {
                    if (window.lucide && typeof window.lucide.createIcons === 'function') {
                        window.lucide.createIcons();
                    }
                }, 50);
                return;
            }
            
            // Clear existing content and create new structure with home container
            accountTypeChart.innerHTML = `
                <div class="card-header">
                    <div class="home-section-header">
                        <div class="section-subtitle">Investment, cash & debt</div>
                    </div>
                </div>
                <div class="card-content">
                    <div class="account-type-horizontal" id="accountTypeHorizontal">
                        <!-- Account bars will be generated here -->
                    </div>
                </div>
            `;
            
            // Add the home-section class to the chart container
            accountTypeChart.classList.add('home-section');
            
            const container = document.getElementById('accountTypeHorizontal');
            
            accountData.forEach((account, index) => {
                const percentage = (account.amount / totalValue) * 100;
                const displayAmount = account.type === 'liability' ? -account.amount : account.amount;
                
                const barItem = document.createElement('div');
                barItem.className = 'account-type-bar';
                
                barItem.innerHTML = `
                    <div class="account-type-header">
                        <div class="account-type-left">
                            <div class="account-type-icon">
                                <i data-lucide="${account.icon}" class="w-4 h-4"></i>
                            </div>
                            <div class="account-type-label">${account.label}</div>
                        </div>
                        <div class="account-type-amount">$${formatAccountTypeAmount(displayAmount)}</div>
                    </div>
                    <div class="account-type-bar-container">
                        <div class="account-type-bar-visual ${account.type}" style="width: ${percentage}%">
                            <div class="account-type-percentage">${Math.round(percentage)}%</div>
                        </div>
                    </div>
                `;
                
                // Apply staggered fade animation
                barItem.style.opacity = '0';
                setTimeout(() => {
                    barItem.classList.add('chart-bar-stagger-in');
                    setTimeout(() => {
                        barItem.classList.remove('chart-bar-stagger-in');
                        barItem.style.opacity = '';
                    }, 300);
                }, index * 100); // 100ms delay between each bar
                
                container.appendChild(barItem);
            });
            
            // Ensure Lucide icons are rendered
            setTimeout(() => {
                if (window.lucide && typeof window.lucide.createIcons === 'function') {
                    window.lucide.createIcons();
                }
            }, 50);
        }

        function formatAccountTypeAmount(amount) {
            const absAmount = Math.abs(amount);
            const formattedAmount = absAmount.toLocaleString('en-US', {
                minimumFractionDigits: 2,
                maximumFractionDigits: 2
            });
            
            // Show negative amounts in brackets
            return amount < 0 ? `(${formattedAmount})` : formattedAmount;
        }

        function updateAccountsView() {
            // Generate the account type chart
            generateAccountTypeChart();
            
        }

        // Function to get the default account ID
        function getDefaultAccountId() {
            // If there are savings accounts, use the first one as default
            if (savingsAccounts && savingsAccounts.length > 0) {
                return savingsAccounts[0].id;
            }
            
            // If no accounts exist, return null
            return null;
        }

        // Update save screen display
        async function updateSaveScreen() {
            renderSaveTitle();
            updateSaveTargetDisplay();
            await updateSaveTotalSavingsDisplay();
            updateAccountsView();
            updateAccountsNetWorth(); // Initialize accounts networth chart
        }

        /**
         * Renders the save screen title area with month/year selector.
         * Shows a large, centered, clickable month/year with chevron.
         */
        function renderSaveTitle() {
            const container = document.getElementById('saveTargetTitleContainer');
            if (!container) return;
            container.innerHTML = '';
            
            // Create month/year selector button
            const btn = document.createElement('button');
            btn.id = 'saveMonthYearSelectorBtn';
            btn.onclick = showSaveMonthYearSlideOut;
            btn.style.background = 'none';
            btn.style.border = 'none';
            btn.style.borderRadius = '14px';
            btn.style.display = 'inline-flex';
            btn.style.alignItems = 'center';
            btn.style.justifyContent = 'flex-start';
            btn.style.fontSize = '1.5rem';
            btn.style.fontWeight = '700';
            btn.style.color = 'inherit';
            btn.style.cursor = 'pointer';
            btn.style.padding = '0';
            btn.style.outline = 'none';
            btn.style.width = 'auto';
            
            // Month/year text
            const span = document.createElement('span');
            span.id = 'saveMonthYearSelectorText';
            span.textContent = getMonthYearString(selectedSaveMonthDate);
            
            // Lucide chevron icon
            const icon = document.createElement('i');
            icon.setAttribute('data-lucide', 'chevron-down');
            icon.className = 'w-7 h-7';
            icon.style.marginLeft = '0.5rem';
            icon.style.color = 'hsl(var(--muted-foreground))';
            
            btn.appendChild(span);
            btn.appendChild(icon);
            container.appendChild(btn);
            
            // Ensure Lucide icons are rendered
            if (window.lucide && typeof window.lucide.createIcons === 'function') {
                window.lucide.createIcons();
            } else {
                setTimeout(() => {
                    if (window.lucide && typeof window.lucide.createIcons === 'function') {
                        window.lucide.createIcons();
                    }
                }, 100);
            }
        }

        /**
         * Shows the save month/year selection slide-out
         */
        function showSaveMonthYearSlideOut() {
            showMonthYearSlideOut();
        }

        /**
         * Updates the save month/year selector text
         */
        function updateSaveMonthYearSelector() {
            const btnText = document.getElementById('saveMonthYearSelectorText');
            if (btnText) {
                btnText.textContent = getMonthYearString(selectedSaveMonthDate);
            }
        }

        // Set save period mode (today/month)
        function setSavePeriodMode(mode) {
            currentSavePeriodMode = mode;
            
            // Update compact button states
            const saveTodayBtn = document.getElementById('saveTodayBtnCompact');
            const saveMonthBtn = document.getElementById('saveMonthBtnCompact');
            if (saveTodayBtn) saveTodayBtn.classList.toggle('active', mode === 'today');
            if (saveMonthBtn) saveMonthBtn.classList.toggle('active', mode === 'month');
            
            // Update icon-only button states
            const saveTodayBtnIcon = document.getElementById('saveTodayBtnIcon');
            const saveMonthBtnIcon = document.getElementById('saveMonthBtnIcon');
            if (saveTodayBtnIcon) saveTodayBtnIcon.classList.toggle('active', mode === 'today');
            if (saveMonthBtnIcon) saveMonthBtnIcon.classList.toggle('active', mode === 'month');
            
            // Update save screen display
            updateSaveScreen();
        }

        /**
         * Initialize click-outside-to-close functionality for all slide-out menus
         * This function sets up event listeners on the overlay backgrounds to close menus when clicked
         */
        function initializeSlideOutClickOutside() {
            // Get all slide-out overlays
            const slideOutOverlays = document.querySelectorAll('.slide-out-overlay, .account-management-slide-out');
            
            slideOutOverlays.forEach(overlay => {
                overlay.addEventListener('click', function(event) {
                    // Check if the click was on the overlay background (not on the content)
                    if (event.target === overlay) {
                        // Close the specific slide-out based on its ID
                        const slideOutId = overlay.id;
                        switch (slideOutId) {
                            case 'expenseSlideOut':
                                hideExpenseSlideOut();
                                break;
                            case 'balanceSlideOut':
                                hideBalanceSlideOut();
                                break;
                            case 'monthYearSlideOut':
                                hideMonthYearSlideOut();
                                break;
                            case 'accountManagementSlideOut':
                                hideAccountManagementSlideOut();
                                break;
                            default:
                                // Generic fallback - remove active class
                                overlay.classList.remove('active');
                                break;
                        }
                    }
                });
            });
        }

        /**
         * Updates the header title based on the current screen.
         */
        function updateHeaderTitle() {
            const headerTitle = document.getElementById('headerTitle');
            const settingsButton = document.getElementById('settingsButton');
            
            if (!headerTitle) return;
            
            switch (currentScreen) {
                case 0:
                    headerTitle.textContent = 'Home';
                    settingsButton.style.display = 'block';
                    break;
                case 1:
                    headerTitle.textContent = 'Spending';
                    settingsButton.style.display = 'block';
                    break;
                case 2:
                    headerTitle.textContent = 'Accounts';
                    settingsButton.style.display = 'block';
                    break;
                case 3:
                    headerTitle.textContent = 'Dashboard';
                    settingsButton.style.display = 'block';
                    break;
                default:
                    headerTitle.textContent = '';
                    settingsButton.style.display = 'block';
            }
        }


        document.addEventListener('DOMContentLoaded', function() {
            updateHeaderTitle();
        });

        // Settings Slide-out Functions
        function openSettings() {
            const overlay = document.getElementById('settingsOverlay');
            const panel = document.getElementById('settingsPanel');
            const appContainer = document.querySelector('.app-container');
            
            // Load settings data
            loadSettings();
            
            // Show overlay and panel
            overlay.classList.add('active');
            panel.classList.add('active');
            
            // Add slide transition to main content
            appContainer.classList.add('settings-open');
            
            // Hide bottom navigation
            document.querySelector('.bottom-nav').style.display = 'none';
        }

        function closeSettings() {
            const overlay = document.getElementById('settingsOverlay');
            const panel = document.getElementById('settingsPanel');
            const appContainer = document.querySelector('.app-container');
            
            // Hide overlay and panel
            overlay.classList.remove('active');
            panel.classList.remove('active');
            
            // Remove slide transition from main content
            appContainer.classList.remove('settings-open');
            
            // Show bottom navigation
            document.querySelector('.bottom-nav').style.display = 'flex';
        }

        // Close settings when clicking overlay
        document.addEventListener('DOMContentLoaded', function() {
            const overlay = document.getElementById('settingsOverlay');
            overlay.addEventListener('click', function(e) {
                if (e.target === overlay) {
                    closeSettings();
                }
            });
            
            // Close budget setup when clicking overlay
            const budgetOverlay = document.getElementById('budgetOverlay');
            budgetOverlay.addEventListener('click', function(e) {
                if (e.target === budgetOverlay) {
                    closeBudgetSetup();
                }
            });
        });

        // Settings Functions
        function loadSettings() {
            // Budget settings are now loaded in the budget slide-out
            // No need to load them here since the settings slide-out no longer contains budget forms
        }

        function updateSimpleBudgetSummary() {
            // Get values from inputs
            const grossIncome = parseFloat(document.getElementById('grossIncome').value) || 0;
            const federalTax = parseFloat(document.getElementById('federalTax').value) || 0;
            const provincialTax = parseFloat(document.getElementById('provincialTax').value) || 0;
            const cppEi = parseFloat(document.getElementById('cppEi').value) || 0;
            let netIncome = parseFloat(document.getElementById('netIncome').value) || 0;
            const annualSavingsGoal = parseFloat(document.getElementById('annualSavingsGoal').value) || 0;
            let monthlySavingsTarget = parseFloat(document.getElementById('monthlySavingsTarget').value) || 0;
            const fixedExpenses = parseFloat(document.getElementById('fixedExpenses').value) || 0;
            const essentialExpenses = parseFloat(document.getElementById('essentialExpenses').value) || 0;
            const discretionaryExpenses = parseFloat(document.getElementById('discretionaryExpenses').value) || 0;

            // Auto-calculate net income if not manually overridden
            const calculatedNet = grossIncome - federalTax - provincialTax - cppEi;
            if (!document.getElementById('netIncome').dataset.manual) {
                document.getElementById('netIncome').value = calculatedNet > 0 ? calculatedNet.toFixed(2) : '';
                netIncome = calculatedNet;
            }

            // Auto-calculate monthly savings target (now always calculated from annual goal)
            const calculatedMonthlySavings = annualSavingsGoal / 12;
            document.getElementById('monthlySavingsTarget').value = calculatedMonthlySavings > 0 ? calculatedMonthlySavings.toFixed(2) : '';
            monthlySavingsTarget = calculatedMonthlySavings;

            // Calculate remaining budget
            const totalExpenses = fixedExpenses + essentialExpenses + discretionaryExpenses;
            const remainingBudget = netIncome - monthlySavingsTarget - totalExpenses;
            document.getElementById('remainingBudgetSummary').textContent = '$' + remainingBudget.toLocaleString('en-US', {minimumFractionDigits: 2, maximumFractionDigits: 2});

            // Calculate savings rate
            const savingsRate = netIncome > 0 ? (monthlySavingsTarget / netIncome) * 100 : 0;
            document.getElementById('savingsRateSummary').textContent = savingsRate.toFixed(1) + '%';

            // Validation
            let validation = '-';
            if (remainingBudget >= -10 && remainingBudget <= 10) {
                validation = ' Tight but feasible';
            } else if (remainingBudget > 10) {
                validation = ' Feasible';
            } else {
                validation = 'Over budget';
            }
            document.getElementById('budgetValidationSummary').textContent = validation;
        }

        function loadSimpleBudgetSettings() {
            const savedSettings = localStorage.getItem('simpleBudgetSettings');
            if (savedSettings) {
                const settings = JSON.parse(savedSettings);
                
                // Populate form fields with saved values
                document.getElementById('grossIncome').value = settings.grossIncome || '';
                document.getElementById('federalTax').value = settings.federalTax || '';
                document.getElementById('provincialTax').value = settings.provincialTax || '';
                document.getElementById('cppEi').value = settings.cppEi || '';
                document.getElementById('netIncome').value = settings.netIncome || '';
                document.getElementById('annualSavingsGoal').value = settings.annualSavingsGoal || '';
                document.getElementById('monthlySavingsTarget').value = settings.monthlySavingsTarget || '';
                document.getElementById('fixedExpenses').value = settings.fixedExpenses || '';
                document.getElementById('essentialExpenses').value = settings.essentialExpenses || '';
                document.getElementById('discretionaryExpenses').value = settings.discretionaryExpenses || '';
            } else {
                // Set default values based on your budget breakdown
                document.getElementById('grossIncome').value = '11667';
                document.getElementById('federalTax').value = '2500';
                document.getElementById('provincialTax').value = '750';
                document.getElementById('cppEi').value = '333';
                document.getElementById('netIncome').value = '8084';
                document.getElementById('annualSavingsGoal').value = '52000';
                document.getElementById('monthlySavingsTarget').value = '4333';
                document.getElementById('fixedExpenses').value = '2450';
                document.getElementById('essentialExpenses').value = '750';
                document.getElementById('discretionaryExpenses').value = '501';
            }
        }

        function saveSimpleBudgetSettings() {
            const settings = {
                grossIncome: parseFloat(document.getElementById('grossIncome').value) || 0,
                federalTax: parseFloat(document.getElementById('federalTax').value) || 0,
                provincialTax: parseFloat(document.getElementById('provincialTax').value) || 0,
                cppEi: parseFloat(document.getElementById('cppEi').value) || 0,
                netIncome: parseFloat(document.getElementById('netIncome').value) || 0,
                annualSavingsGoal: parseFloat(document.getElementById('annualSavingsGoal').value) || 0,
                monthlySavingsTarget: parseFloat(document.getElementById('monthlySavingsTarget').value) || 0,
                fixedExpenses: parseFloat(document.getElementById('fixedExpenses').value) || 0,
                essentialExpenses: parseFloat(document.getElementById('essentialExpenses').value) || 0,
                discretionaryExpenses: parseFloat(document.getElementById('discretionaryExpenses').value) || 0
            };
            
            console.log('Saving settings:', settings);
            localStorage.setItem('simpleBudgetSettings', JSON.stringify(settings));
            
            // Update all displays to reflect new settings
            updatePeriodView();
            updateReports();
            updateSaveScreen();
            
            // Update chart if on reports screen
            if (currentScreen === 2) {
                setTimeout(updateChart, 100);
            }
            
            alert('Settings saved! All budgets and targets have been updated.');
            closeSettings();
        }

        // Tax Calculator Functions
        const TAX_BRACKETS_2024 = {
            federal: [
                { min: 0, max: 55967, rate: 0.15 },
                { min: 55967, max: 111733, rate: 0.205 },
                { min: 111733, max: 173205, rate: 0.26 },
                { min: 173205, max: 246752, rate: 0.29 },
                { min: 246752, max: Infinity, rate: 0.33 }
            ],
            provinces: {
                ON: [ // Ontario
                    { min: 0, max: 51446, rate: 0.0505 },
                    { min: 51446, max: 102894, rate: 0.0915 },
                    { min: 102894, max: 150000, rate: 0.1116 },
                    { min: 150000, max: 220000, rate: 0.1216 },
                    { min: 220000, max: Infinity, rate: 0.1316 }
                ],
                BC: [ // British Columbia
                    { min: 0, max: 45654, rate: 0.0506 },
                    { min: 45654, max: 91310, rate: 0.077 },
                    { min: 91310, max: 104835, rate: 0.105 },
                    { min: 104835, max: 127299, rate: 0.1229 },
                    { min: 127299, max: 172602, rate: 0.147 },
                    { min: 172602, max: 240716, rate: 0.168 },
                    { min: 240716, max: Infinity, rate: 0.205 }
                ],
                AB: [ // Alberta
                    { min: 0, max: 148269, rate: 0.10 },
                    { min: 148269, max: 177922, rate: 0.12 },
                    { min: 177922, max: 237230, rate: 0.13 },
                    { min: 237230, max: 355845, rate: 0.14 },
                    { min: 355845, max: Infinity, rate: 0.15 }
                ],
                SK: [ // Saskatchewan
                    { min: 0, max: 52057, rate: 0.105 },
                    { min: 52057, max: 148734, rate: 0.125 },
                    { min: 148734, max: Infinity, rate: 0.145 }
                ],
                MB: [ // Manitoba
                    { min: 0, max: 36842, rate: 0.108 },
                    { min: 36842, max: 79625, rate: 0.1275 },
                    { min: 79625, max: Infinity, rate: 0.174 }
                ],
                QC: [ // Quebec
                    { min: 0, max: 49275, rate: 0.14 },
                    { min: 49275, max: 98540, rate: 0.19 },
                    { min: 98540, max: 119910, rate: 0.24 },
                    { min: 119910, max: Infinity, rate: 0.2575 }
                ],
                NB: [ // New Brunswick
                    { min: 0, max: 47715, rate: 0.0968 },
                    { min: 47715, max: 95431, rate: 0.1482 },
                    { min: 95431, max: 176756, rate: 0.1652 },
                    { min: 176756, max: Infinity, rate: 0.195 }
                ],
                NS: [ // Nova Scotia
                    { min: 0, max: 29590, rate: 0.0879 },
                    { min: 29590, max: 59180, rate: 0.1495 },
                    { min: 59180, max: 93000, rate: 0.1667 },
                    { min: 93000, max: 150000, rate: 0.175 },
                    { min: 150000, max: Infinity, rate: 0.21 }
                ],
                PE: [ // Prince Edward Island
                    { min: 0, max: 31984, rate: 0.098 },
                    { min: 31984, max: 63969, rate: 0.138 },
                    { min: 63969, max: Infinity, rate: 0.167 }
                ],
                NL: [ // Newfoundland and Labrador
                    { min: 0, max: 43198, rate: 0.087 },
                    { min: 43198, max: 86395, rate: 0.145 },
                    { min: 86395, max: 154244, rate: 0.158 },
                    { min: 154244, max: 215943, rate: 0.173 },
                    { min: 215943, max: 275870, rate: 0.183 },
                    { min: 275870, max: 551739, rate: 0.198 },
                    { min: 551739, max: 1103478, rate: 0.208 },
                    { min: 1103478, max: Infinity, rate: 0.218 }
                ],
                NT: [ // Northwest Territories
                    { min: 0, max: 50877, rate: 0.059 },
                    { min: 50877, max: 101754, rate: 0.086 },
                    { min: 101754, max: 165429, rate: 0.122 },
                    { min: 165429, max: Infinity, rate: 0.1405 }
                ],
                NU: [ // Nunavut
                    { min: 0, max: 50877, rate: 0.04 },
                    { min: 50877, max: 101754, rate: 0.07 },
                    { min: 101754, max: 165429, rate: 0.09 },
                    { min: 165429, max: Infinity, rate: 0.115 }
                ],
                YT: [ // Yukon
                    { min: 0, max: 55967, rate: 0.064 },
                    { min: 55967, max: 111733, rate: 0.09 },
                    { min: 111733, max: 173205, rate: 0.109 },
                    { min: 173205, max: 500000, rate: 0.128 },
                    { min: 500000, max: Infinity, rate: 0.15 }
                ]
            }
        };

        function calculateTaxes() {
            const yearlyIncome = parseFloat(document.getElementById('grossYearlyIncome').value) || 0;
            const province = document.getElementById('provinceValue').textContent;
            const provinceCode = getProvinceCode(province);
            
            if (yearlyIncome <= 0) {
                alert('Please enter a valid yearly income');
                return;
            }
            
            // Calculate federal tax
            const federalTax = calculateTax(yearlyIncome, TAX_BRACKETS_2024.federal);
            
            // Calculate provincial tax
            const provincialTax = calculateTax(yearlyIncome, TAX_BRACKETS_2024.provinces[provinceCode]);
            
            // Calculate CPP/EI (2024 rates)
            const cppContribution = Math.min(yearlyIncome, 68500) * 0.0595; // 5.95% up to $68,500
            const eiContribution = Math.min(yearlyIncome, 63100) * 0.0163; // 1.63% up to $63,100
            const totalCppEi = cppContribution + eiContribution;
            
            // Calculate monthly amounts
            const monthlyGross = yearlyIncome / 12;
            const monthlyFederalTax = federalTax / 12;
            const monthlyProvincialTax = provincialTax / 12;
            const monthlyCppEi = totalCppEi / 12;
            const monthlyNet = monthlyGross - monthlyFederalTax - monthlyProvincialTax - monthlyCppEi;
            
            // Display results
            document.getElementById('monthlyGrossResult').textContent = formatCurrency(monthlyGross);
            document.getElementById('federalTaxResult').textContent = formatCurrency(monthlyFederalTax);
            document.getElementById('provincialTaxResult').textContent = formatCurrency(monthlyProvincialTax);
            document.getElementById('cppEiResult').textContent = formatCurrency(monthlyCppEi);
            document.getElementById('netIncomeResult').textContent = formatCurrency(monthlyNet);
            
            // Show results section
            document.getElementById('taxResults').style.display = 'block';
            
            // Auto-populate manual override fields
            document.getElementById('grossIncome').value = monthlyGross.toFixed(2);
            document.getElementById('federalTax').value = monthlyFederalTax.toFixed(2);
            document.getElementById('provincialTax').value = monthlyProvincialTax.toFixed(2);
            document.getElementById('cppEi').value = monthlyCppEi.toFixed(2);
            document.getElementById('netIncome').value = monthlyNet.toFixed(2);
            
            // Update budget summary - this function is now deprecated since budget is in its own slide-out
            // updateSimpleBudgetSummary();
        }

        function calculateTax(income, brackets) {
            let totalTax = 0;
            
            for (let bracket of brackets) {
                if (income > bracket.min) {
                    const taxableInBracket = Math.min(income - bracket.min, bracket.max - bracket.min);
                    totalTax += taxableInBracket * bracket.rate;
                }
            }
            
            return totalTax;
        }

        function getProvinceCode(provinceName) {
            const provinceMap = {
                'Ontario': 'ON',
                'British Columbia': 'BC',
                'Alberta': 'AB',
                'Saskatchewan': 'SK',
                'Manitoba': 'MB',
                'Quebec': 'QC',
                'New Brunswick': 'NB',
                'Nova Scotia': 'NS',
                'Prince Edward Island': 'PE',
                'Newfoundland and Labrador': 'NL',
                'Northwest Territories': 'NT',
                'Nunavut': 'NU',
                'Yukon': 'YT'
            };
            return provinceMap[provinceName] || 'ON';
        }

        function toggleAccordion(id) {
            const header = document.querySelector(`[onclick="toggleAccordion('${id}')"]`);
            const content = document.getElementById(`${id}Content`);
            const icon = document.getElementById(`${id}Icon`);
            
            const isExpanded = header.classList.contains('expanded');
            
            if (isExpanded) {
                // Collapse
                header.classList.remove('expanded');
                content.classList.remove('expanded');
            } else {
                // Expand
                header.classList.add('expanded');
                content.classList.add('expanded');
            }
        }

        // Add event listeners for settings inputs
        document.addEventListener('DOMContentLoaded', function() {
            // Budget form event listeners are now handled in the budget slide-out
            // The old settings form elements no longer exist

            // Setup province dropdown
            const provinceItems = document.querySelectorAll('#provinceContent .select-item');
            provinceItems.forEach(item => {
                item.addEventListener('click', function() {
                    const value = this.getAttribute('data-value');
                    const text = this.textContent;
                    selectSlideOutOption('province', value, text);
                });
            });
            
            // Setup budget province dropdown
            const budgetProvinceItems = document.querySelectorAll('#budgetProvinceContent .select-item');
            budgetProvinceItems.forEach(item => {
                item.addEventListener('click', function() {
                    const value = this.getAttribute('data-value');
                    const text = this.textContent;
                    selectSlideOutOption('budgetProvince', value, text);
                });
            });
            
            // Add event listeners for budget form inputs
            ['budgetGrossYearlyIncome','budgetGrossIncome','budgetFederalTax','budgetProvincialTax','budgetCppEi','budgetNetIncome','budgetAnnualSavingsGoal','budgetFixedExpenses','budgetEssentialExpenses','budgetDiscretionaryExpenses'].forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.addEventListener('input', function() {
                        updateBudgetSummary();
                    });
                }
            });
        });

        function openBudgetSetup() {
            // Don't close settings, just slide to budget setup
            const budgetOverlay = document.getElementById('budgetOverlay');
            const budgetPanel = document.getElementById('budgetPanel');
            const settingsPanel = document.getElementById('settingsPanel');
            const appContainer = document.querySelector('.app-container');
            
            // Show budget overlay and panel
            budgetOverlay.classList.add('active');
            budgetPanel.classList.add('active');
            
            // Slide settings panel left
            settingsPanel.classList.add('budget-open');
            
            // Add slide transition to main content
            appContainer.classList.add('settings-open');
            
            // Load existing settings into budget form
            loadBudgetSettings();
        }
        
        function closeBudgetSetup() {
            const budgetOverlay = document.getElementById('budgetOverlay');
            const budgetPanel = document.getElementById('budgetPanel');
            const settingsPanel = document.getElementById('settingsPanel');
            const appContainer = document.querySelector('.app-container');
            
            // Hide budget overlay and panel
            budgetOverlay.classList.remove('active');
            budgetPanel.classList.remove('active');
            
            // Slide settings panel back to center
            settingsPanel.classList.remove('budget-open');
            
            // Remove slide transition from main content
            appContainer.classList.remove('settings-open');
        }
        
        function loadBudgetSettings() {
            const settings = getSimpleBudgetSettings();
            
            // Populate form fields with existing settings
            document.getElementById('budgetGrossYearlyIncome').value = settings.grossYearlyIncome || '';
            document.getElementById('budgetProvinceValue').textContent = settings.province || 'Ontario';
            document.getElementById('budgetGrossIncome').value = settings.grossIncome || '';
            document.getElementById('budgetFederalTax').value = settings.federalTax || '';
            document.getElementById('budgetProvincialTax').value = settings.provincialTax || '';
            document.getElementById('budgetCppEi').value = settings.cppEi || '';
            document.getElementById('budgetNetIncome').value = settings.netIncome || '';
            document.getElementById('budgetAnnualSavingsGoal').value = settings.annualSavingsGoal || '';
            document.getElementById('budgetFixedExpenses').value = settings.fixedExpenses || '';
            document.getElementById('budgetEssentialExpenses').value = settings.essentialExpenses || '';
            document.getElementById('budgetDiscretionaryExpenses').value = settings.discretionaryExpenses || '';
            
            // Update budget summary
            updateBudgetSummary();
        }
        
        function calculateBudgetTaxes() {
            const yearlyIncome = parseFloat(document.getElementById('budgetGrossYearlyIncome').value) || 0;
            const province = document.getElementById('budgetProvinceValue').textContent;
            const provinceCode = getProvinceCode(province);
            
            if (yearlyIncome <= 0) {
                alert('Please enter a valid yearly income');
                return;
            }
            
            // Calculate federal tax
            const federalTax = calculateTax(yearlyIncome, TAX_BRACKETS_2024.federal);
            
            // Calculate provincial tax
            const provincialTax = calculateTax(yearlyIncome, TAX_BRACKETS_2024.provinces[provinceCode]);
            
            // Calculate CPP/EI (2024 rates)
            const cppContribution = Math.min(yearlyIncome, 68500) * 0.0595; // 5.95% up to $68,500
            const eiContribution = Math.min(yearlyIncome, 63100) * 0.0163; // 1.63% up to $63,100
            const totalCppEi = cppContribution + eiContribution;
            
            // Calculate monthly amounts
            const monthlyGross = yearlyIncome / 12;
            const monthlyFederalTax = federalTax / 12;
            const monthlyProvincialTax = provincialTax / 12;
            const monthlyCppEi = totalCppEi / 12;
            const monthlyNet = monthlyGross - monthlyFederalTax - monthlyProvincialTax - monthlyCppEi;
            
            // Display results
            document.getElementById('budgetMonthlyGrossResult').textContent = formatCurrency(monthlyGross);
            document.getElementById('budgetFederalTaxResult').textContent = formatCurrency(monthlyFederalTax);
            document.getElementById('budgetProvincialTaxResult').textContent = formatCurrency(monthlyProvincialTax);
            document.getElementById('budgetCppEiResult').textContent = formatCurrency(monthlyCppEi);
            document.getElementById('budgetNetIncomeResult').textContent = formatCurrency(monthlyNet);
            
            // Show results section
            document.getElementById('budgetTaxResults').style.display = 'block';
            
            // Auto-populate manual override fields
            document.getElementById('budgetGrossIncome').value = monthlyGross.toFixed(2);
            document.getElementById('budgetFederalTax').value = monthlyFederalTax.toFixed(2);
            document.getElementById('budgetProvincialTax').value = monthlyProvincialTax.toFixed(2);
            document.getElementById('budgetCppEi').value = monthlyCppEi.toFixed(2);
            document.getElementById('budgetNetIncome').value = monthlyNet.toFixed(2);
            
            // Update budget summary
            updateBudgetSummary();
        }
        
        function updateBudgetSummary() {
            const grossIncome = parseFloat(document.getElementById('budgetGrossIncome').value) || 0;
            const federalTax = parseFloat(document.getElementById('budgetFederalTax').value) || 0;
            const provincialTax = parseFloat(document.getElementById('budgetProvincialTax').value) || 0;
            const cppEi = parseFloat(document.getElementById('budgetCppEi').value) || 0;
            const netIncome = parseFloat(document.getElementById('budgetNetIncome').value) || 0;
            const annualSavingsGoal = parseFloat(document.getElementById('budgetAnnualSavingsGoal').value) || 0;
            const fixedExpenses = parseFloat(document.getElementById('budgetFixedExpenses').value) || 0;
            const essentialExpenses = parseFloat(document.getElementById('budgetEssentialExpenses').value) || 0;
            const discretionaryExpenses = parseFloat(document.getElementById('budgetDiscretionaryExpenses').value) || 0;
            
            // Calculate monthly savings target
            const monthlySavingsTarget = annualSavingsGoal / 12;
            document.getElementById('budgetMonthlySavingsTarget').value = monthlySavingsTarget.toFixed(2);
            
            // Calculate remaining budget
            const totalExpenses = fixedExpenses + essentialExpenses + discretionaryExpenses + monthlySavingsTarget;
            const remainingBudget = netIncome - totalExpenses;
            
            // Calculate savings rate
            const savingsRate = netIncome > 0 ? (monthlySavingsTarget / netIncome) * 100 : 0;
            
            // Update summary display
            document.getElementById('budgetRemainingBudgetSummary').textContent = formatCurrency(remainingBudget);
            document.getElementById('budgetSavingsRateSummary').textContent = savingsRate.toFixed(1) + '%';
            
            // Validation
            let validationText = '-';
            let validationClass = '';
            
            if (remainingBudget < 0) {
                validationText = 'Over Budget';
                validationClass = 'negative';
            } else if (remainingBudget < 100) {
                validationText = 'Tight Budget';
                validationClass = 'warning';
            } else {
                validationText = 'Good Budget';
                validationClass = 'positive';
            }
            
            const validationElement = document.getElementById('budgetValidationSummary');
            validationElement.textContent = validationText;
            validationElement.className = 'budget-value ' + validationClass;
        }
        
        function saveBudgetSettings() {
            // Calculate monthly savings target first
            const annualSavingsGoal = parseFloat(document.getElementById('budgetAnnualSavingsGoal').value) || 0;
            const monthlySavingsTarget = annualSavingsGoal / 12;
            
            const settings = {
                grossYearlyIncome: parseFloat(document.getElementById('budgetGrossYearlyIncome').value) || 0,
                province: document.getElementById('budgetProvinceValue').textContent,
                grossIncome: parseFloat(document.getElementById('budgetGrossIncome').value) || 0,
                federalTax: parseFloat(document.getElementById('budgetFederalTax').value) || 0,
                provincialTax: parseFloat(document.getElementById('budgetProvincialTax').value) || 0,
                cppEi: parseFloat(document.getElementById('budgetCppEi').value) || 0,
                netIncome: parseFloat(document.getElementById('budgetNetIncome').value) || 0,
                annualSavingsGoal: annualSavingsGoal,
                monthlySavingsTarget: monthlySavingsTarget, // Save monthly savings target
                fixedExpenses: parseFloat(document.getElementById('budgetFixedExpenses').value) || 0,
                essentialExpenses: parseFloat(document.getElementById('budgetEssentialExpenses').value) || 0,
                discretionaryExpenses: parseFloat(document.getElementById('budgetDiscretionaryExpenses').value) || 0
            };
            
            localStorage.setItem('simpleBudgetSettings', JSON.stringify(settings));
            
            // Update the save target display after saving
            updateSaveTargetDisplay();
            
            // Update the main app's budget display
            updateBudgetDisplay();
            
            // Close the budget setup
            closeBudgetSetup();
            
            // Show success message
            alert('Budget settings saved successfully!');
        }
        function loadSampleBudget() {
            loadTestData();
        }
        
        function clearAllData() {
            // Confirm before clearing all data
            if (confirm("Are you sure you want to clear all data? This action cannot be undone.")) {
                try {
                    // Clear all application-related data from localStorage
                    const keysToRemove = [
                        'accountBalances',
                        'dailyExpenses',
                        'expenses',
                        'simpleBudgetSettings',
                        'savingsAccounts',
                        'budgetSettings'
                    ];
                    
                    // Clear each key
                    keysToRemove.forEach(key => {
                        console.log(`Removing localStorage key: ${key}`);
                        localStorage.removeItem(key);
                    });
                    
                    // For additional safety, clear all localStorage
                    console.log('Clearing all localStorage');
                    localStorage.clear();
                    
                    // Reload the page to reflect changes
                    alert("All data has been cleared successfully.");
                    window.location.reload();
                } catch (error) {
                    console.error('Error clearing data:', error);
                    alert("An error occurred while clearing data.");
                }
            }
        }
        
        function openSupport() {
            // Don't close settings, just slide to support page
            const supportOverlay = document.getElementById('supportOverlay');
            const supportPanel = document.getElementById('supportPanel');
            const settingsPanel = document.getElementById('settingsPanel');
            const appContainer = document.querySelector('.app-container');
            
            // Show support overlay and panel
            supportOverlay.classList.add('active');
            supportPanel.classList.add('active');
            
            // Slide settings panel left
            settingsPanel.classList.add('budget-open');
            
            // Add slide transition to main content
            appContainer.classList.add('settings-open');
        }
        
        function closeSupport() {
            const supportOverlay = document.getElementById('supportOverlay');
            const supportPanel = document.getElementById('supportPanel');
            const settingsPanel = document.getElementById('settingsPanel');
            const appContainer = document.querySelector('.app-container');
            
            // Hide support overlay and panel
            supportOverlay.classList.remove('active');
            supportPanel.classList.remove('active');
            
            // Slide settings panel back to center
            settingsPanel.classList.remove('budget-open');
            
            // Remove slide transition from main content
            appContainer.classList.remove('settings-open');
            
            // Clear form fields
            document.getElementById('supportTitle').value = '';
            document.getElementById('supportDescription').value = '';
        }
        
        function sendSupportEmail() {
            const title = document.getElementById('supportTitle').value.trim();
            const description = document.getElementById('supportDescription').value.trim();
            
            if (!title || !description) {
                alert('Please fill in both subject and message fields.');
                return;
            }
            
            // Create mailto link
            const subject = encodeURIComponent(`Expense Tracker Support: ${title}`);
            const body = encodeURIComponent(`Subject: ${title}\n\nMessage:\n${description}\n\n---\nSent from Expense Tracker App`);
            const mailtoLink = `mailto:wdean.francis@gmail.com?subject=${subject}&body=${body}`;
            
            // Open email client
            window.location.href = mailtoLink;
            
            // Close support page
            closeSupport();
            
            // Show success message
            alert('Email client opened! Please send the email to complete your support request.');
        }
        function backToSettingsMenu() {
            document.getElementById('settingsForm').style.display = 'none';
            document.getElementById('settingsMenu').style.display = '';
        }


        // --- Expense Editing Support ---
        let editingExpense = null;
        function editExpense(date, timestamp) {
            const expenses = loadExpenses();
            const expenseList = expenses[date] || [];
            const expense = expenseList.find(e => e.timestamp === Number(timestamp));
            if (!expense) return;
            editingExpense = { date, timestamp: Number(timestamp) };
            showExpenseSlideOut();
            // Set date (for month mode)
            if (currentPeriodMode === 'month') {
                const datepickerId = 'expenseCustomDatepicker';
                if (!datepickerStates[datepickerId]) {
                    initializeDatepicker(datepickerId);
                }
                const state = datepickerStates[datepickerId];
                // Parse date properly to avoid timezone issues
                const dateParts = date.split('-').map(Number);
                state.selectedDate = new Date(dateParts[0], dateParts[1] - 1, dateParts[2]);
                updateDatepickerValue(datepickerId);
                renderCalendar(datepickerId);
            }
            document.getElementById('slideOutExpenseAmount').value = expense.amount;
            selectSlideOutOption('expenseCategory', expense.category, capitalizeFirstLetter(expense.category));
            document.getElementById('slideOutExpenseDescription').value = expense.description || '';
            // Change CTA text and handler
            const ctaBtn = document.querySelector('.slide-out-form .add-btn');
            if (ctaBtn) {
                ctaBtn.textContent = 'Save Expense';
                ctaBtn.onclick = saveEditedExpense;
            }
        }
        function saveEditedExpense() {
            if (!editingExpense) return;
            const amount = parseFloat(document.getElementById('slideOutExpenseAmount').value);
            const category = document.getElementById('slideOutExpenseCategory').value;
            const description = document.getElementById('slideOutExpenseDescription').value;
            let targetDate = currentPeriodMode === 'month'
                ? document.getElementById('slideOutExpenseDate').value
                : getCurrentDate();
            if (!amount || amount <= 0) {
                alert('Please enter a valid amount');
                return;
            }
            if (!category) {
                alert('Please select a category');
                return;
            }
            const expenses = loadExpenses();
            // Remove the old expense and get its index
            let oldList = expenses[editingExpense.date] || [];
            const oldIndex = oldList.findIndex(e => e.timestamp === editingExpense.timestamp);
            const oldExpense = oldList.find(e => e.timestamp === editingExpense.timestamp);
            
            // Preserve the original created timestamp
            const created = oldExpense && oldExpense.created ? oldExpense.created : editingExpense.timestamp;
            
            // Remove the old expense
            oldList = oldList.filter(e => e.timestamp !== editingExpense.timestamp);
            expenses[editingExpense.date] = oldList;
            
            // Create the updated expense
            const updatedExpense = {
                amount,
                category,
                description: description || '',
                timestamp: editingExpense.timestamp,
                created: created, // Preserve original created timestamp
                updated: Date.now()
            };
            
            // Add the updated expense at the same index if date is unchanged, else push to new date
            if (!expenses[targetDate]) expenses[targetDate] = [];
            
            if (editingExpense.date === targetDate && oldIndex !== -1) {
                // Insert at the same position to maintain order
                expenses[targetDate].splice(oldIndex, 0, updatedExpense);
            } else {
                // If date changed, add to the end of the new date's list
                expenses[targetDate].push(updatedExpense);
            }
            saveExpenses(expenses);
            // Reset form and editing state
            document.getElementById('slideOutExpenseAmount').value = '';
            document.getElementById('slideOutExpenseDescription').value = '';
            selectSlideOutOption('expenseCategory', 'groceries', 'Groceries');
            if (currentPeriodMode === 'month') clearDate('expenseCustomDatepicker');
            editingExpense = null;
            // Restore CTA
            const ctaBtn = document.querySelector('.slide-out-form .add-btn');
            if (ctaBtn) {
                ctaBtn.textContent = 'Add Expense';
                ctaBtn.onclick = addExpenseFromSlideOut;
            }
            hideExpenseSlideOut();
            updatePeriodView();
            updateChart();
        }
        function capitalizeFirstLetter(str) {
            return str.charAt(0).toUpperCase() + str.slice(1);
        }
        function handleExpenseDelete(element, e) {
            // Use the provided event or the global event
            const evt = e || window.event;
            
            // Stop propagation immediately to prevent any click events from bubbling
            if (evt) {
                evt.preventDefault();
                evt.stopPropagation();
            }
            
            console.log('handleExpenseDelete called');
            
            // Find the parent swipe-container and get its data attributes
            const container = element.closest('.swipe-container');
            if (!container) {
                console.error('Could not find parent swipe container');
                return;
            }
            
            // Get expense data from the container
            const date = container.dataset.date;
            const timestamp = container.dataset.timestamp;
            
            console.log('Expense data from container:', { date, timestamp });
            
            if (!date || !timestamp) {
                console.error('Missing date or timestamp for expense deletion');
                return;
            }
            
            // Add visual feedback - mark container as deleting
            container.classList.add('deleting');
            
            // Call deleteExpense with the data after a short delay to allow animation
            setTimeout(() => {
                deleteExpense(date, timestamp);
            }, 10); // Short timeout to ensure animation starts
}

        function handleBalanceDelete(element, e) {
            // Use the provided event or the global event
            const evt = e || window.event;
            
            // Stop propagation immediately to prevent any click events from bubbling
            if (evt) {
                evt.preventDefault();
                evt.stopPropagation();
            }
            
            console.log('handleBalanceDelete called');
            
            // Find the parent swipe-container and get its data attributes
            const container = element.closest('.swipe-container');
            if (!container) {
                console.error('Could not find parent swipe container');
                return;
            }
            
            // Get balance data from the container
            const accountId = container.dataset.accountId;
            const date = container.dataset.date;
            
            console.log('Balance data from container:', { accountId, date });
            
            if (!accountId || !date) {
                console.error('Missing accountId or date for balance deletion');
                return;
            }
            
            // Add visual feedback - mark container as deleting
            container.classList.add('deleting');
            
            // Call deleteBalance with the data
            setTimeout(() => {
                deleteBalance(accountId, date);
            }, 10); // Short timeout to ensure animation starts
        }


    </script>
    </body>
</html>